<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>The PDL Book</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
</head>

<body>



<ul id="index">
  <li><a href="#Forward">Forward</a>
    <ul>
      <li><a href="#List-of-Chapters">List of Chapters</a></li>
      <li><a href="#Suggested-Reading-Orders">Suggested Reading Orders</a></li>
    </ul>
  </li>
  <li><a href="#First-Steps-with-PDL">First Steps with PDL</a>
    <ul>
      <li><a href="#Alright-lets-do-something">Alright, let&#39;s do something</a></li>
      <li><a href="#Whirling-through-the-Whirlpool">Whirling through the Whirlpool</a></li>
      <li><a href="#Measuring-the-brightness-of-M51">Measuring the brightness of M51</a></li>
      <li><a href="#Twinkle-twinkle-little-star">Twinkle, twinkle, little star</a></li>
      <li><a href="#Getting-Complex-with-M51">Getting Complex with M51</a></li>
      <li><a href="#Roundoff">Roundoff</a></li>
    </ul>
  </li>
  <li><a href="#What-is-an-NDArray">What is an NDArray?</a>
    <ul>
      <li><a href="#NDArrays-are-NOT-Perl-arrays">NDArrays are NOT Perl &quot;arrays&quot;</a></li>
    </ul>
  </li>
  <li><a href="#Constructing-PDLs">Constructing PDLs</a>
    <ul>
      <li><a href="#The-basic-constructor-pdl">The basic constructor, pdl()</a></li>
      <li><a href="#Array-allocation:-zeroes-and-ones">Array allocation: zeroes() and ones()</a></li>
      <li><a href="#Index-PDLs:-xvals-yvals-rvals-sequence-ndcoords">Index PDLs: xvals, yvals, rvals, sequence, ndcoords</a></li>
      <li><a href="#Specialty-constructors">Specialty constructors</a></li>
      <li><a href="#Getting-values-into-and-out-of-PDLs">Getting values into and out of PDLs</a>
        <ul>
          <li><a href="#Construction:-slurping-Perl-arrays">Construction: slurping Perl arrays</a></li>
          <li><a href="#Assignment-with">Assignment with .=</a></li>
          <li><a href="#Importing-data-directly-from-memory:-get_dataref">Importing data directly from memory: get_dataref</a></li>
          <li><a href="#Conversion-to-Perl-types:-at-list-and-unpdl">Conversion to Perl types: at, list, and unpdl</a></li>
        </ul>
      </li>
      <li><a href="#Data-Types-and-Contexts">Data Types and Contexts</a>
        <ul>
          <li><a href="#Refresher-on-Perl-Data-Types-Contexts">Refresher on Perl Data Types &amp; Contexts</a></li>
          <li><a href="#PDL-Data-Types">PDL Data Types</a></li>
          <li><a href="#PDLs-and-Perl-Contexts">PDLs and Perl Contexts</a></li>
          <li><a href="#BAD-Values">BAD Values</a></li>
        </ul>
      </li>
      <li><a href="#Dataflow">Dataflow</a></li>
      <li><a href="#Broadcasting">Broadcasting</a>
        <ul>
          <li><a href="#Broadcasting-rules">Broadcasting rules</a></li>
          <li><a href="#Controlling-broadcasting-and-dimension-order:-xchg-mv-reorder-flat-clump-and-reshape">Controlling broadcasting and dimension order: xchg, mv, reorder, flat, clump, and reshape</a></li>
          <li><a href="#Dummy-Dimensions">Dummy Dimensions</a></li>
          <li><a href="#Collapse-Reduce-Operators-and-Reduction">Collapse/Reduce Operators and Reduction</a></li>
          <li><a href="#PDL-Headers">PDL Headers</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#Slicing-Dicing-and-Broadcasting-dims-with-PDL">Slicing, Dicing and Broadcasting dims with PDL</a>
    <ul>
      <li><a href="#Finding-ndarray-dimensions">Finding ndarray dimensions.</a></li>
      <li><a href="#The-slice-function---regular-subsets-along-axes">The slice function - regular subsets along axes</a>
        <ul>
          <li><a href="#The-basic-slicing-specification">The basic slicing specification.</a></li>
          <li><a href="#Modifying-slices">Modifying slices.</a></li>
          <li><a href="#Does-a-slice-consume-memory">Does a slice consume memory?</a></li>
          <li><a href="#Advanced-slice-syntax">Advanced slice syntax</a></li>
          <li><a href="#PDLs-Method-notation">PDL&#39;s Method notation</a></li>
        </ul>
      </li>
      <li><a href="#The-dice-and-dice_axis-functions---irregular-subsets-along-axes">The dice and dice_axis functions - irregular subsets along axes</a></li>
      <li><a href="#Using-mv-xchg-and-reorder---transposing-dimensions">Using mv, xchg and reorder - transposing dimensions</a></li>
      <li><a href="#Combining-dimensions-with-clump">Combining dimensions with clump</a></li>
      <li><a href="#Adding-dimensions-with-dummy">Adding dimensions with dummy</a></li>
      <li><a href="#Completely-general-subsets-of-data-with-index-which-and-where">Completely general subsets of data with index , which and where</a></li>
      <li><a href="#PDL-broadcasting-and-signatures">PDL broadcasting and signatures</a>
        <ul>
          <li><a href="#Broadcasting1">Broadcasting</a></li>
          <li><a href="#A-simple-example">A simple example</a></li>
          <li><a href="#Why-bother">Why bother?</a></li>
          <li><a href="#More-examples">More examples</a></li>
          <li><a href="#Why-broadcasting-and-why-call-it-broadcasting">Why broadcasting and why call it broadcasting ?</a></li>
          <li><a href="#The-general-case:-PDL-functions-and-their-signature">The general case: PDL functions and their signature</a></li>
          <li><a href="#You-can-write-your-own-broadcasting-routines">You can write your own broadcasting routines</a></li>
          <li><a href="#Matching-broadcasting-dimensions">Matching broadcasting dimensions</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#Writing-your-own-functions-into-PDL">Writing your own functions into PDL</a>
    <ul>
      <li><a href="#Using-PDL-Functions">Using PDL Functions</a></li>
      <li><a href="#Moving-Functions-into-Separate-Files">Moving Functions into Separate Files</a></li>
      <li><a href="#Getting-PDL-to-look-for-your-functions-in-other-places">Getting PDL to look for your functions in other places</a></li>
      <li><a href="#Documenting-your-Functions">Documenting your Functions</a></li>
    </ul>
  </li>
  <li><a href="#Graphics-with-PGPLOT">Graphics with PGPLOT</a>
    <ul>
      <li><a href="#Introducing-PDL::Graphics::PGPLOT">Introducing PDL::Graphics::PGPLOT</a></li>
      <li><a href="#An-overview-of-2D-plotting-commands">An overview of 2D plotting commands</a></li>
      <li><a href="#Options-in-plot-commands">Options in plot commands</a></li>
      <li><a href="#Hard-copies-and-plot-options">Hard-copies and plot options</a>
        <ul>
          <li><a href="#Setting-default-values-for-options">Setting default values for options</a></li>
          <li><a href="#Setting-up-the-plot-area">Setting up the plot area</a></li>
        </ul>
      </li>
      <li><a href="#Drawing-lines-and-plotting-points">Drawing lines and plotting points</a></li>
      <li><a href="#Plotting-error-bars">Plotting error-bars</a></li>
      <li><a href="#Drawing-lines">Drawing lines</a></li>
      <li><a href="#Plotting-histograms">Plotting histograms</a></li>
      <li><a href="#Drawing-polygons">Drawing polygons</a></li>
      <li><a href="#Displaying-images">Displaying images</a></li>
      <li><a href="#Transforms">Transforms</a></li>
      <li><a href="#Colour-bar-wedge">Colour bar/wedge</a></li>
      <li><a href="#Contour-plots-and-vector-fields">Contour plots and vector fields</a></li>
      <li><a href="#Drawing-simple-shapes">Drawing simple shapes</a></li>
      <li><a href="#Text-and-legends">Text and legends</a>
        <ul>
          <li><a href="#Non-alphanumeric-symbols">Non-alphanumeric symbols</a></li>
        </ul>
      </li>
      <li><a href="#Labeling-your-figures-in-PGPLOT">Labeling your figures in PGPLOT</a></li>
      <li><a href="#Using-colour">Using colour</a></li>
      <li><a href="#Broadcasting-in-PDL::Graphics::PGPLOT">Broadcasting in PDL::Graphics::PGPLOT</a></li>
      <li><a href="#Recording-and-playing-back-plot-commands">Recording and playing back plot commands</a>
        <ul>
          <li><a href="#Redoing-a-plot-with-slightly-different-data">Redoing a plot with slightly different data</a></li>
          <li><a href="#Using-recording-in-scripts">Using recording in scripts</a></li>
        </ul>
      </li>
      <li><a href="#The-object-oriented-approach">The object oriented approach</a>
        <ul>
          <li><a href="#Why-use-the-OO-interface">Why use the OO interface</a></li>
          <li><a href="#Usage-of-the-OO-interface">Usage of the OO interface</a></li>
        </ul>
      </li>
      <li><a href="#Using-PGPLOT-commands-directly">Using PGPLOT commands directly</a></li>
    </ul>
  </li>
  <li><a href="#Graphics-with-PLplot">Graphics with PLplot</a>
    <ul>
      <li><a href="#Introducing-PDL::Graphics::PLplot">Introducing PDL::Graphics::PLplot</a></li>
      <li><a href="#Plotting-a-simple-parabola">Plotting a simple parabola</a></li>
      <li><a href="#Object-Oriented-Examples">Object Oriented Examples</a>
        <ul>
          <li><a href="#Axis-labelling-and-titles">Axis labelling and titles</a></li>
        </ul>
      </li>
      <li><a href="#Interactive-crosshairs-with-the-wxwidgets-output-device">Interactive crosshairs with the wxwidgets output device</a></li>
      <li><a href="#Setting-the-DEV-and-FILE-options-and-using-the-aliased-option-for-new">Setting the DEV and FILE options, and using the aliased option for new()</a></li>
      <li><a href="#Outputting-postscript">Outputting postscript</a></li>
      <li><a href="#Tools-for-plotting-points">Tools for plotting points</a></li>
      <li><a href="#A-Symbols-example">A Symbols example</a></li>
      <li><a href="#Plotting-multiple-curves">Plotting multiple curves</a>
        <ul>
          <li><a href="#Plotting-multiple-curves-with-a-multi-dimensional-ndarray">Plotting multiple curves with a multi-dimensional ndarray</a></li>
          <li><a href="#Colorizing-multiple-data-sets">Colorizing multiple data sets</a></li>
          <li><a href="#Plotting-multiple-curves-with-differently-colored-calls-to-xyplot">Plotting multiple curves with differently colored calls to xyplot</a></li>
          <li><a href="#A-multiple-curve-with-xyplot">A multiple curve with xyplot</a></li>
          <li><a href="#Solving-curve-clipping-on-multiple-xyplots-with-the-BOX-option">Solving curve clipping on multiple xyplots with the BOX option</a></li>
          <li><a href="#Plotting-multiple-curves-with-stripplot">Plotting multiple curves with stripplot</a></li>
          <li><a href="#Stripplots-and-reading-DATA-with-rcols">Stripplots and reading DATA with rcols</a></li>
          <li><a href="#Multiple-plots-with-SUBPAGE">Multiple plots with SUBPAGE</a></li>
        </ul>
      </li>
      <li><a href="#Boxes-and-Viewports">Boxes and Viewports</a>
        <ul>
          <li><a href="#Using-Insets">Using Insets</a></li>
        </ul>
      </li>
      <li><a href="#Basics-of-viewports">Basics of viewports</a></li>
      <li><a href="#Surface-dimensions">Surface dimensions</a></li>
      <li><a href="#Viewport-positioning">Viewport positioning</a>
        <ul>
          <li><a href="#The-clipping-box">The clipping box</a></li>
          <li><a href="#Page-size">Page size</a></li>
          <li><a href="#Viewport-upper-right">Viewport upper right</a></li>
          <li><a href="#Viewport-centered">Viewport centered</a></li>
          <li><a href="#Viewport-extreme-bounds">Viewport extreme bounds</a></li>
          <li><a href="#Viewport-multiple-plots">Viewport multiple plots</a></li>
          <li><a href="#The-basic-box">The basic box</a></li>
          <li><a href="#The-tweaked-box">The tweaked box</a></li>
          <li><a href="#Box-with-2-plots">Box with 2 plots</a></li>
          <li><a href="#Multiple-plots-changing-the-box-within-a-single-viewport">Multiple plots, changing the box within a single viewport</a></li>
          <li><a href="#Box-and-viewport-summary">Box and viewport summary</a></li>
        </ul>
      </li>
      <li><a href="#Other-types-of-plot">Other types of plot</a>
        <ul>
          <li><a href="#Shadeplot">Shadeplot</a></li>
          <li><a href="#Histogram">Histogram</a></li>
          <li><a href="#Histogram-height">Histogram height</a></li>
          <li><a href="#Bargraph">Bargraph</a></li>
          <li><a href="#Bargraph-color-and-bar-height">Bargraph color and bar height</a></li>
          <li><a href="#Bargraph-with-labelling">Bargraph with labelling</a></li>
        </ul>
      </li>
      <li><a href="#Using-the-MEM-device">Using the MEM device</a>
        <ul>
          <li><a href="#Creating-a-MEM-memory-buffer">Creating a MEM memory buffer</a></li>
          <li><a href="#Plotting-over-an-image-with-the-MEM-device">Plotting over an image with the MEM device</a></li>
        </ul>
      </li>
      <li><a href="#Functional-programming-style-examples">Functional programming style examples</a>
        <ul>
          <li><a href="#Simple-line-plot-and-multiple-windows-demo-x01">Simple line plot and multiple windows demo x01</a></li>
          <li><a href="#Multiple-window-and-color-map-0-demo-x02">Multiple window and color map 0 demo x02</a></li>
          <li><a href="#Polar-plot-demo-x03">Polar plot demo x03</a></li>
          <li><a href="#Log-plot-demo-x04">Log plot demo x04</a></li>
          <li><a href="#Histogram-demo-x05">Histogram demo x05</a></li>
          <li><a href="#Font-demo-x06">Font demo x06</a></li>
          <li><a href="#Font-demo-x07">Font demo x07</a></li>
          <li><a href="#d-plot-demo-x08">3-d plot demo x08</a></li>
          <li><a href="#Contour-plot-demo-x09">Contour plot demo x09</a></li>
          <li><a href="#Window-positioning-demo-x10">Window positioning demo x10</a></li>
          <li><a href="#Mesh-plot-demo-x11">Mesh plot demo x11</a></li>
          <li><a href="#Bar-chart-demo-x12">Bar chart demo x12</a></li>
          <li><a href="#simple-pie-chart-x13">simple pie chart x13</a></li>
          <li><a href="#Shade-plot-demo-x15">Shade plot demo x15</a></li>
          <li><a href="#plshade-demo-using-color-fill-x16">plshade demo, using color fill x16</a></li>
          <li><a href="#A-simple-stripchart-with-four-pens-x17">A simple stripchart with four pens x17</a></li>
          <li><a href="#d-line-and-point-plot-demo-x18">3-d line and point plot demo x18</a></li>
          <li><a href="#Backdrop-plotting-of-world-US-maps.-x19">Backdrop plotting of world, US maps. x19</a></li>
          <li><a href="#Grid-data-demo-x21">Grid data demo x21</a></li>
          <li><a href="#Simple-vector-plot-x22">Simple vector plot x22</a></li>
          <li><a href="#Displays-Greek-letters-and-mathematically-interesting-Unicode-ranges-x23">Displays Greek letters and mathematically interesting Unicode ranges x23</a></li>
          <li><a href="#Unicode-Pace-Flag-x24">Unicode Pace Flag x24</a></li>
          <li><a href="#Drawing-polygons-x25">Drawing polygons x25</a></li>
          <li><a href="#Frequency-Amplitude-and-Phase-x26">Frequency Amplitude and Phase x26</a></li>
          <li><a href="#Spirograph-curves---epitrochoids-cycolids-roulettes-x27">Spirograph curves - epitrochoids, cycolids, roulettes x27</a></li>
          <li><a href="#plmtex3-plptex3-demo-x28">plmtex3, plptex3 demo x28</a></li>
          <li><a href="#Plots-using-date-time-formatting-for-axes-x29">Plots using date / time formatting for axes x29</a></li>
          <li><a href="#Alpha-color-values-demonstration-x30">Alpha color values demonstration x30</a></li>
          <li><a href="#Using-pllegend-including-unicode-symbols-x33">Using pllegend including unicode symbols x33</a></li>
        </ul>
      </li>
      <li><a href="#Typesetting-greek-letters-symbols">Typesetting, greek letters, symbols</a>
        <ul>
          <li><a href="#A-basic-typsetting-example">A basic typsetting example</a></li>
          <li><a href="#psfrag">psfrag</a></li>
        </ul>
      </li>
      <li><a href="#annotations-and-TEXTPOSITION">annotations and TEXTPOSITION</a>
        <ul>
          <li><a href="#TEXTPOSITION-3-argument-form">TEXTPOSITION 3 argument form</a></li>
          <li><a href="#TEXTPOSITION-4-argument-form">TEXTPOSITION 4 argument form</a></li>
        </ul>
      </li>
      <li><a href="#Legends">Legends</a></li>
    </ul>
  </li>
  <li><a href="#D-Graphics-with-OpenGL">3D Graphics with OpenGL</a>
    <ul>
      <li><a href="#Introduction">Introduction</a></li>
      <li><a href="#Parametric-Graphics">Parametric Graphics</a></li>
      <li><a href="#Types-of-3D-Graphical-Objects">Types of 3D Graphical Objects</a></li>
      <li><a href="#More-than-one-Image">More than one Image</a></li>
      <li><a href="#Putting-it-all-together---cool-hacks">Putting it all together---cool hacks</a></li>
    </ul>
  </li>
  <li><a href="#The-PDL-Preprocessor">The PDL Preprocessor</a>
    <ul>
      <li><a href="#Basics">Basics</a>
        <ul>
          <li><a href="#First-Example">First Example</a></li>
          <li><a href="#Returning-Values">Returning Values</a></li>
          <li><a href="#Exercise-Set-1">Exercise Set 1</a></li>
        </ul>
      </li>
      <li><a href="#Higher-Dimensional-Functions">Higher Dimensional Functions</a>
        <ul>
          <li><a href="#Specifying-Dimensions-and-Using-Explicit-Looping">Specifying Dimensions and Using Explicit Looping</a></li>
          <li><a href="#Matrix-Matrix-Multiplication">Matrix-Matrix Multiplication</a></li>
          <li><a href="#Broadcastloops">Broadcastloops</a></li>
          <li><a href="#A-Complex-Example">A Complex Example</a></li>
          <li><a href="#Exercise-Set-2">Exercise Set 2</a></li>
        </ul>
      </li>
      <li><a href="#Tips">Tips</a></li>
      <li><a href="#Recap">Recap</a></li>
      <li><a href="#Appendix-A:-Installing-Inline::Pdlpp">Appendix A: Installing Inline::Pdlpp</a></li>
      <li><a href="#Appendix-B:-Solutions-to-Exercises">Appendix B: Solutions to Exercises</a>
        <ul>
          <li><a href="#Excercise-Set-1">Excercise Set 1</a></li>
          <li><a href="#Exercise-Set-21">Exercise Set 2</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#The-Beginnings-of-PDL">The Beginnings of PDL</a>
    <ul>
      <li><a href="#The-case-for-a-high-level-approach">The case for a high-level approach</a></li>
      <li><a href="#The-case-for-a-free-Data-Language">The case for a free Data Language</a></li>
      <li><a href="#So-why-Perl">So why Perl?</a></li>
    </ul>
  </li>
  <li><a href="#PDL-Book-Credits">PDL Book Credits</a></li>
</ul>

<h1 id="Forward">Forward</h1>

<h2 id="List-of-Chapters">List of Chapters</h2>

<dl>

<dt id="PDL::Book::FirstSteps-Trying-out-PDL-for-the-first-time"><a>PDL::Book::FirstSteps</a> Trying out PDL for the first time.</dt>
<dd>

</dd>
<dt id="PDL::Book::NDArray-What-is-a-PDL-object"><a>PDL::Book::NDArray</a> What is a PDL object?</dt>
<dd>

</dd>
<dt id="PDL::Book::Creating-Basic-Operations-to-make-PDLs"><a>PDL::Book::Creating</a> Basic Operations to make PDLs</dt>
<dd>

</dd>
<dt id="PDL::Book::NiceSlice-Cutting-out-bits-of-a-PDL"><a>PDL::Book::NiceSlice</a> Cutting out bits of a PDL</dt>
<dd>

</dd>
<dt id="PDL::Book::Functions-Writing-your-own-functions-for-PDL"><a>PDL::Book::Functions</a> Writing your own functions for PDL</dt>
<dd>

</dd>
<dt id="PDL::Book::Broadcasting-NOT-YET-Broadcasting-and-Getting-rid-of-FOR-loops"><a>PDL::Book::Broadcasting</a> (NOT YET) Broadcasting and Getting rid of FOR loops</dt>
<dd>

</dd>
<dt id="PDL::Book::PGPLOT-Graphics-with-PGPLOT"><a>PDL::Book::PGPLOT</a> Graphics with PGPLOT</dt>
<dd>

</dd>
<dt id="PDL::Book::PLplot-Graphics-with-PLplot"><a>PDL::Book::PLplot</a> Graphics with PLplot</dt>
<dd>

</dd>
<dt id="PDL::Book::TriD-3D-Graphics-with-TriD"><a>PDL::Book::TriD</a> 3D Graphics with TriD</dt>
<dd>

</dd>
<dt id="PDL::Book::Transform-NOT-YET-Rotating-Scaling-and-Translating-with-PDL::Transform"><a>PDL::Book::Transform</a> (NOT YET) Rotating, Scaling and Translating with PDL::Transform</dt>
<dd>

</dd>
<dt id="PDL::Book::Complex-NOT-YET-Complex-Numbers"><a>PDL::Book::Complex</a> (NOT YET) Complex Numbers</dt>
<dd>

</dd>
<dt id="PDL::Book::Pthreads-NOT-YET-Parallel-Computations-with-pthreads"><a>PDL::Book::Pthreads</a> (NOT YET) Parallel Computations with pthreads</dt>
<dd>

</dd>
<dt id="PDL::Book::PP-Getting-C-routines-into-PDL-with-PDL::PP"><a>PDL::Book::PP</a> Getting C routines into PDL with PDL::PP</dt>
<dd>

</dd>
<dt id="PDL::Book::Genesis-A-history-lesson-on-PDL-from-the-creator-Karl-Glazebrook"><a>PDL::Book::Genesis</a> A history lesson on PDL from the creator, Karl Glazebrook.</dt>
<dd>

</dd>
<dt id="PDL::Book::Credits-Credits-for-the-Book"><a>PDL::Book::Credits</a> Credits for the Book</dt>
<dd>

</dd>
</dl>

<h2 id="Suggested-Reading-Orders">Suggested Reading Orders</h2>

<p>We assume you know Perl, but that you are new to PDL.</p>

<p>First, try out the PDL command line by going through FirstSteps. PDL has several ways of displaying two-dimensional images and producing publication quality plots, and so we have PGPLOT and PLplot for producing two dimensional plots either in a computer window or as written file formats (PostScript, PNG, JPEG and more), and we also have the capability to produce three dimensional plots in TriD.</p>

<p>The power of PDL is in the ability to carry out broadcasting over N-dimensional PDLs. When you code with broadcasting you eliminate the multiple FOR loops that are the source of many slow-downs in code. Reading Broadcasting and Functions will get you up to speed and in the right mind-set.</p>

<p>If you require the speed of C routines in your PDL code, there is also the powerful PDL:PP capability of PDL - you can write C code INLINE in your PDL code, and it will be compiled and run when you call your Perl/PDL scripts!</p>

<p>PDL is primarily used by scientists who want access to Scientific libraries and data types, so we have Complex numbers handled by PDL and the capabilities of PDL::Transform, the Slatec libraries accessible in PDL::Slatec, and any other libraries that you can access through Perl.</p>

<h1 id="First-Steps-with-PDL">First Steps with PDL</h1>

<p><i>&quot;Maybe there are a few civilizations out there that have decided to stay home, piddle around and send out some radio waves once in a while.&quot;</i></p>

<p><i>- Annette Foglino, Space: Is Anyone Out There? Most astronomers say yes, Life, 1 Jul 1989.</i></p>

<p>It can be very frustrating to read an introductory book which takes a long time teaching you the very basics of a topic, in a &quot;Janet and John&quot; style. While you wish to learn, you are anxious to see something a bit more exciting and interesting to see what the language can do.</p>

<p>Fortunately our task in this book on PDL is made very much easier by the high-level of the language. We can take a tour through PDL, looking at the advanced features it offers without getting involved in complexity.</p>

<p>The aim of this section is to cover a breadth of PDL features rather than any in depth, to give the reader a flavour of what he or she can do using the language and a useful reference for getting started doing real work. Later sections will focus on looking at the features introduced here, in more depth.</p>

<h2 id="Alright-lets-do-something">Alright, let&#39;s <i>do</i> something</h2>

<p>We&#39;ll assume PDL is correctly installed and set up on your computer system (see <a href="http://pdl.perl.org/">http://pdl.perl.org/</a> for details of obtaining and installing PDL).</p>

<p>Many of the graphics examples in this chapter use a simplified interface to whatever PDL Graphics library you have installed. However, this simplified interface is not included with the normal PDL distribution. To get it, install PDL::Graphics::Simple from CPAN. This should do it (perhaps prefixed with &#39;sudo&#39;):</p>

<pre><code>  myhost% cpan PDL::Graphics::Simple</code></pre>

<p>For interactive use PDL comes with a program called <code>perldl</code>. This allows you to type raw PDL (and perl) commands and see the result right away. It also allows command line recall and editing (via the arrow keys) on most systems.</p>

<p>So we begin by running the <code>perldl</code> program from the system command line. On a Mac/UNIX/Linux system we would simply type <code>perldl</code> in a terminal window. On a Windows system we would type <code>perldl</code> in a command prompt window. If PDL is installed correctly this is all that is required to bring up <code>perldl</code>.</p>

<pre><code>  myhost% perldl
  perlDL shell v1.357
   PDL comes with ABSOLUTELY NO WARRANTY. For details, see the file
   &#39;COPYING&#39; in the PDL distribution. This is free software and you
   are welcome to redistribute it under certain conditions, see
   the same file for details.
  ReadLines, NiceSlice, MultiLines  enabled
  Reading PDL/default.perldlrc...
  Found docs database /usr/lib/perl5/.../PDL/pdldoc.db
  Type &#39;help&#39; for online help
  Type &#39;demo&#39; for online demos
  Loaded PDL v2.006 (supports bad values)
  pdl&gt; </code></pre>

<p>We get a whole bunch of informational messages about what it is loading for startup and the help system. Note; the startup is <i>completely</i> configurable, an advanced user can completely customize which PDL modules are loaded. We are left with the <code>pdl&gt;</code> prompt at which we can type commands. This kind of interactive program is called a &#39;shell&#39;. There is also <code>pdl2</code> which is another PDL shell with additional features, available on CPAN as <a>PDL::Perldl2</a>.</p>

<p>Let&#39;s create something, and display it:</p>

<pre><code>  pdl&gt; use PDL::Graphics::Simple
  pdl&gt; imag (sin(rvals(200,200)+1))</code></pre>

<p>The result should look like the image below - a two dimensional <code>sin</code> function. <code>rvals</code> is a handy PDL function for creating an image whose pixel values are the radial distance from the central pixel of the image. With these arguments it creates a 200 by 200 &#39;radial&#39; image. (Try &#39;<code>imag(rvals(200,200))</code>&#39; and you will see better what we mean!) <code>sin()</code> is the mathematical sine function, this already exists in perl but in the case of PDL is applied to all 40000 pixels at once, a topic we will come back to. The <code>imag()</code> function displays the image. You will see the syntax of perl/PDL is algebraic - by which we mean it is very similar to C and FORTRAN in how expressions are constructed. (In fact much more like C than FORTRAN). It is interesting to reflect on how much C code would be required to generate the same display, even given the existence of some convenient graphics library.</p>

<p> <img width="400" alt="" src="content/book/firststeps/sepia/crop/whirl-sync.png"/></p>

<p>Figure of a two dimensional <code>sin</code> function.</p>

<p>That&#39;s all fine. But what if we wanted to achieve the same results in a standalone perl script? Well it is pretty simple:</p>

<pre><code>  use PDL;
  use PDL::Graphics::Simple;
  imag (sin(rvals(200,200)+1));</code></pre>

<p>That&#39;s it. This is a complete perl/PDL program. One could run it by typing <code>perl filename</code>. (In fact there are many ways of running it, most systems allows it to be setup so you can just type <i>filename</i>. See your local Perl documentation - then the <code>perlrun</code> manual page.)</p>

<p>Two comments:</p>

<ol>

<li><p>The statements are all terminated by the &#39;<code>;</code>&#39; character. Perl is like C in this regard. When entering code at the <code>pdl</code> command line the final &#39;<code>;</code>&#39; may be omitted if you wish, note you can also use it to put multiple statements on one line. In our examples from now on we&#39;ll often omit the <code>pdl</code> prompt for clarity.</p>

</li>
<li><p>The directive <code>use PDL;</code> tells Perl to load the PDL module, which makes available all the standard PDL extensions. (Advanced users will be interested in knowing there are other ways of starting PDL which allows one to select which bits of it you want).</p>

</li>
</ol>

<h2 id="Whirling-through-the-Whirlpool">Whirling through the Whirlpool</h2>

<p>Enough about the mechanics of using PDL, let&#39;s look at some real data! To work through these examples exactly you can download any needed input files from <a href="http://sourceforge.net/projects/pdl/files/PDL/PDL%20Book%20Example%20Data%20Set/">http://sourceforge.net/projects/pdl/files/PDL/PDL%20Book%20Example%20Data%20Set/</a> and we&#39;ll assume you are running any of these examples in the same directory as you have downloaded the input data files.</p>

<p>We&#39;ll be playing with an image of the famous spiral galaxy discovered by Charles Messier, known to astronomers as M51 and commonly as the Whirlpool Galaxy. This is a &#39;nearby&#39; galaxy, a mere 25 million light years from Earth. The image file is stored in the &#39;FITS&#39; format, a common astronomical format, which is one of the many formats standard PDL can read. (FITS stores more shades of gray than GIF or JPEG, but PDL can read these formats too).</p>

<pre><code>  pdl&gt; $a = rfits(&quot;m51_raw.fits&quot;);   # m51_raw.fits is in current directory
  Reading IMAGE data...
  BITPIX =  -32  size = 262144 pixels 
  Reading  1048576  bytes
  BSCALE =  &amp;&amp;  BZERO = </code></pre>

<p>This looks pretty simple. As you can probably guess by now <code>rfits</code> is the PDL function to read a FITS file. This is stored in the perl variable <code>$a</code>.</p>

<p><b>This is an important PDL concept: PDL stores its data arrays in simple perl variables</b> (<code>$a, $x, $y, $MyData</code>, etc.). PDL data arrays are special arrays which use a more efficient, compact storage than standard perl arrays (<code>@a, @x, ...</code>) and are much faster to access for numerical computations. To avoid confusion it is convenient to introduce a special name for them, we call them <i>ndarrays</i> (short for &#39;n-dimensional array&#39;) to distinguish them from ordinary Perl &#39;arrays&#39;. We&#39;ll say more about this later.</p>

<p>Before we start seriously playing around with M51 it is worth noting that we can also say:</p>

<pre><code>  pdl&gt; $a = rfits &quot;m51_raw.fits&quot;;</code></pre>

<p>Note we have now left off the brackets on the <code>rfits</code> function. Perl is rather simpler than C and allows one to omit the brackets on a function all together. It assumes all the items in a list are function arguments and can be pretty convenient. If you are calling more than one function it is however better to use some brackets so the meaning is clear. For the rules on this &#39;list operator&#39; syntax see the Perl syntax documentation. From now on we&#39;ll mostly use the list operator syntax for conciseness</p>

<p>Let&#39;s look at M51:</p>

<pre><code>  pdl&gt; imag $a;</code></pre>

<p> <img width="600" alt="" src="content/book/firststeps/sepia/crop/whirl-m51-default.png"/></p>

<p>Figure of the raw image <code>m51_raw.fits</code> shown with progressively greater contrast using the <code>imag</code> command.</p>

<p>A couple of bright spots can be seen, but where is the galaxy? It&#39;s the faint blob in the middle: by default the display range is autoscaled linearly from the faintest to the brightest pixel, and only the bright star slightly to the bottom right of the center can be seen without contrast enhancement. We can easily change that by specifying the black/white data values (Note: <code>#</code> starts a Perl comment and can be ignored - i.e. no need to type the stuff after it!):</p>

<p> <img width="600" alt="" src="content/book/firststeps/sepia/crop/whirl-m51-1000.png"/></p>

<pre><code>  pdl&gt; imag $a,0,1000; # More contrast</code></pre>

<p> <img width="600" alt="" src="content/book/firststeps/sepia/crop/whirl-m51-300.png"/></p>

<pre><code>  pdl&gt; imag $a,0,300;  # Even more contrast</code></pre>

<p>You can see that <code>imag</code> takes additional arguments to specify the display range. In fact <code>imag</code> takes quite a few arguments, many of them optional. By typing &#39;<code>help imag</code>&#39; at the <code>pdl</code> prompt we can find out all about the function.</p>

<p>It is certainly a spiral galaxy with a few foreground stars thrown in for good measure. But what is that horrible stripey pattern running from bottom right to top left? That certainly is not part of the galaxy? Well no. What we have here is the uneven sensitivity of the detector used to record the image, a common artifact in digital imaging. We can correct for this using an image of a uniformly illuminated screen, what is commonly known as a &#39;flatfield&#39;.</p>

<pre><code>  pdl&gt; $flat = rfits &quot;m51_flatfield.fits&quot;;
  pdl&gt; imag $flat;</code></pre>

<p>This is shown in the next figure. Because the image is of a uniform field, the actual image reflects the detector sensitivity. To correct our M51 image, we merely have to divide the image by the flatfield:</p>

<p> <img width="400" alt="" src="content/book/firststeps/sepia/crop/whirl-flat.png"/></p>

<p>Figure: The &#39;flatfield&#39; image showing the detector sensitivity of the raw data.</p>

<pre><code>  pdl&gt; $gal = $a / $flat;
  pdl&gt; imag $gal,0,300;  
  pdl&gt; wfits $gal, &#39;fixed_gal.fits&#39;; # Save our work as a FITS file</code></pre>

<p>Well that&#39;s a lot better. But think what we have just done. Both <code>$a</code> and <code>$flat</code> are <i>images</i>, with 512 pixels by 512 pixels. <b>The divide operator &#39;<code>/</code>&#39; has been applied over all 262144 data values in the ndarrays <code>$a</code> and <code>$flat</code>.</b> And it was pretty fast too - these are what are known as <i>vectorized</i> operations. In PDL each of these is implemented by heavily optimized C code, which is what makes PDL very efficient for procession of large chunks of data. If you did the same operation using normal perl arrays rather than ndarrays it would be about ten to twenty times slower (and use ten times more memory). In fact we can do whatever arithmetic operations we like on image ndarrays:</p>

<p> <img width="400" alt="" src="content/book/firststeps/sepia/crop/whirl-flattened.png"/></p>

<p>Figure: The M51 image corrected for the flatfield.</p>

<pre><code>  pdl&gt; $funny = log(($gal/300)**2 - $gal/100  + 4); 
  pdl&gt; imag $funny; # Surprise!</code></pre>

<p>Or on 1-D line ndarrays. On on 3-D cubic ndarrays. In fact ndarrays can support an infinite number of dimensions (though your computer&#39;s memory won&#39;t).</p>

<p><b>This the key to PDL: the ability to process large chunks of data at once.</b></p>

<h2 id="Measuring-the-brightness-of-M51">Measuring the brightness of M51</h2>

<p>How might we extract some useful scientific information out of this image? A simple quantity an astronomer might want to know is how the brightness of the the &#39;disk&#39; of the galaxy (the outer region which contains the spiral arms) compares with the &#39;bulge&#39; (the compact inner nucleus). Well let&#39;s find out the total sum of all the light in the image:</p>

<pre><code>  pdl&gt; print sum($gal);
  17916010</code></pre>

<p><code>sum</code> just sums up all the data values in all the pixels in the image - in this case the answer is 17916010. If the image is linear (which it is) and if it was calibrated (i.e. we knew the relation between data numbers and brightness units) we could work out the total brightness. Let&#39;s turn it round - we know that M51 has a luminosity of about 1E36 Watts, so we can work out what one data value corresponds to in physical units:</p>

<pre><code>  pdl&gt; p 10**36/sum($gal)
  5.58159992096455e+28</code></pre>

<p>This is also about 200 solar luminosities, (Note we have switched to using <code>p</code> as a shorthand for <code>print</code> - which only works in the <code>pdl</code> shell) which gives 4 billion solar luminosities for the whole galaxy.</p>

<p>OK we do not need PDL for this simple arithmetic, let&#39;s get back to computations that involve the whole image. How can we get the sum of a piece of an image, e.g. near the centre? Well in PDL there is more than one way to do it (Perl aficionados call this phenomenon TIMTOWTDI). In this case, because we really want the brightness in a circular aperture, we&#39;ll use the <code>rvals</code> function:</p>

<pre><code>  pdl&gt; $r = rvals $gal;
  pdl&gt; imag $r;
  ...</code></pre>

<p>Remember <code>rvals</code>? It replaces all the pixels in an image with its distance from the centre. We can turn this into a <i>mask</i> with a simple operation like:</p>

<pre><code>  pdl&gt; $mask = $r&lt;50;
  pdl&gt; imag $mask;
  ...</code></pre>

<p> <img width="400" alt="" src="content/book/firststeps/sepia/crop/whirl-maska.png"/></p>

<p> <img width="400" alt="" src="content/book/firststeps/sepia/crop/whirl-maskb.png"/></p>

<p> <img width="400" alt="" src="content/book/firststeps/sepia/crop/whirl-maskc.png"/></p>

<p> <img width="400" alt="" src="content/book/firststeps/sepia/crop/whirl-maskd.png"/></p>

<p>Figure: Using <code>rvals</code> to generate a mask image to isolate the galaxy bulge and disk. Top row: radial gradient image <code>$r</code>, and radial gradient masked with less than operator <code>$r &lt; 50</code>. Bottom row: Bulge and disk of the galaxy.</p>

<p>The Perl <i>less than operator</i> is applied to all pixels in the image. You can see the result is an image which is 0 on the outskirts and 1 in the area of the nucleus. We can then simply use the mask image to isolate in a simple way the bulge and disk components (lower row) and it is then very easy to find the brightness of both pieces of the M51 galaxy:</p>

<pre><code> pdl&gt; $bulge = $mask * $gal
 pdl&gt; imag $bulge,0,300
 ...
 pdl&gt; print sum $bulge;
 3011125
 
 pdl&gt; $disk = $gal * (1-$mask)
 pdl&gt; imag $disk,0,300
 ...
 pdl&gt; print sum $disk
 14904884</code></pre>

<p>You can see that the disk is about 5 times brighter than the bulge in total, despite its more diffuse appearance. This is typical for spiral galaxies. We might ask a different question: how does the average <i>surface brightness</i>, the brightness per unit area on the sky, compare between bulge and disk? This is again quite straight forward:</p>

<pre><code>  pdl&gt; print sum($bulge)/sum($mask);
  pdl&gt; print sum($disk)/sum(1-$mask);</code></pre>

<p>We work out the area by simply summing up the 0,1 pixels in the mask image. The answer is the bulge has about 7 times the surface brightness than the disk - something we might have guessed from looking at the above figure, which tells astronomers its stellar density is much higher.</p>

<p>Of course PDL being so powerful, we could have figured this out in one line:</p>

<pre><code>  pdl&gt; print ( avg($gal-&gt;where(rvals($gal)&lt;50)) / avg($gal-&gt;where(rvals($gal)&gt;=50)) )
  6.56590509414673</code></pre>

<h2 id="Twinkle-twinkle-little-star">Twinkle, twinkle, little star</h2>

<p>Let&#39;s look at something else, we&#39;ll zoom in on a small piece of the image:</p>

<pre><code>  pdl&gt; $section = $gal(337:357,178:198);
  pdl&gt; imag $section; # the bright star</code></pre>

<p>Here we are introducing something new - we can see that PDL supports <i>extensions</i> to the Perl syntax. We can say <code>$var(a:b,c:d...)</code> to specify <i>multidimensional slices</i>. In this case we have produced a sub-image ranging from pixel 337 to 357 along the first dimension, and 178 through 198 along the second. Remember pdl data dimension indexes start from zero. We&#39;ll talk some more about <i>slicing and dicing</i> later on. This sub-image happens to contain a bright star.</p>

<p>At this point you will probably be able to work out for yourself the amount of light coming from this star, compared to the whole galaxy. (Answer: about 2%) But let&#39;s look at something more involved: the radial profile of the star. Since stars are a long way away they are almost point sources, but our camera will blur them out into little disks, and for our analysis we might want an exact figure for this blurring.</p>

<p>We want to plot all the brightness of all the pixels in this section, against the distance from the centre. (We&#39;ve chosen the section to be conveniently centered on the star, you could think if you want about how you might determine the centroid automatically using the <code>xvals</code> and <code>yvals</code> functions). Well it is simple enough to get the distance from the centre:</p>

<pre><code>  pdl&gt; $r = rvals $section;</code></pre>

<p>But to produce a one-dimensional plot of one against the other we need to reduce the 2D data arrays to one dimension. (i.e our 21 by 21 image section becomes a 441 element vector). This can be done using the PDL <code>clump</code> function, which &#39;clumps&#39; together an arbitrary number of dimensions:</p>

<pre><code>  pdl&gt; $rr  = $r-&gt;clump(2); # Clump first two dimensions
  pdl&gt; $sec = $section-&gt;clump(2);
  
  pdl&gt; points $rr, $sec;  # Radial plot</code></pre>

<p>You should see a nice graph with points like those in the figure below showing the drop-off from the bright centre of the star. The blurring is usually measured by the &#39;Full Width Half Maximum&#39; (FWHM) - or in plain terms how fat the profile is across when it drops by half. Looking at the plot it looks like this is about 2-3 pixels - pretty compact!</p>

<p> <img width="400" alt="" src="content/book/firststeps/sepia/crop/whirl-star-radial.png"/></p>

<p>Figure: Radial light profile of the bright star with fitted curve.</p>

<p>Well we don&#39;t just want a guess - let&#39;s fit the profile with a function. These blurring functions are usually represented by the <code>Gaussian</code> function. PDL comes with a whole variety of general purpose and special purpose fitting functions which people have written for their own purposes (and so will you we hope!). Fitting Gaussians is something that happens rather a lot and there is surprisingly enough a special function for this very purpose. (One could use more general fitting packages like <code>PDL::Fit::LM</code> or <code>PDL::Opt::Simplex</code> but that would require more care).</p>

<pre><code>  pdl&gt; use PDL::Fit::Gaussian;</code></pre>

<p>This loads in the module to do this. PDL, like Perl, is modular. We don&#39;t load all the available modules by default just a convenient subset. How can we find useful PDL functions and modules? Well <code>help</code> tells us more about what we already know, to find out about what we don&#39;t know use <code>apropos</code>:</p>

<pre><code>  pdl&gt; apropos gaussian
  PDL::Fit::Gaussian ...
                                Module: routines for fitting gaussians
  PDL::Gaussian   Module: Gaussian distributions.
  fitgauss1d      Fit 1D Gassian to data ndarray
  fitgauss1dr     Fit 1D Gassian to radial data ndarray
  gefa            Factor a matrix using Gaussian elimination.
  grandom         Constructor which returns ndarray of Gaussian random numbers
  ndtri           The value for which the area under the Gaussian probability density function (integrated from minus
                                infinity) is equal to the argument (cf erfi). Works inplace.</code></pre>

<p>This tells us a whole lot about various functions and modules to do with Gaussians. Note that we can abbreviate <code>help</code> and <code>apropos</code> with &#39;<code>?</code>&#39; and &#39;<code>??</code>&#39; when using the <code>pdl</code> shell.</p>

<p>Let&#39;s fit a Gaussian:</p>

<pre><code>  pdl&gt; use PDL::Fit::Gaussian;
  pdl&gt; ($peak, $fwhm, $background) = fitgauss1dr($rr, $sec); 
  pdl&gt; p $peak, $fwhm, $background;</code></pre>

<p><code>fitgauss1dr</code> is a function in the module <a>PDL::Fit::Gaussian</a> which fits a Gaussian constrained to be radial (i.e. whose peak is at the origin). You can see that, unlike C and FORTRAN, Perl functions can return more than one result value. This is pretty convenient. You can see the FWHM is more like 2.75 pixels. Let&#39;s generate a fitted curve with this functional form.</p>

<pre><code>  pdl&gt; $rrr = sequence(2000)/100;  # Generate radial values 0,0.01,0,02..20
       
  # Generate Gaussian with given FWHM

  pdl&gt; $fit = $peak * exp(-2.772 * ($rrr/$fwhm)**2) + $background;</code></pre>

<p>Note the use of a new function, <code>sequence(N)</code>, which generates a new ndarray with N values ranging 0..(N-1). We are simply using this to generate the horizontal axis values for the plot. Now let&#39;s overlay it on the previous plot.</p>

<pre><code>  pdl&gt; hold; # This command stops new plots starting new pages
  pdl&gt; line $rrr, $fit, {Colour=&gt;2} ; # Line plot</code></pre>

<p>The last <code>line</code> command shows the PDL syntax for optional function arguments. This is based on the Perl&#39;s built in hash syntax. We&#39;ll say more about this later in <a>PDL::Book::PGPLOT</a>. The result should look a lot like the figure above. Not too bad. We could perhaps do a bit better by exactly centroiding the image but it will do for now.</p>

<p>Let&#39;s make a <i>simulation</i> of the 2D stellar image. This is equally easy:</p>

<pre><code>  pdl&gt; $fit2d = $peak * exp(-2.772 * ($r/$fwhm)**2);
  pdl&gt; release; # Back to new page for new plots;
  pdl&gt; imag $fit2d;
  ...
  pdl&gt; wfits $fit2d, &#39;fake_star.fits&#39;; # Save our work</code></pre>

<p>But the figure below is a boring. So far we have been using simple 2D graphics from the <code>PDL::Graphics::Simple</code> library. In fact PDL has more than one graphics library (some see this as a flaw, some as a feature!). Using the <code>PDL::Graphics::TriD</code> library which does OpenGL graphics we can look at our simulated star in 3D (see the right hand panel);</p>

<p> <img width="300" alt="" src="content/book/firststeps/sepia/crop/whirl-starsima.png"/></p>

<p> <img width="300" alt="" src="content/book/firststeps/grey/work/whirl-starsimb.png"/></p>

<p>Figure: Two different views of the 2D simulated Point Spread Function.</p>

<pre><code>   pdl&gt; use PDL::Graphics::TriD; # Load the 3D graphics module
   pdl&gt; imag3d [$fit2d];</code></pre>

<p>If you do this on your computer you should be able to look at the graphic from different sides by simply dragging in the plot window with the mouse! You can also zoom in and out with the right mouse button. Note that <code>imag3d</code> has it&#39;s a rather different syntax for processing it&#39;s arguments - for very good reasons - we&#39;ll explore 3D graphics further in <a>PDL::Book::TriD</a>.</p>

<pre><code>   To continue: Select the TriD window and type q</code></pre>

<p>Finally here&#39;s something interesting. Let&#39;s take our fake star and place it elsewhere on the galaxy image.</p>

<pre><code>  pdl&gt; $newsection = $gal(50:70,70:90);
  pdl&gt; $newsection +=  $fit2d;
  pdl&gt; imag $gal,0,300;</code></pre>

<p>We have a bright new star where none existed before! The C-style <code>+=</code> increment operator is worth noting - it actually modifies the contents of <code>$newsection</code> in-place. And because <code>$newsection</code> is a <i>slice</i> of <code>$gal</code> the change also affects <code>$gal</code>. This is an important property of slices - any change to the slice affects the <i>parent</i>. This kind of parent/child relationship is a powerful property of many PDL functions, not just slicing. What&#39;s more in many cases it leads to memory efficiency, when this kind of linear slice is stored we only store the start/stop/step and not a new copy of the actual data.</p>

<p>Of course sometimes we DO want a new copy of the actual data, for example if we plan to do something evil to it. To do this we could use the alternative form:</p>

<pre><code>  pdl&gt; $newsection = $newsection +  $fit2d</code></pre>

<p>Now a new version of <code>$newsection</code> is created which has nothing to do with the original <code>$gal</code>. In fact there is more than one way to do this as we will see in later chapters.</p>

<p>Just to amuse ourselves, lets write a short script to cover M51 with dozens of fake stars of random brightnesses:</p>

<pre><code>   use PDL;
   use PDL::Graphics::Simple;
   use PDL::NiceSlice;  # must use in each program file

   srand(42); # Set the random number seed
   $gal  = rfits &quot;fixed_gal.fits&quot;;
   $star = rfits &quot;fake_star.fits&quot;;
   
   sub addstar {
      ($x,$y) = @_;
      $xx = $x+20; $yy = $y+20;
      # Note use of slice on the LHS!
      $gal($x:$xx,$y:$yy) += $star * rand(2);
   }

   for (1..100) {
      $x1 = int(rand(470)+10);
      $y1 = int(rand(470)+10);
      addstar($x1,$y1);
   }
   imag $gal,0,1000;</code></pre>

<p>This ought to give the casual reader some flavour of the Perl syntax - quite simple and quite like C except that the entities being manipulated here are entire arrays of data, not single numbers. The result is shown, for amusement, in the figure below and takes virtually no time to compute.</p>

<p> <img width="400" alt="" src="content/book/firststeps/sepia/crop/whirl-fakestars.png"/></p>

<p>Figure: M51 covered in fake stars.</p>

<h2 id="Getting-Complex-with-M51">Getting Complex with M51</h2>

<p>To conclude this frantic whirl through the possibilities of PDL, let&#39;s look at a moderately complex (sic) example. We&#39;ll take M51 and try to enhance it to reveal the large-scale structure, and then subtract this to reveal small-scale structure.</p>

<p>Just to show off we&#39;ll use a method based on the Fourier transform - don&#39;t worry if you don&#39;t know much about these, all you need to know is that the Fourier transform turns the image into an &#39;inverse&#39; image, with complex numbers, where each pixel represents the strength of wavelengths of different scales in the image. Let&#39;s do it:</p>

<pre><code>  pdl&gt; use PDL::FFT; # Load Fast Fourier Transform package
  pdl&gt; $gal = rfits &quot;fixed_gal.fits&quot;;</code></pre>

<p>Now <code>$gal</code> contains real values, to do the Fourier transform it has to have complex values. We create a variable <code>$imag</code> to hold the imaginary component and set to zero.(For reasons of efficiency complex numbers are represented in PDL by separate real and imaginary arrays; see PDL::Complex.)</p>

<pre><code>  pdl&gt; $imag = $gal * 0;       # Create imaginary component, equal to zero
  pdl&gt; fftnd $gal, $imag;      # Perform Fourier transform</code></pre>

<p><code>fftnd</code> performs a Fast Fourier Transform, in-place, on arbitrary-dimensioned data (i.e. it is &#39;N-dimensional&#39;). You can display <code>$gal</code> after the FFT but you won&#39;t see much. If at this point we ran <code>ifftnd</code> to invert it we would get the original <code>$gal</code> back.</p>

<p>If we want to enhance the large-scale structure we want to make a filter to only let through low-frequencies:</p>

<pre><code>  pdl&gt; $tmp = rvals($gal)&lt;10;        # Radially-symmetric filter function
  pdl&gt; use PDL::ImageND;             # provides kernctr()
  pdl&gt; $filter = kernctr $tmp, $tmp; # Shift origin to 0,0
  pdl&gt; imag $filter;</code></pre>

<p> <img width="400" alt="" src="content/book/firststeps/sepia/crop/gal-filter.png"/></p>

<p>You can see from the image that <code>$filter</code> is zero everywhere except near the origin (0,0) (and the 3 reflected corners). As a result it only lets through low-frequency wavelengths. So we multiply by the filter and FFT back to see the result (<code>cmul</code> is complex multiplication):</p>

<pre><code>  pdl&gt; ($gal2, $imag2) = cmul $gal, $imag, $filter, 0;
  pdl&gt; ifftnd $gal2, $imag2;
  pdl&gt; imag $gal2,0,300;</code></pre>

<p> <img width="400" alt="" src="content/book/firststeps/sepia/crop/whirl-ffta.png"/></p>

<p> <img width="400" alt="" src="content/book/firststeps/sepia/crop/whirl-fftb.png"/></p>

<p>Figure: Fourier filtered smoothed image and contrast enhanced image with the smoothed image subtracted.</p>

<p>Well that looks quite a bit different! Just about all the high-frequency information has vanished. To see the high-frequency information we can just subtract our filtered image from the original to form the right hand image.</p>

<pre><code>  pdl&gt; $orig = rfits &quot;fixed_gal.fits&quot;;
  pdl&gt; imag $orig-$gal2,0,100;</code></pre>

<h2 id="Roundoff">Roundoff</h2>

<p>Well that is probably enough abuse of Messier 51. We have demonstrated the ease of simple and complex data processing with PDL and how PDL fits neatly in to the Perl syntax as well as extending it. You have come across basic arithmetical operations and a scattering of useful functions - and learned how to find more. You certainly ought now to have a good feel of what PDL is all about. In the next chapter we&#39;ll take a more comprehensive look at the basic parts of PDL that all keen PDL users should know.</p>

<h1 id="What-is-an-NDArray">What is an NDArray?</h1>

<p>PDL uses Perl &quot;objects&quot; to hold PDL data, called an ndarray. An &quot;object&quot; is like a user-defined data-type and is a very powerful feature of Perl, PDL creates its own class of &quot;PDL&quot; objects to store ndarrays. These look like ordinary Perl variables such as $x, $Foo, $MyData, etc.</p>

<p>Most of the time you can forget about the fact that ndarrays are objects and treat them like ordinary variables:</p>

<pre><code>  $x = rfits &#39;file.fits&#39;;
  $y = rvals($x);
  $z = $x/$y;
  print sqrt($x+$y+$z);</code></pre>

<p>The only time the distinction becomes important is when creating ndarrays and using the &quot;=&quot; operator.</p>

<h2 id="NDArrays-are-NOT-Perl-arrays">NDArrays are NOT Perl &quot;arrays&quot;</h2>

<p>It is now time to answer a question which has probably been nagging at the back of your mind for a while.</p>

<p>Why bother with ndarrays? Why not just use normal Perl &quot;arrays&quot;?</p>

<p>By Perl &quot;arrays&quot; we of course mean entities like @x and @Data z which one would normally create and manipulate like this:</p>

<pre><code>   @x = (1,2,3);
   push @x, 42;
   $y = pop @x;</code></pre>

<p>So why don&#39;t we just use Perl &quot;arrays&quot;? Several very good reasons:</p>

<p>It is impossible to manipulate Perl &quot;arrays&quot; arithmetically as one would like. i.e.:</p>

<pre><code>  @y = @x * 2;  # Wrong!</code></pre>

<p>can not be made to operate element by element.</p>

<p>Perl &quot;arrays&quot; store Perl scalars (<code>SV</code>s), each of which is a separate piece of data.</p>

<p>Perl arrays are intrinsically one-dimensional. You can have &quot;arrays of arrays&quot; but this is not the same thing as true multi-dimensional arrays. Honest.</p>

<p>Perl arrays consume a lot of memory. At least 20 bytes per number, of which only a few are for the actual value. This is because Perl arrays are flexible, and can contain text strings as well as numbers. This flexibility requires an internal complex data structure which contains extra information such as a place holder for the number, a place holder for the text and the overhead of the array data structure itself.</p>

<p>Perl arrays are scattered about memory. The array data structure means consecutive numbers are not stored in a neat block of consecutive memory addresses as C and FORTRAN programmers are used to. This makes it difficult to pass the arrays to low-level C and FORTRAN routines for processing -- the numbers must be collected together -a process known as &quot;packing&quot; -- processed and unpacked back into arrays. If you have &quot;arrays of arrays&quot; then it gets even worse.</p>

<p>Perl arrays do not support the range of data types that ndarrays do (byte arrays, integer arrays, single precision, double precision, etc.)</p>

<p>That is why PDL does not use Perl arrays. Just to be clear from now on we&#39;ll always refer to PDL numeric data arrays as &quot;ndarrays&quot; and Perl-style number/text arrays as &quot;arrays&quot;.</p>

<h1 id="Constructing-PDLs">Constructing PDLs</h1>

<p>PDL variables are a new class of object within Perl. There are three main ways to construct them: via the pdl constructor; via one of the special index PDL constructors; or by reading in some external data. In addition, there are hooks for stuffing your own raw data into a PDL variable. The more basic constructors are here.</p>

<h2 id="The-basic-constructor-pdl">The basic constructor, <code>pdl()</code></h2>

<p>The most basic way to make a PDL is with the function <code>pdl()</code>. You can feed pdl just about anything that makes sense: a perl scalar, a perl list, a nested perl list, another PDL, or even a perl list of PDLs. It will return an appropriately-dimensioned PDL containing those values. Here are some examples:</p>

<pre><code>  $a = pdl( 5 );                 # double-precision scalar
  $a = pdl( short,5 );           # short-integer scalar
  $a = pdl( 1,2,3 );             # 3-PDL (one dim)
  $a = pdl( [1,2,3] );           # 3-PDL, another way (just one dim)
  $a = pdl( [[1,2,3]] );         # 3x1-PDL (two dims)
  $a = pdl( [[1,2,3],[4,5,6]] ); # 3x2-PDL (two dims)
  $a = pdl &quot;[[1,2,3],[4,5,6]]&quot;;  # Even strings from print output!</code></pre>

<p>In the last couple of examples, notice that the innermost nested lists form the 0th dimension of the PDL.</p>

<p>If you aren&#39;t sure whether a particular variable contains a PDL or not (and sometimes you care: there&#39;s a slight difference between a scalar PDL and a perl scalar!) you can always safely wrap a <code>pdl</code> call around it to be sure.</p>

<h2 id="Array-allocation:-zeroes-and-ones">Array allocation: <code>zeroes()</code> and <code>ones()</code></h2>

<p>The two operations zeroes and ones generate PDLs full of the value 0 and of the value 1, respectively. (well, what did you expect?) They&#39;re useful for allocating data in a hurry. If you feed in a list of perl scalars, they are used as a list of dimensions for the new PDL that gets returned. If you feed in a PDL, either one will simply match the size of the PDL. Examples:</p>

<pre><code>  $a = zeroes(3,3);           # $a becomes a 3x3 array filled with 0
  $a = zeroes(byte,3,3);      # ditto, only bytes instead of doubles
  $b = ones($a);              # $b becomes a 3x3 array filled with 1
  $p = pdl(1,2,3);            # A PDL containing [1 2 3]
  $c = zeroes($p);            # A 3-PDL containing [0 0 0]
  $d = zeroes($p-&gt;list);      # A 1x2x3-PDL ($p-&gt;list is a Perl list)</code></pre>

<h2 id="Index-PDLs:-xvals-yvals-rvals-sequence-ndcoords">Index PDLs: xvals, yvals, rvals, sequence, ndcoords</h2>

<p>It is surprisingly useful to be able to generate &quot;index PDLs&quot;: arrays whose elements merely enumerate their coordinates. PDL supplies a passel of index PDL constructors.</p>

<p>The basics are <code>xvals</code>, <code>yvals</code> and <code>zvals</code>, which work like <code>zeroes</code> and <code>ones</code>, but construct an index PDL that works along the 0, 1, or 2 axis, respectively. For example:</p>

<pre><code>  pdl&gt; print xvals(3,3)
  [  
    [0 1 2]  
    [0 1 2]  
    [0 1 2] 
  ]
  pdl&gt; print yvals(3,3)
  [
    [0 0 0]
    [1 1 1]
    [2 2 2]
  ]</code></pre>

<p>If you want more generality or higher dimensionality, <code>axisvals</code> works the same way but lets you specify the index dimension by number.</p>

<p>Sometimes you want a PDL that contains radii from a given point. You could always apply the Pythagorean theorem explicitly:</p>

<pre><code>  $x=xvals(10,10)-5;
  $y=yvals(10,10)-5;
  $a=sqrt( $x*$x + $y*$y );</code></pre>

<p>but it&#39;s much easier to use <code>rvals</code>, which does that stuff for you:</p>

<pre><code>  pdl&gt; $a = rvals(3,3); print $a;
  [
    [ 1.4142136        1  1.4142136]
    [         1        0          1]
    [ 1.4142136        1  1.4142136]
  ]</code></pre>

<p>As with the others, <code>rvals</code> works in any number of dimensions, and can either take a dimension list or another PDL to match. There are a number of adjustments that you can make to <code>rvals</code>; see the online documentation for details.</p>

<p>Finally, sometimes you want to create a full vector index PDL; for example, to enumerate all the coordinates in a 100x100 image you would want a 2x100x100-PDL. You can assemble one from <code>xvals</code>, <code>yvals</code>, or just use <code>ndcoords</code>. Here&#39;s how to do it either way:</p>

<pre><code>  $a = pdl( xvals(100,100), yvals(100,100) )-&gt;mv(0,1); # slow way
  $a = ndcoords(100,100);                              # fast way</code></pre>

<p><code>ndcoords</code> works like all the other index constructors, except that it adds an additional dim to the beginning of its return value, to handle the fact that each index is a vector that points into an N-dimensional array. <code>ndcoords</code> and <code>range</code> together can be used to chop up an image into manageable tiles; see Section [sub:Range] , below.</p>

<h2 id="Specialty-constructors">Specialty constructors</h2>

<p>PDL contains two important internal constructors, <code>PDL::new_from_specification</code> and <code>null</code>, that are useful for importing data en masse or for other special applications. If you&#39;re just starting out, you probably don&#39;t really need to know this stuff just yet - you&#39;ll probably find the various data import techniques in [sec:Getting-values-into] more useful. So skip ahead if you like.</p>

<p><code>null</code> takes no arguments and returns a null PDL. A null PDL has no values, but (unlike the empty PDL) can be assigned to. Null PDLs are placeholders that automatically resize themselves to fit any dimensional context. They&#39;re mainly intended for internal use, but you might find them helpful in odd contexts (for example, you can pass a null PDL into a function as a write-back return value).</p>

<p><code>PDL::new_from_specification</code> is the engine that <code>zeroes</code>, <code>rvals</code>, and such use for initial construction. It takes the same sort of arguments as <code>zeroes</code> (an optional type and a PDL template or a size list), but doesn&#39;t bother with any initialization of the newly allocated RAM. This is especially useful if you&#39;re just going to stuff your own values into the new PDL anyway.</p>

<h2 id="Getting-values-into-and-out-of-PDLs">Getting values into and out of PDLs</h2>

<p>Unless you can get data in and out of your PDLs they won&#39;t do you much good. Most large blocks of data are handled by direct file I/O (Chapter [cha:File-I/O]), but you will also want to get normal Perl values into and out of your PDLs. Here are the basic ways to get data into your PDLs (from perl, other PDLs, or random chunks of memory), and back out again (into perl, into random chunks of memory, or into ASCII). For displaying your data you will want to look at Chapter [cha:Graphics].</p>

<h3 id="Construction:-slurping-Perl-arrays">Construction: slurping Perl arrays</h3>

<p>The simplest way to turn a bunch of Perl data into a PDL is by calling <code>pdl()</code>, the PDL constructor. The constructor pokes and prods the array structure of its argument(s), and creates a PDL that contains all the values in whatever nested array you&#39;ve come up with. For example,</p>

<pre><code>  $pdl_all = pdl(@pdl_source);
  $pdl_3x3 = pdl([00,01,02],[10,11,12],[20,21,22]);</code></pre>

<p>That is certainly the most convenient (and probably the fastest) way to stuff a bunch of values from Perl variables into a PDL.</p>

<h3 id="Assignment-with">Assignment with <code>.=</code></h3>

<p>PDL distinguishes between two kinds of assignment: <i>global assignment</i> (the usual <code>=</code> operator) and <i>broadcasted (computed) assignment</i> (the <code>.=</code> operator).</p>

<p>PDLs are best thought of as something like perl refs or C pointers: the variable points to the location in memory where the data reside. That makes array indexing and slicing straightforward, since you can hold a slice of a larger array in a related variable, without expensive memory copies. The global <code>=</code> operator is used to set the value of the pointer. The broadcasted <code>.=</code> operator is used to set the value of the data that are contained in the PDL. The two operators work quite differently. For example:</p>

<pre><code>  $a = xvals(3);      # 1D-PDL: values are (0,1,2)
  $b = zeroes(3,4);   # 3x4 array of zeroes
  $c = zeroes(3,4);   # 3x4 array of zeroes
  $b = $a;            # $b becomes a clone of $a
  $c .= $a;           # $c becomes 4 copies of $a</code></pre>

<p>puts two quite different values into <code>$b</code> and <code>$c</code>. At the end of the code, <code>$b</code> and <code>$a</code> are linked (they point to the same area of memory), so assigning to the elements of <code>$b</code> changes <code>$a</code> too. But <code>$c</code> remains a separate variable, whose elements happen to have received values from the corresponding elements of <code>$a</code>.</p>

<p>But that&#39;s not all! <code>$b</code> and <code>$c</code> end up with completely different shapes. Because <code>$c</code> started out as a 3x4-PDL, the broadcasting engine duplicates <code>$a</code> (which is a 3-PDL) for each row of <code>$c</code>. The <code>.=</code> operator is called broadcasted assignment, because it causes its right-hand argument to be expanded and vectorized exactly as any other operand would. Broadcasting is explained in detail in Section [sec:Dimensionality-and-Broadcasting] .</p>

<h3 id="Importing-data-directly-from-memory:-get_dataref">Importing data directly from memory: <code>get_dataref</code></h3>

<p>PDL lets you access the memory of a PDL variable directly, using a perl string variable. You normally won&#39;t have to use this mechanism, but I include it here for completeness - if you are just learning PDL, you can probably skip this subsection.</p>

<p>The string variable mechanism gives you access to the low-level representation of the data (which is the same as your C compiler would use). The string access routines are <code>get_dataref</code> and <code>upd_data</code>. <code>get_dataref</code> takes a PDL argument and returns a perl scalar ref that points to the PDL&#39;s data as a perl string. If you change the string, Perl might move it in memory, so you must then update the pointers in the PDL variable to match. That is what <code>upd_data</code> is for.</p>

<p>Here&#39;s a brief example of how to import a large hunk of memory into a PDL. In this case, the hunk is three 1000x1000 image planes that you have somehow imported into a perl string, e.g. by reading from a file or executing a PerlXS script. The three image planes are to represent R, G, and B in a PDL with dimensions (3x1000x1000).</p>

<pre><code>  $pdl = PDL-&gt;new_from_specification(byte,1000,1000,3);
  $dref = $pdl-&gt;get_dataref;  # $$dref is the PDL data as a string.
  $$dref = $data;   # Overwrite the string.
  $pdl-&gt;upd_data(); # Make sure the PDL knows it changed.
  $rgb = $pdl-&gt;mv(2,0); # 3x1000x1000.</code></pre>

<p>Here, <code>$$dref</code> is a Perl string that occupies the same location in RAM as the data in <code>$pdl</code>. Unless you&#39;re using 2-byte Unicode strings, the string has as many characters as there are bytes in the machine representation of the PDL. This example has a 3MB string - but a double-precision PDL with the same dimensions would have a 24MB string. Remember, <code>new_from_specification</code> allocates the PDL but doesn&#39;t initialize its contents - so initially the string is full of whatever garbage happened to be in that chunk of memory. Overwriting the string with a simple copy (or perl sysread operation) rapidly loads the binary data directly into <code>$pdl</code>, with no type conversion at all. (Warning - you can hose yourself if you shorten the string, which will de-allocate the end of the PDL!) Afterward, you have to update the internal data pointers in <code>$pdl</code>, in case Perl moved the string around. The final mv call makes sure that the dimensionality is right, without shuffling the actual bytes around.</p>

<p>If you use this low-level mechanism, you are responsible for making sure that the data you put into the new PDL has the same form as the PDL&#39;s formal data type! You are also responsible for figuring out byte swapping for your machine - the bytes in the string are in machine order, not network order.</p>

<h3 id="Conversion-to-Perl-types:-at-list-and-unpdl">Conversion to Perl types: <code>at</code>, <code>list</code>, and <code>unpdl</code></h3>

<p>You can get a PDL scalar out into the Perl world with <code>at</code>, which requires the index of the scalar to pull out:</p>

<pre><code>  pdl&gt; $a = xvals(5)*2;  # $a is a PDL
  pdl&gt; $a4 = $a-&gt;at(4);  # $a4 is a perl scalar</code></pre>

<p>You can also export a whole PDL with <code>list</code>:</p>

<pre><code>  pdl&gt; @a = $a-&gt;list;
  pdl&gt; for($a-&gt;list) { print $_, - ; }
  0 - 2 - 4 - 6 - 8 - </code></pre>

<p>The <code>unpdl</code> command returns a whole PDL as a reference to a list-of-lists structure equivalent to the input PDL in the sense that <code>sum($x - pdl( $x-&gt;unpdl ))</code> equals 0. E.g.,</p>

<pre><code>  pdl&gt; p $a = pdl([ [0,1,2], [3,4,5] ]);
  [
   [0 1 2]
   [3 4 5]
  ]
  pdl&gt; $aperl = $a-&gt;unpdl # $aperl is [ [0,1,2], [3,4,5] ] </code></pre>

<p>Be careful with <code>at</code>, as you almost never want to use it - it is tedious for anything nontrivial, and extremely slow! Particularly if you find yourself placing an <code>at</code> call inside a <code>for</code> loop, you should probably stop and think about how to use broadcasting for your problem - see below.</p>

<h2 id="Data-Types-and-Contexts">Data Types and Contexts</h2>

<p>Because PDL is a hybrid language, it&#39;s important to understand Perl&#39;s data structures as well as PDL&#39;s. Normal Perl variables are represented in a way that makes sense for Perl&#39;s original application - small to medium sized &quot;glue&quot; tasks - while PDL variables and arrays (&quot;PDLs&quot;) have a more traditional typing scheme.</p>

<p>Unlike most other languages, ordinary Perl uses &quot;polymorphous&quot; (or &quot;behind-your-back&quot;) typing. While the traditional simple types (boolean, string, short, long, float, double) are all represented, the language doesn&#39;t distinguish between the different types. The Perl engine keeps track of each variable&#39;s representation, and delivers to you the most appropriate representation depending on context. For example, + is an arithmetic operator, so the expression <code>&quot;5&quot; + 2</code> yields the number <code>7</code> even though one of its terms began life as a string.</p>

<p>PDL variables are implemented on top of Perl&#39;s normal variable system. A PDL is effectively a new type of perl scalar, that can contain a whole array of numeric values. PDLs are strongly typed, but are still slightly influenced by Perl&#39;s notion of context. In particular, PDLs behave slightly differently in numeric, boolean, and string context. In Perl numeric contexts, PDLs act normally. In boolean/logical contexts, they act like boolean values in the C language - the only false value is <code>0</code>, and any nonzero value is treated as true (note: Not all languages treat nonzero values as logical-true, which may come as a surprise to C or Perl programmers. For example, some FORTRANs and RSI&#39;s IDL language use the least-significant bit of integer variables as the boolean truth value of the integer).</p>

<p>In Perl string contexts, PDLs act like descriptive multiline strings (or the string <code>&quot;TOO LONG TO PRINT&quot;</code>). See the following subsections for details.</p>

<h3 id="Refresher-on-Perl-Data-Types-Contexts">Refresher on Perl Data Types &amp; Contexts</h3>

<p>While the underlying representations of objects change, Perl itself recognizes only a few distinct variable types. These are &quot; scalar&quot;, &quot;ref&quot;, &quot;array&quot; (also called &quot;list&quot;), and &quot;hash&quot;. (PDLs are implemented as special refs that are opaque to perl itself; perl treats them as scalars). The ones relevant to PDLs are scalars, lists, and hashes.</p>

<ul>

<li><p><b>Scalar variables</b> or expressions hold a single value - a string, a number, the undefined value, or a reference (&quot;ref&quot;) to one of the other basic types (see below). A scalar - even one that carries a numeric value - is slightly different than a PDL with one element.</p>

</li>
<li><p><b>List values</b> (often called &quot;arrays&quot; by the general Perl community) are collections of scalars that are indexed by number. Unlike normal arrays or PDLs, perl lists are expanded automatically as needed, so you can address any element whether it exists or no. List elements can contain any perl scalar value.</p>

</li>
<li><p><b>Hash values</b> are collections of scalars that are indexed by string. Hashes act like lookup tables or dynamic structures. Instead of being numbered, each element is addressed by name.</p>

</li>
<li><p><b>Refs</b> are special scalar values that hold pointers to other data types. They have a different name than pointers, to remind you that they are podiatrically friendly - it&#39;s much harder to shoot yourself in the foot with refs than it is with pointers. Perl variables maintain a reference count (like UNIX files) and are automatically deallocated when the last reference disappears - so you don&#39;t have to keep track of whether a ref is valid or no. Refs come in four basic flavors: scalar refs, list refs, hash refs, and code refs.</p>

<p>Refs can be used to &quot;roll up&quot; large data structures (like lists) into a single scalar value; this is how Perl implements multi-dimensional lists and complex data structures. In addition, refs may be &quot;blessed&quot; into a particular object class; this is the mechanism that Perl uses for object oriented programming. Blessing merely associates the target of the ref with a particular kind of object. PDLs are implemented as blessed Perl refs, so that a PDL (which may hold a million values) may appear wherever you can put a Perl scalar.</p>

</li>
</ul>

<h3 id="PDL-Data-Types">PDL Data Types</h3>

<p>PDLs are strongly typed: when you create a PDL, it gets a particular representation and stays that way. The basic types are familiar to C programmers: byte, short, unsigned short, long, long long, float, and double. You can compile 64-bit support into your copy of PDL, and have access to wide doubles and other such exotica. Complex numbers are supported as a subclass of PDL; see PDL::Complex in the main PDL documentation.</p>

<p>PDL types are automatically converted as necessary within arithmetic expressions, at some cost in speed. Numeric expressions run faster between PDLs of the same type than between PDLs of different types, but all numeric expressions work more or less the way a C programmer would expect, with data types being automagically promoted to the highest complexity type that is used in each expression.</p>

<h3 id="PDLs-and-Perl-Contexts">PDLs and Perl Contexts</h3>

<p>While the representation of each PDL is fixed, the interpretation is different in each of the three main Perl scalar contexts:</p>

<p><b>Numeric context</b> is what you get if you use PDLs in the usual way - adding, subtracting, and such. Normal numeric operations act elementwise, and each array preserves its storage class (char/byte, short-int, long-int, float, double, etc.). If you mix a PDL with a Perl variable in numeric context (for example, <code>pdl(2,3,4)+5</code>), then the Perl variable is &quot;promoted&quot; to a PDL.</p>

<p><b>Boolean context</b> is what you get if you use a PDL in a branch statement like <code>if</code> or <code>while</code> or even the <code>&amp;&amp;</code> and <code>||</code> operators. Multi-element PDLs are not allowed in this context, to avoid the confusion inherent in non-deterministic branching (<code>&amp;&amp;</code> and <code>||</code> are short-circuit operators that don&#39;t evaluate the second term if doing so would be redundant). Single-element PDLs are treated as TRUE if they are nonzero and FALSE if they are zero. (Note that the bitwise logical operators, such as <code>&amp;</code> apply numeric, rather than boolean, context - so you can do elementwise Boolean arithmetic with <code>&amp;</code>, <code>|</code>, and <code>^</code> - but not with <code>&amp;&amp;</code>, <code>||</code>, and <code>^^</code>.</p>

<p>String context is what you get if you use a PDL as a string. The PDL gets converted to a human-readable string suitable for printing. The new <code>pdl()</code> string input capability allows one to convert printed ndarrays back into the original object. The feature includes support for MATLAB-style <code>[ ; ]</code> syntax as well.</p>

<p>Because string conversion is intended for use with <code>print</code>, PDLs that are moderately large (more than about 1,000 elements) don&#39;t get converted - the string that you get back is <code>TOO LONG TO PRINT</code>. String context is easy to remember as &quot;just&quot; a way to give you direct access to the output of <code>print</code>: use a PDL as if it were a string, and you get the string that would be printed.</p>

<h3 id="BAD-Values">BAD Values</h3>

<p>PDL lets you propagate bad/missing values in your data. You can set a particular numeric value that will be treated as BAD and ignored by the underlying code.</p>

<p>You can mark values BAD with the <code>setbadif</code> and <code>setbadat</code> methods. Bad values are treated as truly missing by statistical routines and collapse operators (that summarize each row of a PDL) and as poisonous by arithmetic routines. For example, <code>average</code> and <code>sumover</code> ignore bad values completely, multiplication will mark appropriate output values as bad, and <code>convolve</code> and <code>convolveND</code> will cause bad patches to spread throughout a block of data.</p>

<h2 id="Dataflow">Dataflow</h2>

<p>&quot;Dataflow&quot; is the concept that multiple variables can remain connected to one another (so that data flows between them). PDL allows you to keep multiple variables that refer to the same underlying data. For example, if you extract a subfield of a large data array you can pass it to subroutines and other expressions just like any other PDL, but changes will still propagate back to the large array unless you indicate otherwise.</p>

<p>In general, PDL&#39;s element-selection operators (such as slicing and indexing) maintain dataflow connections unless they are explicitly severed. To support dataflow, PDL has two different kinds of assignment: the global assignment operator = and the computed assignment operator <code>.=</code>.</p>

<p>Global assignment is used to create new PDLs, and computed assignment is used to insert values into existing PDLs. Many other languages, such as FORTRAN and IDL, don&#39;t maintain dataflow for slices of arrays except in the special case where the slice operation is on the left-hand side of an assignment; in that case, those languages assume computed assignment rather than global assignment. That nuance sweeps under the rug the differences between the two types of assignment. It also yields many special cases that do not work correctly in those languages - for example, array subroutine parameters in IDL are passed by reference and can hence be used to change the original array - but array slices are copied before being passed, so the original array does not change. C sidesteps the issue by not (directly) supporting array slices. One result is that you can keep multiple representations of your data, and work on the representation that is most convenient.</p>

<p>For example:</p>

<pre><code>  pdl&gt; $a = xvals(5);
  pdl&gt; $b = $a(2); # global
  pdl&gt; $b .= 100;  # computed - flows back to $a
  pdl&gt; print $a;
  [0 1 100 3 4]</code></pre>

<p>Here, <code>$a(2)</code> is a slice corresponding to the third element of <code>$a</code> using the <a>PDL::NiceSlice</a> syntax. <code>$a</code> and <code>$b</code> remain connected by the slicing/indexing operation, so the change in <code>$b</code> flows back to <code>$a</code>. Most indexing operations maintain dataflow.</p>

<p>At times, you want to ensure that your variables remain separate or to make a physical copy of your data.</p>

<p>The copy operator makes a physical copy of its argument and returns it. In general, if you want a real copy of something, just ask for it:</p>

<pre><code>  pdl&gt; $a = xvals(5);
  pdl&gt; $b = $a(2)-&gt;copy;
  pdl&gt; $b .= 100;
  pdl&gt; print $a;
  [0 1 2 3 4]</code></pre>

<p>or, even more straightforwardly,</p>

<pre><code>  pdl&gt; $a = xvals(5);
  pdl&gt; $c = $a;       # $c and $a remain connected
  pdl&gt; $b = $a-&gt;copy; # $b is a (separate) copy of $a</code></pre>

<p>The <code>sever</code> operator is slightly more subtle. It acts in place on its argument, cutting most kinds of dataflow connection. It cannot disconnect two variables that were cloned with Perl&#39;s =; it can only sever the dataflow connection between related PDLs. The wart is present in current versions that rely on the Perl 5 engine, because it is not possible to overload the built-in <code>=</code> operator in Perl 5.</p>

<pre><code>  pdl&gt; $a = xvals(5);
  pdl&gt; $b = $a(2:3)-&gt;sever; # $b is a slice of $a: gets separated
  pdl&gt; $b += 100; print $a; # changing $b doesn&#39;t affect $a.
  [0 1 2 3 4]
  pdl&gt; $c = $a-&gt;sever;      # $c is a clone of $a: still connected
  pdl&gt; $c += 100; print $a; # changing $b affects $a.
  [100 101 102 103 104]</code></pre>

<h2 id="Broadcasting">Broadcasting</h2>

<p>Array languages like PDL perform basic operations by looping over an entire array, applying a simple operation to each element, row, or column of the array. This process is called <b>broadcasting</b>. Broadcasting is accomplished by the broadcasting engine, which matches up the sizes of different variables and ensures that they &quot;fit&quot;. The broadcasting engine is based on constructs from linear algebra (but is slightly more forgiving than most math professors).</p>

<p>Most operations act on the first few dimensions of a PDL. These first dimensions are active dimensions and any dimensions after that are called broadcast dimensions. The active dimensions must match any requirements of the operator, and the broadcast dimensions are automatically looped over by the broadcasting engine. The operator sets the number of active and broadcast dimensions. A given operator may have 0 active dimensions (e.g. addition, +), 1 active dimension (e.g. reduce operators like <code>sumover</code> and vector operators like <code>cross</code>), 2 active dimensions (e.g. matrix multiplication), or even more.</p>

<p>You can rearrange the way that an operator acts on a PDL by rearranging the dim list of that PDL, to bring dims down into the active position(s) for an operation or to bring them up to be broadcasted over. These rearrangements are a generalization of <i>matrix transposition</i>, though in general they are quite fast as they don&#39;t actually transpose the data in memory - only rearrange PDL&#39;s internal metadata that explain how the block of memory is to be used.</p>

<h3 id="Broadcasting-rules">Broadcasting rules</h3>

<p>PDL operators that act on two or more operands require the broadcast dimensions of each operand to match up. The broadcasting engine follows these rules for each dim (starting with the 0 dim and iterating through to the highest dim in either operand):</p>

<ul>

<li><p>If both operands have the dim and it has a size greater than 1 in each operand, then the size must be the same for both!</p>

<ul>

<li><p><code>print pdl(1,2,3) * pdl(3,4)</code> doesn&#39;t work, because dim 0 of the left operand has size 3 and dim 0 of the right operand has size 2.</p>

</li>
<li><p><code>print pdl(1,2,3)*pdl(4,5,6)</code> prints the string <code>[4 10 18]</code>.</p>

</li>
</ul>

</li>
<li><p>If both operands have the dim and it has size 1 in at least one operand (it is a trivial dim), then the dim is &quot;extended&quot; as a dummy dimension. This is a generalization of scalar multiplication in linear algebra.</p>

<ul>

<li><p>print pdl(1,2,3) * pdl(2) prints the string <code>[2 4 6]</code>.</p>

</li>
</ul>

</li>
<li><p>If a dimension exists in one operand and not in the other, it is treated as a virtual trivial dim</p>

<ul>

<li><p><code>print pdl([1,2],[3,4]) * pdl(3)</code> prints the string <code>[ [3 6] [9 12] ]</code>.</p>

</li>
</ul>

</li>
<li><p>If one operand is a PDL and the other is a Perl scalar, the scalar is PDL-ified before the operation</p>

<ul>

<li><p><code>print pdl([1,2],[3,4]) * 3</code> prints the string <code>[ [3 6] [9 12] ]</code>.</p>

</li>
</ul>

</li>
</ul>

<h3 id="Controlling-broadcasting-and-dimension-order:-xchg-mv-reorder-flat-clump-and-reshape">Controlling broadcasting and dimension order: xchg, mv, reorder, flat, clump, and reshape</h3>

<p>Because rearranging the dim list of a PDL (i.e. transposing it) is the way to control the broadcasting engine, PDL has many operators that are devoted to rearranging dim lists. Here are six of them:</p>

<p><b>transpose - matrix transposition</b></p>

<p><code>$at=$a-&gt;transpose</code> will yield the transpose of a matrix <code>$a</code> (that is, with the 0 and 1 dims exchanged); you can use <code>$a-&gt;inplace-&gt;transpose</code> to change the variable itself. Of course, if <code>$a</code> has more than two dims, it is treated as a collection of matrices (the other dims are broadcasted over).</p>

<p><b>xchg - generalized transposition</b></p>

<p>You can generalize transpose to any two dims with xchg - just give the index numbers and those two indices get exchanged (transposed): <code>$at = $a-&gt;xchg(0,1)</code> is the same as using transpose, but you can also say (for example) <code>$ax = $a-&gt;xchg(0,3)</code>.</p>

<p><b>mv - dim reshuffling</b></p>

<p>Using mv shifts a dim from its original location to a new location; all the other dims stay in the same relative order but get shifted to make room and/or fill up the old slot. You can say, for example,<code>$b = $a-&gt;mv(3,0)</code> to move dimension 3 to the 0 slot. Afterward, <code>$b</code> will have the dimensions of <code>$a</code> in the order (3,0,1,2).</p>

<p><b>reorder - arbitrary redimensioning</b></p>

<p>This is useful for carrying out many transpositions at once. You specify the order in which the old dimensions should appear in the new PDL: <code>$b=$a-&gt;reorder(3,0,1,2)</code> is the same as <code>$b=$a-&gt;mv(3,0)</code>, and <code>$at=$a-&gt;reorder(1,0)</code> does the same thing as <code>$at=$a-&gt;transpose</code>. You can reorder all the dimensions of your PDL or just the first few - if you ignore later dimensions they carried along &quot;for the ride&quot;, keeping the same order in which they came.</p>

<p><b>flat - flatten a PDL</b></p>

<p>Flat reduces a PDL of arbitrary dimension to one with a single long dimension. The 0 dimension runs fastest in the resulting 1-D PDL, and the last dimension runs slowest. For example, if <code>$a</code> is a 120x120 image then <code>$a-&gt;flat</code> is a 1-D array of 14400 values. That is useful, for example, for making a reduce operator (see Section [sub:Collapse-Operators]) work on a whole PDL at once. In the above example, <code>$a-&gt;average</code> would return a 120-array of row average brightnesses, but <code>$a-&gt;flat-&gt;average</code> would return the average brightness of the whole image (or, if <code>$a</code> had more dimensions) the average brightness of the whole collection.</p>

<p><b>clump - flatten specific dims</b></p>

<p>Clump is useful for making an operation that normally works on one dimension work on more at once. For example, <code>$im-&gt;average</code> reduces an NxMx3 RGB image into a Mx3 array of row-average brightnesses. If you want the average brightness of each color throughout the whole image, you can say either <code>$im-&gt;average-&gt;average</code> or <code>$im-&gt;clump(2)-&gt;average</code>, to get a 3-array of average brightnesses for R, G, and B.</p>

<p><b>reshape - allocate dims yourself</b></p>

<p>With reshape you can reassign the block of memory that makes up a PDL, cutting it up however you please. For example, if <code>$a</code> is a 60x60 image, you can say <code>$b=$a-&gt;reshape(100,36)</code> to create instead a 100x36 image. The product of the new dimensions should be less than or equal to the product of the old dimensions, or strange things may happen!</p>

<h3 id="Dummy-Dimensions">Dummy Dimensions</h3>

<p>Dummy dimensions are bookkeeping dimensions that act to the broadcasting engine like complete dimensions but in fact repeat the same data in each position in the new dimension. A dummy dimension is simply a convenient bookkeeping convention; no extra memory is allocated for it. You create dummy dimensions with the dummy operator or via the slicing syntax explained elsewhere.</p>

<p>The dummy operator takes two parameters: a position at which the dummy dimension is to be inserted into the dim list, and a size. For example, if <code>$a</code> is a 100-array, then <code>$b=$a-&gt;dummy(0,50)</code> makes $b a 50x100 image - except that each column of $b points to the same piece of memory, so that assigning to any element of $b changes a whole row.</p>

<p>You can &quot;physicalize&quot; a dummy dimension by making an explicit copy. For example, <code>$b=$a-&gt;dummy(0,50)-&gt;copy</code> makes <code>$b</code> a 50x100 image, each column of which happens to contain the same data, but in this case every pixel of $b is allocated separately from memory, so that assigning to $b works in the normal way.</p>

<h3 id="Collapse-Reduce-Operators-and-Reduction">Collapse/Reduce Operators and Reduction</h3>

<p>PDL contains many &quot;collapse operators&quot;: enough of them that they deserve special attention as a group. A collapse operator has a single active dim. It summarizes elements along each row (the 0 dim) of a PDL, returning the summary of that row as a single number. Thus, a collapse operator will reduce a D-dimensional PDL to D-1 dimensions. The average, sumover, and andover operators are examples of collapse operators: each one has a single active dim and produces the average, sum, or logical AND (respectively) of everything along that dim of the argument PDL. To average over a dim other than the 0 dim, you must move that dim to the 0 position. For example, to convert a color image that is (NxMx3) to a black-and-white image that is (NxM) you can say $bw=$rgb-&gt;mv(2,0)-&gt;average. For historical reasons, some documentation refers to them as &quot;reduce operators&quot;, because they reduce the dimensionality of their operands.</p>

<h3 id="PDL-Headers">PDL Headers</h3>

<p>Every PDL can contain a &quot;header&quot; - a perl hash ref (that is, a collection of keyword/value pairs) that stores metadata about the PDL itself. Some of the built-in routines are aware of the FITS WCS format for metadata about scientific images, and use the header slot to store a WCS coordinate system about the PDL; but most operations do not use or affect the header at all. You are free to store whatever data you like in it.</p>

<p>An internal flag associated with each PDL controls whether the header is propagated to derived PDLs. Copying the header can be a time-consuming operation, many times slower than arithmetic on small PDLs - but it can be quite convenient as well. PDL keeps the copying flag false by default on most new PDLs, but if you set it to true (using the hdrcpy method, see below), then the both the header and the copy flag will be copied to derived PDLs.</p>

<p>Convenient interfaces exist to use an <a>Astro::FITS::Header</a> tied hash instead of a normal Perl hash ref. <a>Astro::FITS::Header</a> tied hashes act like normal Perl hashes but force case-insensitivity and provide some control over the card structure of the underlying FITS header.</p>

<p><b>hdr &amp; fhdr - access PDL header elements</b></p>

<p>You can access elements the header of a PDL by inlining the hdr or fhdr method into a hash dereference: <code>$a-&gt;hdr-&gt;{keyword}=$value;</code>, or <code>$val=$a-&gt;hdr-&gt;{keyword}</code>. If the header doesn&#39;t exist, then it is autogenerated. The only difference between hdr and fhdr is that, if no header exists, fhdr autogenerates tied FITS header objects while hdr autogenerates normal Perl hashes.</p>

<p><b>gethdr &amp; sethdr - manipulate a complete PDL header</b></p>

<p>You can get or store the current header of a PDL with the <code>gethdr</code> and <code>sethdr</code> methods. <code>$a-&gt;gethdr</code> returns either a hash ref (which could be a tied object such as a FITS header object) or the undefined value. <code>$a-&gt;sethdr($hdr)</code> accepts either a hash ref or the undefined value, and assigns it to the pdl&#39;s header.</p>

<p><b>hdr_copy - return a deep copy of a PDL&#39;s header</b></p>

<p>The gethdr method makes a shallow copy of the PDL&#39;s header - it returns a ref that points to the original header data. If instead you want a complete, deep copy (that you can modify without affecting the original PDL) you want <code>hdr_copy</code> instead.</p>

<p><b>hdrcpy - control header copying</b></p>

<p>If you apply an operator to a PDL with a header set, you can arrange to have the header copied to the result PDL. The underlying hash or object is deep-copied, which is somewhat expensive; so you must set a flag on the source PDL to make it happen. <code>$a-&gt;hdrcpy()</code> returns the state of the copying flag; <code>$a-&gt;hdrcpy($flag)</code> sets it. False values (the default) turn the feature off, true values turn it on.</p>

<h1 id="Slicing-Dicing-and-Broadcasting-dims-with-PDL">Slicing, Dicing and Broadcasting dims with PDL</h1>

<p>Fundamental to any vectorized data language such as PDL is the ability to manipulate subsets of data in convenient ways. PDL provides the facilities to change the size and dimensionality of data, to take contiguous and non-contiguous subsections of data along dimensions and to take completely arbitrary subsets of data meeting arbitrary criteria.</p>

<p>A key powerful feature is the ability to manipulate these subsets of data, and if desired to propagate these changes back to the original data <b>automatically</b>. This includes passing data to user-written subroutines, which may call standard external C code, which do not know or care about whether the data is a subset or not.</p>

<p>That sounds pretty abstract - but here is a concrete example: with PDL one could for example select all the pixels in an image greater than a certain value or meeting some other condition. This might serve to isolate a bright star or galaxy. One could then pass the pixel values and their locations to a photometry subroutine (which is just written to work on data arrays not caring whether it is a subset or not) which would fit the pixels with some model and replace them in the array. These changed pixels would then be automatically changed in the original image.</p>

<p>This sort of abstraction is extremely powerful as it allows for very concise and clear code. We&#39;ll start by looking at the simplest operations to extract simple slices of ndarrays, and look at increasingly more complex kinds of slices.</p>

<h2 id="Finding-ndarray-dimensions">Finding ndarray dimensions.</h2>

<p>PDL data arrays can take arbitrary sizes and dimensions. Finding the current dimensions is straight-forward with the <code>dims</code> function which returns a list:</p>

<pre><code>    $data = zeroes(100,20,3);
    print dims($data);
    ($nx, $ny, $nz) = dims($data);</code></pre>

<p>See also the <code>shape</code> function which returns the pdl shape as a pdl:</p>

<pre><code>    $datashape = shape($data);</code></pre>

<p>The number of elements in a ndarray is equally easy:</p>

<pre><code>    print nelem($data); </code></pre>

<h2 id="The-slice-function---regular-subsets-along-axes">The <code>slice</code> function - regular subsets along axes</h2>

<p>Earlier we saw how to extract a rectangular subset of a ndarray:</p>

<pre><code>    $section = $gal(337:357,178:198);</code></pre>

<p>The ndarray <code>$gal</code> was a 2D image, we used array syntax (compliments of <code>PDL::NiceSlice</code>) to extract a contiguous subset ranging from pixel 337 to 357 along the first dimension, and 178 through 198 along the second. Behind the scenes, this is implemented by the <code>slice</code> function.</p>

<pre><code>    $section = $gal-&gt;slice(&#39;337:357,178:198&#39;);</code></pre>

<p>Use the on-line documentation:</p>

<pre><code>    pdl&gt; help slice</code></pre>

<p>to explore the full set of options. <code>slice</code> is probably the most frequently used PDL function so we will explore it in some detail. But first we notice that <code>slice</code> is implemented via a named function.</p>

<p>Through the magic of <code>PDL::NiceSlice</code> and source filtering you can access <code>slice</code> functionality in a form very similar to the vector array syntax found in many array computation languages such as FORTRAN-90 and MATLAB. The chief difference being that the argument to the <code>slice</code> method call is a <i>string</i> describing the elements to be selected. For the new <code>PDL::NiceSlice</code> syntax, you don&#39;t use the method or function call and the argument does not need to be wrapped up in a string.</p>

<p>In this chapter, we will usually show the <code>PDL::NiceSlice</code> syntax but refer to the operation as a slice even though with the new syntax there is no longer an explicit <code>slice</code> method being called.</p>

<h3 id="The-basic-slicing-specification">The basic slicing specification.</h3>

<p>The slicing argument syntax is just a list of ranges, the simplest if of the form <code>A:B</code> to specify the start and end pixels. This generalizes to arbitrary dimensions;</p>

<pre><code>    $data = zeroes(1000);
    $sec = $data(0:20);
    $data = zeroes(100,100,20);
    $sec = $data(0:20,40:60,1:3);</code></pre>

<p>Note that PDL, just like Perl and C, uses <b>ZERO OFFSET</b> arrays. i.e. the first element is numbered 0, not 1. Just like Perl you can use <code>-N</code> to refer to the last elements:</p>

<pre><code>    $data = zeroes(1000);
    $sec = $data(-10:-1); # Elements 990 to 999 (last)</code></pre>

<p>One can also specify a step in the slice using the form <code>A:B:C</code> where <code>C</code> is the step. Here is an example:</p>

<pre><code>    pdl&gt; $x = sequence(24); # Create an ndarray of increasing value
    pdl&gt; print $x
    [0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23]
    pdl&gt; print $x(16:22:2)
    [16 18 20 22]</code></pre>

<p>Quite often one wants all the elements along many of the dimensions, one can just use &quot;<code>:</code>&quot; or just omit the specifier altogether:</p>

<pre><code>    pdl&gt; $a = zeroes(10,20,3)
    pdl&gt; print dims $a(:,5:10,:)
    10 6 3
    pdl&gt; print dims $a(,5:10,)
    10 6 3</code></pre>

<p>Omitting the range allows specification of just one index along the dimension:</p>

<pre><code>    $z = zeroes 100,200; 
    $col = $z(42,:); # Column 42 (Dims = 1x200) 
    $row = $z(:,42); # Row 42 (Dims = 100x1) </code></pre>

<p>You also can use perl scalars to construct the slicing specifications:</p>

<pre><code>    $x1 = 2; $x2 = 42; 
    $sec = $data($x1:$x2);</code></pre>

<h3 id="Modifying-slices">Modifying slices.</h3>

<p>Here&#39;s the biggy:</p>

<pre><code>    pdl&gt; $x = sequence(24); 
    pdl&gt; print $x; 
    [0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23]
    pdl&gt; $slice = $x(4:20:2);
    pdl&gt; print $slice;
    [4 6 8 10 12 14 16 18 20]</code></pre>

<p>All very well. But now we modify the slice using the assignment operator.</p>

<pre><code>    pdl&gt; $slice .= 0;
    pdl&gt; print $slice;
    [0 0 0 0 0 0 0 0 0]
    pdl&gt; print $x;
    [0 1 2 3 0 5 0 7 0 9 0 11 0 13 0 15 0 17 0 19 0 21 22 23 24]</code></pre>

<p>Modifying the slice automatically modifies the original data! However it is done ( <code>$slice++</code> etc. work just as well).</p>

<p>All the PDL slicing and dicing functions work this way, from the simplest rectangular slices to the most complex conditional slices. This is because they use a fundamental PDL feature known as <b>dataflow</b>.</p>

<h3 id="Does-a-slice-consume-memory">Does a slice consume memory?</h3>

<p>What if we have a big array and make a slice of most of it:</p>

<pre><code>    $x = zeroes (2000,2000); 
    $slice = $x(10:1990,10:1990); 
    $slice++;</code></pre>

<p>If you monitor the memory consumed by the PDL process on your computer (UNIX/Linux users can try the <code>top</code> command) you will see that the amount of memory consumed does not go up - <b>even when the slice is modified</b> . This is because the way PDL is written allows many of the simple operations on slices to be optimized - i.e. a temporary internal copy of the slice need not be made. Of course sometimes - for example when passing to an external subroutine - this optimization is not possible. But the book-keeping of propagating the changes back to the original ndarray is handled automatically.</p>

<h3 id="Advanced-slice-syntax">Advanced slice syntax</h3>

<p><code>slice</code> has some advanced syntactical features which allow dimensions to be inserted or removed (this comes in quite useful when passing 2D arrays to functions expecting 1D arguments and vice versa, this comes in extremely useful when using PDL&#39;s advanced <b>broadcasting</b> features (see <i>PDL broadcasting and the signature</i> later.</p>

<p>If a dimension is of size unity it can be removed using <code>()</code>:</p>

<pre><code>    $z = zeroes 100,30;
    $col = $z(42,:); # Column 42 - 2D (Dims = 1x30)
    $col = $z((42),:); # Column 42 - 1D (Dims = 30)</code></pre>

<p>And then one can put them back again using &quot;<code>*</code>&quot;:</p>

<pre><code>    $col2 = $col(*,:,*); # Dims now = 1x30x1</code></pre>

<p>This can even be used to insert more than one element along the dimension:</p>

<pre><code>    $t = $z(:,*3,:); # Dims now 100x3x30</code></pre>

<p>This sort of thing is very useful for advanced broadcasting trickery.</p>

<h3 id="PDLs-Method-notation">PDL&#39;s Method notation</h3>

<p>At this point we would like to introduce the varied notations for calling <code>slice</code> and it&#39;s friends. This is because it will be commonly seen in PDL code and is very handy. While at first unfamiliar to C and FORTRAN users it is not rocket science, PDL users will quickly become used to it.</p>

<p>As we mentioned in Chapter 2 ndarrays are implemented as Perl objects. Objects can have their own personal functions, known as methods. The difference between a method and a function is that a method can only be used on the class of object it belongs too. And methods have a new notation for calling them. This means names (which can get in short supply) can be re-used for different objects.</p>

<p>Many of PDL&#39;s functions are available as methods too, in fact once you started using the more advanced features you will find that many of them are only available as methods. (PDL by default defines a lot of functions, which while useful do clutter Perl&#39;s namespace, at some point we had to stop!).</p>

<p>For example here are 3 different ways of calling <code>slice</code>:</p>

<pre><code>    $t = slice($z,&quot;:,*3,:&quot;); # Function call (old style) 
    $t = slice $z,&quot;:,*3,:&quot;; # Function call (old style) 
    $t = $z-&gt;slice(&quot;:,*3,:&quot;); # Method call (old style) 
    $t = $z(:,*3,:); # Vector syntax (NiceSlice style) 
    $t = $z-&gt;(:,*3,:); # Method call (NiceSlice style)</code></pre>

<p>The <code>PDL::NiceSlice</code> style vector syntax is the most concise and readable. The method call syntax (either old style or <code>PDL::NiceSlice</code> style) is also readable. You may need to understand the original slicing syntax to understand legacy PDL codes and for the cases where <code>PDL::NiceSlice</code> syntax can not or is not used. See the on-line docs for <code>PDL::NiceSlice</code> for details.</p>

<h2 id="The-dice-and-dice_axis-functions---irregular-subsets-along-axes">The <code>dice</code> and <code>dice_axis</code> functions - irregular subsets along axes</h2>

<p>As well as take regular slices along axes via the <code>slice</code> function, another common requirement is to take <b>irregular slices</b>, by which we mean a list of arbitrary coordinates. This operation is referred to in PDL as <b>dicing</b> an ndarray.</p>

<p>The <code>dice_axis</code> function performs a dice along a specified axis:</p>

<pre><code>    $a = sequence(10,20);
    $b = dice_axis $a, 0, [3,7,9]; # Dice along axis 0
    $b .= 42; # Alters columns [3,7,9];
    print $b;</code></pre>

<p>For a 2D ndarray dicing along axis 0 selects columns, dicing along axis 1 selects rows. In general in N-dimensions dicing along a given axis reduces the number of elements along that axis, but the number of dimensions remains unchanged. The <code>dice</code> function allows all axes to be specified at once:</p>

<pre><code>    $z = zeroes 10,20,50;
    print dims dice $z,[2,3,5],[10,11,12],[30..35,39,40];</code></pre>

<p>The list of axes in the dice can be specified using Perl&#39;s &quot;<code>[]</code>&quot; list reference notation or using a 1D ndarray:</p>

<pre><code>    $z = sequence 10,20;
    $dice = long(random(10)*10); # Select random columns
    $sel = $z-&gt;dice_axis(0,$dice); </code></pre>

<h2 id="Using-mv-xchg-and-reorder---transposing-dimensions">Using <code>mv</code>, <code>xchg</code> and <code>reorder</code> - transposing dimensions</h2>

<p>We saw earlier how arguments to <code>slice</code> can be used to add and remove dimensions. More sophisticated tricks can be performed with a whole suite of PDL methods.</p>

<p><code>xchg</code> simply swaps two dimensions:</p>

<pre><code>    $z = zeroes(3,4);
    $t = $z-&gt;xchg(0,1); # Axes 0 and 1 swapped, dims now = 4,3</code></pre>

<p>This is a simple matrix transpose. The method <code>$z-&gt;transpose</code> also does this, though it also makes a copy (i.e. return a new ndarray) not a slice and can operate on 1D ndarrays (i.e. convert a row vector into a column vector). Sometimes this is what you want. <code>xchg</code> works like <code>slice</code> and <code>dice</code> - changes affect the original. Also <code>xchg</code> generalizes to N-dimensions:</p>

<pre><code>    $z = zeroes(3,4,5,6,7);
    $t = $z-&gt;xchg(1,3); # Dims now 3,6,5,4,7</code></pre>

<p>A different way of switching dimensions around is provided by <code>$z-</code>mv(A,B)&gt; which just moves the axis <code>A</code> to position <code>B</code> :</p>

<pre><code>    $z = zeroes(3,4,5,6,7);
    $t = $z-&gt;mv(1,3); # Dims now 3,5,6,4,7</code></pre>

<p>Finally one can completely re-order dimensions:</p>

<pre><code>    $z = zeroes(3,4,5,6,7);
    $t = $z-&gt;reorder(4,3,0,2,1); # Dims now 7,6,3,5,4</code></pre>

<p>Note <code>reorder</code> is our first example of a pure PDL method - it does not exist as a function and can only be called using the <code>&lt;$z-</code>reorder(...)&gt;&gt; syntax.</p>

<h2 id="Combining-dimensions-with-clump">Combining dimensions with <code>clump</code></h2>

<p>We&#39;ve now seen a whole slew of functions for changing the ordering of dimensions. It is now time to look at some more complicated operations. The first of these is something we have already seen in Chapter 1. This is the <code>clump</code> function for combining dimensions together. Suppose we have a 3-D datacube ndarray:</p>

<pre><code>    pdl&gt; $a = xvals(5,3,2);
    pdl&gt; print $a;

    [
     [
      [0 1 2 3 4]
      [0 1 2 3 4]
      [0 1 2 3 4]
     ]
     [
      [0 1 2 3 4]
      [0 1 2 3 4]
      [0 1 2 3 4]
     ]
    ]</code></pre>

<p>We have seen before we can apply a 1-D function like <code>sumover</code> to the rows - and using dimension manipulating functions to any of the axes.</p>

<p>But say we wanted to sum over the first <b>TWO</b> dimensions? i.e. replace our datacube with a 1-D vector containing the sums of each plane. What we need to do is to &quot;clump&quot; the first two dimensions together to make one dimension, and then use <code>sumover</code>. Surprisingly enough this is what <code>clump</code> does:</p>

<pre><code>    pdl&gt; $b = $a-&gt;clump(2); # Clump first two dimensions together
    pdl&gt; print $b;
    [
     [0 1 2 3 4 0 1 2 3 4 0 1 2 3 4]
     [0 1 2 3 4 0 1 2 3 4 0 1 2 3 4]
    ]
    pdl&gt; $c = sumover $b;
    pdl&gt; print $c;
    [30 30]</code></pre>

<p>Now we know about <code>mv</code> it is also easy to sum over the last two dimensions:</p>

<pre><code>    pdl&gt; print sumover $a-&gt;mv(0,2)-&gt;clump(2)
    [0 6 12 18 24]</code></pre>

<p>It is also possible using the special form <code>clump(-1)</code> to clump <b>all</b> the dimensions together:</p>

<pre><code>    pdl&gt; $x = sequence(10,20,30,40);
    pdl&gt; print dims $x-&gt;clump(-1);
    240000
    pdl&gt; print sumover $x-&gt;clump(-1); # Same as sum($x)
    28799880000</code></pre>

<p>Uncannily this is almost exactly how the <code>sum</code> function is implemented in PDL.</p>

<h2 id="Adding-dimensions-with-dummy">Adding dimensions with <code>dummy</code></h2>

<p>After our first look at broadcasting in Chapter 2 we know how to add a vector to rows of an image:</p>

<pre><code>    pdl&gt; print $a = pdl([1,0,0],[1,1,0],[1,1,1]);
    [
     [1 0 0]
     [1 1 0]
     [1 1 1]
    ]
    pdl&gt; print $b = pdl(1,2,3);
    [1 2 3]
    pdl&gt; print $a+$b;
    [
     [2 2 3]
     [2 3 3]
     [2 3 4]
    ]</code></pre>

<p>But say we wanted to add the vector to the columns. You might think to transpose <code>$a</code> :</p>

<pre><code>    pdl&gt; print $a-&gt;xchg(0,1)+$b;
    [
     [2 3 4]
     [1 3 4]
     [1 2 4]
    ]</code></pre>

<p>But the result is the transpose of the desired result. We could of course just transpose the result but a cleaner method is to use <code>dummy</code> to change the dimensions of <code>$b</code> :</p>

<pre><code>    pdl&gt; print $b-&gt;dummy(0); # Result has dims 1x3
    [
     [1]
     [2]
     [3]
    ]</code></pre>

<p><code>dummy</code> just inserts a &quot;dummy dimension&quot; of size unity at the specified place. <code>dummy(0)</code> put&#39;s it at position 0 - i.e. the first dimension. The result is a column vector. Then we easily get what we want:</p>

<pre><code>    pdl&gt; print $a + $b-&gt;dummy(0);
    [
     [2 1 1]
     [3 3 2]
     [4 4 4]
    ]</code></pre>

<p>Because of the broadcasting rules the unit dimension makes <code>$b</code> implicitly repeat along axis 0. i.e. it is as if <code>&lt;$b-</code>dummy(0)&gt;&gt; <b>looked</b> like:</p>

<pre><code>    [
     [1 1 1]
     [2 2 2]
     [3 3 3]
    ]</code></pre>

<p><code>dummy</code> can also be used to insert a dimension of size &gt;1 with the data <b>explicitly</b> repeating:</p>

<pre><code>    pdl&gt; print dims $b-&gt;dummy(0,10);
    10 3
    pdl&gt; print $b-&gt;dummy(0,10);
    [
     [1 1 1 1 1 1 1 1 1 1]
     [2 2 2 2 2 2 2 2 2 2]
     [3 3 3 3 3 3 3 3 3 3]
    ]</code></pre>

<h2 id="Completely-general-subsets-of-data-with-index-which-and-where">Completely general subsets of data with <code>index</code> , <code>which</code> and <code>where</code></h2>

<p>Our look at advanced slicing concludes with a look at completely general subsets, specified using arbitrary conditions.</p>

<p>Let&#39;s make an ndarray of real numbers from 0 to 1:</p>

<pre><code>    pdl&gt; print $a = sequence(10)/10;
    [0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9]</code></pre>

<p>We can make a conditional array whose values are 1 where a condition is true using standard PDL operators. For example for numbers below 0.2 and above 0.9:</p>

<pre><code>    pdl&gt; print $a&lt;0.25 | $a&gt;0.85;
    [1 1 1 0 0 0 0 0 0 1]</code></pre>

<p>We&#39;ll use this as an example of an arbitrary condition. Using <code>which</code> we can return an ndarray containing the positions of the elements which match the condition:</p>

<pre><code>    pdl&gt; $idx = which($a&lt;0.25 | $a&gt;0.85); print $idx;
    [0 1 2 9]</code></pre>

<p>i.e. elements 0..2 and 9 in the original ndarray are the ones we want. We can select these using the <code>index</code> function:</p>

<pre><code>    pdl&gt; print $a-&gt;index($idx);
    [0 0.1 0.2 0.9]</code></pre>

<p>So here we have an arbitrary, non-contiguous slice. However thanks to the magic of PDL we can still modify this as if it was still a more boring kind of slice and have our results affect the original:</p>

<pre><code>    pdl&gt; $a-&gt;index($idx) .= 0; # Set indexed values to zero
    pdl&gt; print $a;
    [0 0 0 0.3 0.4 0.5 0.6 0.7 0.8 0]</code></pre>

<p>In fact PDL possesses a convenience function called <code>where</code> which actually lets you combine these steps at once:</p>

<pre><code>    $a = sequence(10)/10;
    $a-&gt;where($a&lt;0.25 | $a&gt;0.85) .= 0;
    print $a; # Same result as above</code></pre>

<p>i.e. we make a subset of values <b>where</b> a certain condition is true. You can of course use index with explicit values:</p>

<pre><code>    # Increment first and last values

    $a = sequence(10);
    $a-&gt;index(pdl(0,9))++;</code></pre>

<p>What if you had a 2-D array? <code>index</code> is obviously one-dimensional. What happens is an implicit <code>clump(-1)</code> (i.e. the whole array is viewed as 1-D):</p>

<pre><code>    pdl&gt; $a = sequence(10,2);
    pdl&gt; $a-&gt;index(pdl(0,9)) .= 999;
    pdl&gt; print $a;
    [
     [999 1 2 3 4 5 6 7 8 9]
     [ 10 11 12 13 14 15 16 17 18 999]
    ]</code></pre>

<p>You can of course use <code>where</code> too for any number of dimensions:</p>

<pre><code>    # e.g.  make a cube with a sphere of 1&#39;s in the middle:
    $cube = rvals(100,100,100);
    $tmp = $cube-&gt;where($cube&lt;20);
    $cube .= 0;
    $tmp .= 1;</code></pre>

<h2 id="PDL-broadcasting-and-signatures">PDL broadcasting and signatures</h2>

<p>Slicing and indexing arbitrary subsets of data is certainly a fundamental aspect of any array processing language and PDL is no exception (as you can tell from the preceding examples). In PDL those functions might be even more important since they are absolutely vital in using PDL <b>broadcasting</b> , the fast (and automagic) vectorized iteration of &quot;elementary operations&quot; over arbitrary slices of multidimensional data. First we have to explain what we mean by <b>broadcasting</b> in the context of PDL, especially since the term <b>broadcasting</b> already has a distinct meaning in computer science that only partly agrees with its usage within PDL. In the following we will explain the general use of PDL broadcasting and highlight the close interplay with those slicing and dicing routines that you have just become familiar with (<code>slice</code>, <code>xchg</code>, <code>mv</code>, etc). But first things first: what is PDL broadcasting?</p>

<h3 id="Broadcasting1">Broadcasting</h3>

<p><b>Broadcasting</b> already has been working under the hood in many examples we have encountered in previous sections. It allows for fast processing of large amounts of data in a scripting language (such as <code>perl</code>). And just to be sure, PDL <b>Broadcasting</b> is <b>not</b> the same as broadcasting in the computer science sense or in the perl sense. Both concepts are related but more about that later.</p>

<h3 id="A-simple-example">A simple example</h3>

<p>As a starting point, we look at one of the PDL projection operators (they make N-1 dimensional ndarrays from N dim input ndarrays). So we need some data to try our code on. This time, we use the image of a tiny fluorescent bead that was recorded with a fluorescent microscope:</p>

<pre><code>    use PDL::IO::Pic;
    $im = rpic &#39;beads.jpg&#39;; # image stored in the JPEG format</code></pre>

<p>The following code snippet calculates the maxima of all rows of this image <code>$im</code> :</p>

<pre><code>    $max = $im-&gt;maximum;</code></pre>

<p>We rewrite this example slightly so that we can see the dimensions of the ndarrays involved using a little helper routine (see box) to print out the shape of ndarrays in the course of computations:</p>

<pre><code>    ($max = $im-&gt;pdim(&#39;Input&#39;)-&gt;maximum)-&gt;pdim(&#39;Result&#39;);</code></pre>

<p>that generates the following output:</p>

<pre><code>    Input Byte D [256,256]
    Result Byte D [256]

  Since is important to keep track of the dimensions
  of ndarrays when using (and especially when
  introducing) B&lt;PDL broadcasting&gt; we quickly define a
  shorthand command (a method) that lets us print
  the dimensions of ndarrays nicely formatted as
  needed:

  { package PDL;
    sub pdim {
       # pretty print type+dimensions and
       # allow for optional string arg
         my ($this) = @_;
         print (($#_ &gt; 0 ? &quot;$_[1]\t&quot; : &quot;&quot; ) .
             $this-&gt;info(&quot;%T %D\n&quot;)); # use info to print type and dims
         return $this;
    }
  }</code></pre>

<p>Two observations: note how we temporarily switched into the package PDL so that <code>pdim</code> can be used as a method on ndarrays and we made the function return the ndarray argument so that it can be seamlessly integrated into method invocation chains:</p>

<pre><code>    $a-&gt;pdim(&quot;Dims&quot;)-&gt;maximum;</code></pre>

<p>A small utility routine</p>

<p>So let&#39;s dissect what has happened. If you look at the documentation of <code>maximum</code> it says This function reduces the dimensionality of a ndarray by one by taking the maximum along the 1st dimension.</p>

<p>In this respect <code>maximum</code> behaves quite differently from <code>max</code>. <code>max</code> will always return a scalar with a value equal to that of the largest element of a (possibly multidimensional) ndarray. <code>maximum</code>, however, is by definition an operation that takes the maximum only over a one-dimensional vector. If the input ndarray is of higher dimension this <b>elementary operation</b> is automatically iterated over all one-dimensional subslices of the input ndarray</p>

<p>And, most importantly, this automatic iteration (we call it the <b>broadcastloop</b>) is implemented as fast optimized C loops. As a convention, these subslices are by default taken along the first dimensions of the input ndarray. In our current example the subslices are one-dimensional and therefore taken along the first dimension. All results are placed in an appropriately sized output ndarray of N-1 dimensions, one value for each subslice on which the operation was performed.</p>

<p>Now it should be no surprise that</p>

<pre><code>    pdl&gt; $im3d = sequence short, 5,10,3; # a 3D image (volume)
    pdl&gt; $max = $im3d-&gt;pdim(&#39;Input&#39;)-&gt;maximum;
    pdl&gt; print $max-&gt;pdim(&#39;Result&#39;) .  &quot; \n&quot;; generates

    Input   Short D [5,10,3]
    Result  Short D [10,3]
    [
     [  4   9  14  19  24  29  34  39  44  49]
     [ 54  59  64  69  74  79  84  89  94  99]
     [104 109 114 119 124 129 134 139 144 149]
    ]</code></pre>

<p>As expected the above command sequence creates a 2D ndarray (size <code>[10,3]</code>) of maxima of all rows of the original volume data.</p>

<h3 id="Why-bother">Why bother?</h3>

<p>Why should we go through this at length? Quickly you will realize that many more complicated operations can be assembled from the iteration of an elementary operation (that is if you keep reading this chapter). Those elementary operations that ship with the basic PDL distribution make the building blocks for your more complicated real world applications; broadcasting just makes sure it will all happen quickly enough and without too much syntactical effort from your side (you still will have to get your head round the idea). So let&#39;s expand our example a little further and postpone the why and how for a small while.</p>

<h3 id="More-examples">More examples</h3>

<p>Now suppose we do not want to calculate the maxima along the first dimension but rather along the second (the column maxima). However, we just heard that <code>maximum</code> works by definition on the first dimension. How can we make it do the same thing on the second dimension? Here is where the dimension manipulation routines come in handy: we use a to make an ndarray in which the original second dimension has been moved to first place. Guess how that is done: yes, using <code>xchg</code> we get what we want:</p>

<pre><code>    pdl&gt; $im3d = sequence short, 5,10,3; # a 3D image (volume)
    pdl&gt; $max = $im3d-&gt;xchg(0,1)-&gt;pdim(&#39;Input&#39;)-&gt;maximum;
    pdl&gt; print $max-&gt;pdim(&#39;Result&#39;) .  &quot; \n&quot;;</code></pre>

<p>generates</p>

<pre><code>    Input   Short D [5,10,3]
    Result  Short D [5,3]
    [
     [ 45  46  47  48  49]
     [ 95  96  97  98  99]
     [145 146 147 148 149]
    ]</code></pre>

<p>If you check <code>pdim</code>&#39;s output you see how the originally second dimension of size 10 has been moved to the first dimension (step 1-&gt;2) and, accordingly, maximum now does its work on all the columns of the original input ndarray <code>$im3d</code> (step 3).</p>

<p>Again PDL has automatically iterated the elementary functionality of maximum (calculate the maximum of a one-dimensional vector) over all subslices of the data and created an appropriately sized ndarray (here of shape <code>[5,3]</code>) to hold the resulting elements.</p>

<p>This general scheme works for most PDL functions. For example, let&#39;s say you have a stack of images (represented by a 3D ndarray) and you want to convolve each image with the same kernel. That&#39;s easy. Make sure the image dimensions (x and y) are the leading dimension in your ndarray:</p>

<pre><code>    $convolved = $stack-&gt;conv2d($kernel);</code></pre>

<p>And if your image stack is organized differently, e.g. the leading dimension is the z dimension, say in a [8,256,256] shaped ndarray just use <code>mv</code> to obtain the desired result:</p>

<pre><code>    $convolved = $stack-&gt;mv(0,2)-&gt;conv2d($kernel);</code></pre>

<p>These (admittedly simple) examples show the general principle: an elementary operation is iterated over subslices of one or several multidimensional ndarrays. Sometimes the dimensions of the input ndarrays involved need to be manipulated so that iteration happens as desired (e.g. over the intended subslices) and the result has the intended dimensionality. Formulating your problem at hand in a way that makes use of broadcasting rather than resorting to nested <code>for</code>-loops at the perl level can make the difference between a script that is executed faster than you can type and one that is crawling along and giving you plenty of time to have your long overdue lunch break.</p>

<h3 id="Why-broadcasting-and-why-call-it-broadcasting">Why broadcasting and why call it <b>broadcasting</b> ?</h3>

<p>So what are the advantages of relying on broadcasting to perform things you can achieve in perl also with explicit <code>for</code>-loops and the <code>slice</code> command? There are several (very good) reasons. The more you use PDL for your daily work the quicker you will appreciate this.</p>

<p>Before we get into the details of the why and how let&#39;s admit: PDL is by no means the first data language that supports this type of automatic implicit looping facility: the authors have in fact been inspired by several previous data language implementations, most notably <code>Yorick</code></p>

<p>Similar concepts are also implemented in APL and J, although well hidden by a wealth of terminology and notation very different from that of most other conventional computer languages . What we think distinguishes PDL from these previous languages is the consistent support of broadcasting throughout PDL, the tight integration with the PDL preprocessor (dealt with in a separate chapter) and the conceptual interplay with the dimension manipulation routines.</p>

<p>The first and most important reason to use <b>PDL broadcasting</b> is simply <b>speed</b> . The alternative to broadcasting are loops at the perl level. That is certainly a viable alternative, however, if we rewrite our maximum routine along these lines a quick benchmark test will prove our point. First of all, here is the code that does the equivalent of <code>maximum</code> on 2D input without using broadcasting</p>

<pre><code>    sub mymax {
       # we only cover the case of 2D input
       my ($pdl) = @_;
       die &quot;can only deal with 2D input&quot; unless $pdl-&gt;getndims == 2;
       $result = PDL-&gt;zeroes($pdl-&gt;type,$pdl-&gt;getdim(1));
       my $tmp;
       for (my $i=0;$i&lt;$pdl-&gt;getdim(1);$i++) {
          ($tmp = $result-&gt;slice(&quot;($i)&quot;)) .= $pdl-&gt;slice(&quot;,($i)&quot;)-&gt;max;
       }
       return $result;
    }</code></pre>

<p>We have written it so that <code>mymax</code> can just deal with 2D input ndarrays. A routine for the general n-dimensional case would have been more involved . Note that we explicitly have to create an output ndarray of the desired type and size. By comparison, the corresponding broadcasting routine is much more concise:</p>

<pre><code>    sub mybroadcastmax {
       my ($pdl) = @_;
       return $pdl-&gt;maximum;
    }</code></pre>

<p>In fact, we only wrapped <code>maximum</code> in another subroutine to have the same calling overhead as <code>mymax</code> . We are trying to be fair (even though we are biased). So let&#39;s compare the performance of <code>mymax</code> versus <code>mybroadcastmax</code> . How? Remember that we are using perl, after all, and that there is (almost) always a module that does just what you need. Here and now, that would be <code>Benchmark</code>.</p>

<p>Our benchmarking script looks like this</p>

<pre><code>    use Benchmark;
    use PDL;
    $a = sequence(10,300);
    timethese(0, { # run each for at least 3 CPU secs
                &#39;Perl loops&#39; =&gt; &#39;$pl = mymax $a;&#39;,
                &#39;PDL broadcast&#39; =&gt; &#39;$pt = mybroadcastmax $a;&#39;,
    });</code></pre>

<p>If we run this script it generates</p>

<pre><code> PDL broadcast: 4 wclk secs (2.48 usr + 0.64 sys = 3.12 CPU) @ 12802.88/s (n=40009) 
 Perl loops: 3 wclk secs (1.80 usr + 1.23 sys = 3.03 CPU) @    12.86/s (n=39)</code></pre>

<p>That proves our point: while the example using broadcasting is executed at a rate of nearly 13,000 per second using explicit loops has brought down the speed to less than 13/second, a very significant difference.</p>

<p>Obviously, the difference between broadcasting and explicit looping depends somewhat on the nature of the elementary operation and the ndarrays in question. The difference becomes most striking the more elementary operations are involved and the faster an individual elementary operation can be performed. The advantage of broadcasting will level off as the time for performing the elementary operation becomes comparable or even greater than that required to execute the explicit looping code.</p>

<p>Another distinct advantage becomes apparent when comparing the code required to implement the equivalent of the <code>maximum</code> functionality explicitly in perl code. We have to write extra code to create the right size output ndarray, explicitly handle dimension sizes, etc. All in all the code is much less concise and also less general.</p>

<p>With the requirement to deal with all dimensions, loop limits, etc yourself you increase the probability of introducing errors into your code. When using broadcasting, PDL checks all dimensions for you, makes sure it loops over the correct indices internally and keeps you from having to do the bookkeeping: after all, <b>that</b> is what computers are good at.</p>

<p>Even though PDL broadcasting makes your life much easier in one respect by taking care of some of the &quot;messy&quot; details it leaves you with another task: you have to find the places in your algorithm/problem where broadcasting can effectively be used and help to make for speedy execution even when using an (almost inevitably slower) scripting language. But finding such places and making use of these vectorized features is the key to using an array-oriented high level language like PDL successfully. This is what the programmer new to PDL and used to low-level programming has to learn: avoid explicit loops where possible and try to use automatically performed <b>broadcast loops</b> instead.</p>

<p>There is yet another benefit that comes with the broadcasting approach. By looking at places where broadcasting can be efficiently used you are also rethinking your problem in a way so that it can be very effectively parallelized! The keen reader has probably already observed that those internal automatic loops of elementary operations over subslices do not have to be performed sequentially. In fact, as of PDL-2.4.10, there is a new capability where PDL now support automatic parallelization of the PDL broadcastloops via POSIX threads:</p>

<pre><code>   use Benchmark qw(:hireswallclock);
   use PDL;
   $a = zeros(2_000_000);
   $b = zeros(2_000_000);
   set_autopthread_size(0);
   
   set_autopthread_targ(10);  # split across 10 threads
   timethese(20,{threaded =&gt; &#39;$a **= 1.3&#39;});
   
   set_autopthread_targ(0); # Set target to 0 for unthreaded
   timethese(20,{unthreaded =&gt; &#39;$b **= 1.3&#39;});</code></pre>

<p>For a Vista/Cygwin system with a quad-core i5 processor we see an greater than 2.5X reduction in wall clock time by using multiple processor cores. See documentation for <a>PDL::ParallelCPU</a> using <code>help PDL::ParallelCPU</code> in one of the PDL shells, or with <code>pdldoc PDL::ParallelCPU</code> from the command line.</p>

<h3 id="The-general-case:-PDL-functions-and-their-signature">The general case: PDL functions and their signature</h3>

<p>Having made the case for PDL broadcasting let&#39;s study its own messy details. PDL broadcasting is a powerful tool. And as usual you have to pay a price for power: complexity. The general rules for PDL broadcasting can be confusing at first. But there is hope: you can first study the more simple cases and work up to more difficult examples as you go. So let&#39;s continue our tour of broadcasting.</p>

<p>The first question arises naturally: how can one find out about the dimension of subslices in a elementary operation of a function in PDL? We know from the preceding examples that some PDL functions work on a one-dimensional subvector of the data and generate a zero-dimensional result (a scalar) from each of the processed subslices, for example: <code>maximum</code>, <code>minimum</code>, <code>sumover</code>, <code>prodover</code>, etc. Two-dimensional convolution (<code>conv2d</code>), on the other hand, consumes a 2D subslice in an elementary operation. But how do we get this information in general for any given function? It is easy: you just have to check the function&#39;s <b>signature</b>!</p>

<p>The signature is a string that contains this information in concise symbolic form: it names the parameters of a function and the dimensions of these parameters in an elementary operation. Additionally, it specifies which of these parameters are input parameters and which are output parameters. Finally, for some functions it contains information about special type conversions that are to be performed at run-time.</p>

<p>Generally, you can find the signature of a function using the perldl online help system. Just type <code>sig &lt;funcname</code>&gt; at the command prompt, e.g.:</p>

<pre><code>    pdl&gt; sig maximum

       Signature: maximum(a(n); [o]c())</code></pre>

<p>The interesting part is the formal argument list in parentheses that follows the function name:</p>

<pre><code>    a(n); [o]c()</code></pre>

<p>This signature states that <code>maximum</code> is a function with two arguments named <code>a</code> and <code>c</code>. Wait a minute: above it seemed that <code>maximum</code> only takes one argument and returns a result! The apparent contradiction is resolved by noting that the formal argument <code>c</code> is flagged with the <code>[o]</code> option identifying <code>c</code> is an output argument. This seems to suggest that we could <code>maximum</code> also call as <code>maximum($im, $result)</code>;</p>

<p>This is in fact possible and an intended feature of PDL that is useful in <b>tight loops</b> where it helps to avoid unnecessary reallocation of variables (see below). In general, however, we will call functions in the usual way that can be written symbolically as:</p>

<pre><code>    output_arg_list = function(input_arg_list)</code></pre>

<p>or equivalently, using the method notation:</p>

<pre><code>    output_arg_list = input_ndarray_1-&gt;function(rest_of_arg_list)</code></pre>

<p>The other important information supplied by the signature is the dimensionality of each of these arguments in an elementary operation. Each formal parameter carries this information in a list of formal dimension identifiers enclosed in parentheses. So indeed <code>a(n)</code> marks <code>a</code> as a one-dimensional argument. Additionally, each dimension has a <b>named</b> size in a signature, in this example <code>n</code> . <code>c()</code> has an empty list of dimension sizes: it is declared to be zero-dimensional (a scalar).</p>

<p>If ndarrays that are supplied as runtime arguments to a function have more dimensions than specified for their respective formal arguments in the signature then these dimensions are treated by PDL as <b>extra dimensions</b> and lead to the operation being <b>broadcasted</b> over the appropriate subslices, just what we have seen in the simple examples above.</p>

<p>As mentioned before a higher dimensional ndarray can be viewed as an array (again <b>not</b> in the perl array sense) of lower dimensional subslices. Anybody who has ever worked with matrix algebra will be familiar with the concept. For some of the following examples it will be useful to illustrate this concept in somewhat more detail. Let&#39;s make an ndarray first, a simple 3D ndarray:</p>

<pre><code>    $pdl = sequence(3,4,5);</code></pre>

<p>A boring ndarray, you say? Yes, boring, but simple enough to clearly see what is going on in the following. First we look at it as a 3D array of 0D subslices. Since we know the syntax of the <code>slice</code> method already we can write down all 0D subslices, no problem:</p>

<pre><code>    $pdl(($i),($j),($k));</code></pre>

<p>Well, obviously we have not written down all 3*4*5 = 60 subslices literally but rather in a more concise way. It is understood that <code>$i</code> can have any value between 0 and 2, <code>$j</code> between 0 and 3 and <code>$k</code> between 0 and 4. To emphasize this we sometimes write</p>

<pre><code>    $pdl(($i),($j),($k)) $i=0..2; $j=0..3; $k=0..4</code></pre>

<p>With the meaning as above (and &#39;..&#39; <code>not</code> meaning the perl list operator). In that way we enumerate all the subslices. Quite analogously, when dealing with an elementary operation that consumes 1D slices we want to view <code>$pdl</code> as an <code>[4,5]</code> array of 1D subslices:</p>

<pre><code>    $pdl(:,($i),($j)) $i=0..3; $j=0..4</code></pre>

<p>And similarly, as a <code>[5]</code> array of 2D subslices:</p>

<pre><code>    $pdl(:,:,($i)) $i=0..4</code></pre>

<p>You see how we just insert a &quot;:&quot; for each complete dimension we include in the subslice. In fig. XXX the situation is illustrated graphically for a 2D ndarray. Depending on the dimensions involved in an elementary operation we therefore often group the dimensions (what we call the <b>shape</b>) of an ndarray in a form that suggests the interpretation as an array of subslices. For example, given our 3D ndarray above that has a shape <code>[3,4,5]</code> we have the following different interpretations:</p>

<pre><code>    ()[3,4,5]  a shape [3,4,5] array of 0D slices
    (3)[4,5]   a shape [4,5]   array of 1D slices (of shape [3])
    (3,4)[5]   a shape [5]     array of 2D slices (of shape [3,4])
    (3,4,5)[]  a        0D     array of 3D slices (of shape [3,4,5]) </code></pre>

<p>The dimensions in parentheses suggest that these are used in the elementary operation (mimicking the signature syntax); in the context of broadcasting we call these the <b>elementary dimensions</b> . The following group of dimensions in rectangular brackets are the <b>extra dimensions</b>. Conversely, given the elementary/extra dims notation we can easily obtain the shape of the underlying ndarray by appending the extradims to the elementary dims. For example, a <code>[3,6,1]</code> array of 2D subslices of shape <code>[3,4]</code>:</p>

<pre><code>    (3,4)[3,6,1]</code></pre>

<p>identifies our ndarray&#39;s shape as <code>[3,4,3,6,1]</code></p>

<p>Alright, the principles are simple. But nothing is better than a few examples. Again a typical imaging processing task is our starting point. We want to convert a colour image to grayscale. The input image is represented as a two-dimensional array of triples of RGB colour coordinates, or in other words, an ndarray of shape <code>[3,n,m]</code> . Without delving too deeply into the details of digital colour representation it suffices to note that commonly a gray value <b>i</b> corresponding to a colour represented by a triple of red, green and blue intensities <b>(r,g,b)</b> is obtained as a weighted sum:</p>

<pre><code>       77        150       29   
   i = --- r  +  --- g  +  --- b
       256       256       256   </code></pre>

<p>A straight forward way to compute this weighted sum in PDL uses the <code>inner</code> function. This function implements the well-known <b>inner product</b> between two vectors. In a elementary operation <code>inner</code> computes the sum of the element-by-element product of two one-dimensional subslices (vectors) of equal length:</p>

<pre><code>        __ n-1        
   c = \          a   b 
       /__ i=0     i   i </code></pre>

<p>Now you should already be able to guess <code>inner</code>&#39;s signature:</p>

<pre><code>    pdl&gt; sig inner                                                      

  Signature: inner(a(n); b(n); [o]c())</code></pre>

<p><code>a(n); b(n); [o]c();</code> : two one-dimensional input parameters <code>a(n) </code> and <code>b(n)</code> and a scalar output parameter <code>c()</code> . Since <code>a</code> and <code>b</code> both have the same named dimension size <code>n</code> the corresponding dimension sizes of the actual arguments will have to match at runtime (which will be checked by PDL!). We demonstrate the computation starting with a colour triple that produces a sort of yellow/orange on an RGB display:</p>

<pre><code>    $yel = byte [255, 214, 0]; # a yellowish pixel
    $conv = float([77,150,29])/256; # conversion factor
    $i = inner($yel,$conv)-&gt;byte; # compute and convert to byte
    print &quot;$i \backslash n&quot;;
    202</code></pre>

<p>Now broadcasting makes extending this example to a whole RGB image very straightforward:</p>

<pre><code>    use PDL::IO::Pic; # IO for popular image formats
    $im = rpic &#39;pdllogo.jpg&#39;; # a colour image from the book dataset
    $gray = inner($im-&gt;pdim(&#39;COLOR&#39;),$conv);
       # broadcasted inner product over all pixels
    $gb = $gray-&gt;byte; # back to byte type
    COLOR Byte D [3,500,300]</code></pre>

<p>The code needs no modification! Let us analyze what is going on. We know that <code>$conv</code> has just the required number of dimensions (namely one of size 3). So this argument doesn&#39;t require PDL to perform broadcasting. However, the first argument <code>$im</code> has two <b>extra dimensions</b> (shape <code>[500,300]</code>). In this case broadcasting works (as you would probably expect) by iterating the inner product over the combination of all 1D subslices of <code>$im</code> with the one and only subslice of <code>$conv</code> creating a resulting ndarray (the grayscale image) that is made up of all results of these elementary operations: a 500x300 array of scalars, or in other words, a 2D ndarray of shape <code>[500,300]</code>.</p>

<p>We can more concisely express what we have said in words above in our new way to split ndarray arguments in elementary dimensions and extra dimensions. At the top we write <code>inner</code>&#39;s signature and at the bottom the <code>slice</code> expressions that show the subslices involved in each elementary operation:</p>

<pre><code>    NDArrays $im $conv $gray
    Signature a(n); b(n); [o]c()
    Dims (3)[500,300] (3)[] ()[500,300]
    Slices &quot;:,($i),($j)&quot; &quot;:&quot; &quot;($i)($j)&quot;</code></pre>

<p>Remember that the slice notation at the bottom does not mean that you have to generate all these slices yourself. It rather tells you which subslices are used in a elementary operation. It is a way to keep track what is going on behind the scenes when PDL broadcasting is at work. Broadcasting makes it possible that we can call the grayscale conversion with ndarrays representing just one RGB pixel (shape <code>[3]</code>), a line of RGB pixels (shape <code>[3,n]</code>), RGB images (shape <code>[3,m,n]</code>), volumes of RGB data (shape <code>[3,m,n,o]</code>), etc. All we have to do is wrap the code above into a small subroutine that also does some type conversion to complete it:</p>

<pre><code>    sub rgbtogr {
       my ($im) = @_;
       my $conv = float([77,150,29])/256; # conversion factor
       my $gray = inner $im, $conv;
       return $gray-&gt;convert($im-&gt;type); # convert to original type
    }</code></pre>

<h3 id="You-can-write-your-own-broadcasting-routines">You can write your own broadcasting routines</h3>

<p>Did you notice? By writing this little routine we have created a new function with its own signature that will broadcast as appropriate. It has <b>inherited</b> the ability to broadcast from <code>inner</code>. So what is the signature of <code>rgbtogr</code>? It is nowhere written explicitly and we can&#39;t use the <code>sig</code> function to find out about it</p>

<p><code>sig</code> will only know about functions that were created using <code>PDL::PP</code> or if we explicitly specified the signature in the PDL documentation but from the properties of <code>inner</code> and the definition of <code>rgbtogr</code> we can work it out. As input it takes ndarrays with a size of the first dimension of 3 and returns for each of the 1D subslices a 0D result (the gray value). In other words, the signature is</p>

<pre><code>    a(tri = 3); [o] b()</code></pre>

<p>There is some new syntax in this signature that we haven&#39;t seen before: writing <code>tri=3</code> signifies that in a elementary operation <code>rgbtogr</code> will work on 1D subslices (we have encountered this before); additionally, the size of the first dimension (named suggestively <code>tri</code>) <b>must</b> be three. You get the idea. What we have just seen is worth keeping in mind! By using PDL functions in our own subroutines we can make new functions with the ability to broadcast over subslices. Obviously, this is useful. We will come back to this feature when we talk about other ways of defining broadcasting functions using PDL::PP below.</p>

<h3 id="Matching-broadcasting-dimensions">Matching broadcasting dimensions</h3>

<p>After this small digression, back to the subject at hand: what happens when both ndarray arguments have extra dimensions? Well, the extra dimensions have to match. Otherwise we wouldn&#39;t know how to sensibly pair the subslices, right? So when do extra dimensions match? It is quite simple: corresponding extra dimensions have to have the same size in both ndarray arguments. Corresponding extra dimensions are those that occur in both ndarrays. However, one ndarray can have more extra dimensions than the other without causing a mismatch. That sounds strange? Ok, here is an example. We use one of the fundamental arithmetic operations in PDL, addition implemented by the &quot;<code>+</code>&quot; operator. You know already that in an array-oriented language like PDL addition is performed element-by-element on scalars. So the signature of &quot;<code>+</code>&quot; comes as no surprise</p>

<pre><code>    a(); b(); [o] c()</code></pre>

<p>two scalars are summed to yield a scalar result. And when we use higher dimensional ndarrays in an addition this elementary operation is performed over all 0D subslices, as before. So let&#39;s go through a few cases. First make some simple ndarrays</p>

<pre><code>    $a = pdl [1,2,3];
    $b = pdl [1,1,1];
    $c = ones 3,2;
    $d = pdl [3,4];
    print $a + $b, &quot;\n&quot;; </code></pre>

<p>No big deal. extradims for both ndarrays have shape <code>[3]</code> obviously matching, resulting in</p>

<pre><code>    [2 3 4]</code></pre>

<p>Next,</p>

<pre><code>    print $a + $c;
    [
     [2 3 4]
     [2 3 4]
    ]</code></pre>

<p>Alright, this probably is exactly what you expected but let us go through our new terminology and check that we can formally agree with what we intuitively expected anyway.</p>

<p><code>$a</code>&#39;s <b>extradim</b> (s) has shape <code>[3]</code> , those of <code>$c</code> shape <code>[3,2]</code>. The <b>corresponding</b> <b>extradim</b>(s) in this case is just the first one for the ndarrays involved. It is equal to 3 in both input ndarrays, so clearly matches.</p>

<pre><code>    $a $c
    a(); b(); [o] c()
    ()[3] ()[3,2] ?????</code></pre>

<p>Now, here is something we have not explicitly discussed yet: what is the shape of the automatically created output ndarray given the shape of the extradims of the input ndarrays involved? Well, the result is created so that it has as many extradims as that input <b>ndarray</b>(s) with the most extra dims. Additionally, the shape will match that of the input ndarrays. In our current example that leaves us with a result with extradim shape <code>[3,2]</code>: <code>[o] c() ()[3,2]</code>. Remembering that we obtain the shape of the output ndarray by appending the shapes of the extradims to that of the elementary dimensions (here a scalar, i.e. 0D) that leaves us with a result ndarray of shape <code>[3,2]</code>.</p>

<p>In the next example we want to multiply <code>$c</code> with <code>$d</code> so that each row of <code>$c</code> is multiplied by the corresponding element of <code>$d</code> or expressed in slices (with NiceSlice syntax):</p>

<pre><code>    $result(($i),($j)) = $c(($i),($j)) * $d(($j)) $i=0..2, $j=0..1</code></pre>

<p>How do we achieve that by broadcasting?</p>

<pre><code>    $result = $c*$d</code></pre>

<p>is not the right way.</p>

<p>Why? Well, the extradims don&#39;t match, <code>[3,2]</code> does not match <code>[2]</code> since 2 is not equal to 3. Just to see how PDL checks this let us actually execute the command. The slightly obscure error message is something like this</p>

<pre><code>    PDL: PDL::Ops::mult(a,b,c): Parameter &#39;b&#39;
    PDL: Mismatched implicit broadcast dimension 0: should be 3, is 2
    Caught at file (eval 344), line 4, pkg main</code></pre>

<p>This is PDL&#39;s way to tell you that the extra dimensions don&#39;t match.</p>

<p>So how do we do it? We use one of the dimension manipulation methods again. This time <code>dummy</code> comes in handy. We want to multiply each element in the nth row of <code>$c</code> with the nth element of <code>$d</code> . So we have to repeat each element of <code>$d</code> as many times as there are elements in each row of <code>$c</code> . This is exactly what we can achieve by inserting a dummy dimension of size <code>&lt;$c-</code>getdim(0)&gt;&gt; as dimension 0 of <code>$d</code> :</p>

<pre><code>    pdl&gt; print $d-&gt;dummy(0,$c-&gt;getdim(0))-&gt;pdim(&quot;New dims&quot;);
    New dims Double D [3,2]
    [
     [3 3 3]
     [4 4 4]
    ]</code></pre>

<p>Using this trick we have a our broadcasted multiplication do what we want. And now the extra dimensions <b>match</b>(!):</p>

<pre><code>    $result = $c * $d-&gt;dummy(0,$c-&gt;getdim(0));
    print $result;</code></pre>

<p>Using our symbolic way of writing down the slices that are paired in a elementary operation we can see that we achieve what we wanted</p>

<pre><code>    $c $d-&gt;dummy(0,$c-&gt;getdim(0)) $result
    &quot;($i),(j)&quot; &quot;($i),($j)&quot; &quot;($i),($j)&quot;</code></pre>

<p>But hang on, we want to verify (somewhat formally) that the right subslices of the original <code>$d</code> are used in each elementary operation. That is easily achieved by noting that the slice <code>($i),($j)</code> of the dummied <code>$d</code> is equivalent to the subslice <code>($j)</code> of the original 1D ndarray <code>$d</code> . So we finally arrive at</p>

<pre><code>    $c $d $result
    &quot;($i),(j)&quot; &quot;($j)&quot; &quot;($i),($j)&quot;</code></pre>

<p>While this kind of analysis seems probably not justified when dealing with such a simple example it comes in very handy when looking at more complex broadcasted code.</p>

<p>But before we try our understanding on such an example we look once again at the way extra dims have to match in a broadcast loop. In the previous example, we had to find out about the size of <code>$c</code>&#39;s first dimension (using <code>getdim(0)</code>) to make a dummy dimension that would fit <code>$c</code>&#39;s extradims in the broadcasted multiplication. Since similar situations occur very often when writing broadcasted PDL code the matching rules for extra dimensions allow a dimension size of 1 to match any other dimension size: it is the <b>elastic</b> dimension size in a sense that it grows in a broadcast loop as required. As in the broadcast loop the corresponding extra dimension is marched through all its positions (e.g. <code>slice(&quot;:,($i)&quot;) $i=0..n-1</code>) the elastic dimension just uses its one and only position 0 repeatedly ( <code>slice(&quot;:,(0)&quot;) $i=0..n-1</code>). Therefore, an equivalent and more concise way to write the broadcasted multiplications makes use of this and the fact that a dummy dimension of size 1 is created by default if the second argument is omitted (see <code>help dummy</code>)</p>

<pre><code>    print $c-&gt;pdim(&#39;c&#39;) * $d-&gt;dummy(0)-&gt;pdim(&#39;dd&#39;);
    $A [l,m] $B [n,l] $AB [n,m]
    $AB = inner $A-&gt;dummy(1), $B-&gt;xchg(0,1)
    $A-&gt;dummy(1) $B-&gt;xchg(0,1) $AB
    (l)[1,m] (l)[n] ()[n,m]
    &quot;:,(0),($j)&quot; &quot;:,($i)&quot; &quot;($i)($j)&quot;</code></pre>

<p>Going back to the original ndarrays <code>$A</code> and <code>$B</code> we see that the slice expressions change to</p>

<pre><code>    $A $B $AB
    &quot;:,($j)&quot; &quot;($i),:&quot; &quot;($i),($j)&quot;</code></pre>

<p>and that means</p>

<pre><code>    $AB(($i),($j)) = inner $A(:,($j)), $B(($i),:) $i=0..n-1, $j=0..m-1</code></pre>

<p>and that is exactly the definition of the matrix product as we explained above! Our bit of formalism has sort of &quot;proved&quot; it. You see that the slice and dimension matching formalism we developed can really be helpful when you try to verify that your complicated broadcasting expression does what you want it to do. However, as you get more experience with broadcasting we strongly suspect that you don&#39;t need this any more; you will rather develop a much better &quot;feeling&quot; how to write down the right combination of dimension manipulations to achieve the desired result in a broadcast loop.</p>

<h1 id="Writing-your-own-functions-into-PDL">Writing your own functions into PDL</h1>

<h2 id="Using-PDL-Functions">Using PDL Functions</h2>

<p>PDL shares the Perl method for building functions for code that perform a commonly repeated function - you can define a function with <code>sub</code>, a function name, and a pair of curly braces.</p>

<p>Here&#39;s a simple function in a PDL script:</p>

<pre><code>    #!/usr/bin/perl
    use PDL;
    $a = sequence(10);
    $b = $a * 4;

    $result = my_sums($a, $b);
    print $result;

    print my_sums(pdl(10,20,30), pdl(3,4,5) );

    sub my_sums {
        my ($a1, $a2) = @_; # pdls passed in the perl array @_
        my $c = $a1 + $a2;
        my $difference = $a1 - $a2;
        return($c, $difference);
    }</code></pre>

<p>As you can see, the function is called <code>my_sums</code> and it is defined at the end of this script, but you can be define functions anywhere in the script. In the example above, we call <code>my_sums</code> twice, printing out the answers as we go.</p>

<p>You can return as many PDLs from the function as you want, by passing them out in a comma separated list.</p>

<p>You can define the functions in any part of your Perl script, even after the point in the program that you started using the function. The input variables to the function are passed through the <code>@_</code> array, and we can put any set of ndarrays into the function. The function also has local scope, so variables inside the routine are not seen by anything calling that function. Remember, though, that the variables <i>outside</i> the function <b>can</b> be seen inside the function! It&#39;s good practice to have a <code>use strict;</code> inside your functions whilst writing them, though, as this will help catch bugs.</p>

<h2 id="Moving-Functions-into-Separate-Files">Moving Functions into Separate Files</h2>

<p>It gets tiring to copy and paste your useful functions from script to script, and so PDL provides a way to have your functions stored in a file that can be read by many scripts.</p>

<p>Two important notes:</p>

<ul>

<li><p>The filename has <code>.pdl</code> at its end, not <code>.pl</code></p>

</li>
<li><p>The file has <code>1;</code> as the last line outside the curly braces of the statement.</p>

</li>
</ul>

<p>Use a file editor and cut and paste the text below into a file with the name <code>my_sums.pdl</code>.</p>

<pre><code>    sub my_sums {
        ($a1, $a2) = @_;
        my $c = $a1 + $a2;
        my $difference = $a1 - $a2;
        return($c, $difference);
    }
    1;</code></pre>

<p>Now create a separate script in the same directory:</p>

<pre><code>    #!/usr/bin/perl
    use PDL;
    use PDL::AutoLoader;
    $a = sequence(10);
    $b = $a * 4;
    $result = my_sums($a, $b);
    print $result;
    print my_sums(pdl(10,20,30), pdl(3,4,5) );</code></pre>

<p>Running this Perl script will include PDL, and PDL will automatically look for a file called <code>my_sums.pdl</code> (remember the extension has to have <code>.pdl</code>) and use it.</p>

<h2 id="Getting-PDL-to-look-for-your-functions-in-other-places">Getting PDL to look for your functions in other places</h2>

<p>After a while, you will have many PDL functions scattered over many directories, and so it makes sense to collect all your functions into a separate directory and have PDL look for them there.</p>

<p>You can set an environment variable in your shell called <code>PDLLIB</code> to look within a given directory. One convention is to use <code>PDLLIB=${HOME}/lib/pdl+</code> to store all your functions. When defined in your system shell, this will inform PDL where you&#39;ve put your commonly used functions. The directory path is specified to your PDL library directory. The <code>+</code> sign at the end of the path tells PDL to also look in all the subdirectories below the PDLLIB directory.</p>

<h2 id="Documenting-your-Functions">Documenting your Functions</h2>

<p>Just like any other Perl script, you can add Plain Old Documentation (POD) inside your PDL functions.</p>

<p>For a detailed look at what you can have in a POD, look at <a>perlpod</a> with <code>perldoc perlpod</code> or look online for a tutorial.</p>

<p>At the bare minimum, the POD should say what the PDL function does, what are its inputs and outputs. Further detail may include one or two examples so that a new user can test it and check they understand what the function behaves, look at <a>perlpod</a> with <code>perldoc perlpod</code> or look online for a tutorial.</p>

<h1 id="Graphics-with-PGPLOT">Graphics with PGPLOT</h1>

<p>A central requirement of any data analysis package is the possibility of visualization of data. PDL deals with this in a slightly different manner than some other packages in that no built-in graphics library is used, instead it uses other freely available external packages. In this chapter we will focus on the main 2D plotting package, PGPLOT.</p>

<p>Here we will cover the use of the <code>PDL::Graphics::PGPLOT</code> package which uses the freely available PGPLOT subroutine package written by Tim Pearson. This is a very powerful package and <code>PDL::Graphics::PGPLOT</code> does not provide easy access to everything in the PGPLOT package, although it hopefully does most of what you will need.</p>

<p>For advanced use you might have to use some PGPLOT commands directly, see <a href="#Using-PGPLOT-commands-directly">&quot;Using PGPLOT commands directly&quot;</a> for a discussion of this. But even if you don&#39;t you are recommended to at least keep a copy of the PGPLOT documentation lying around. It is available from <a href="http://www.astro.caltech.edu/~tjp/pgplot/">http://www.astro.caltech.edu/~tjp/pgplot/</a>.</p>

<p>The goals of this section is to familiarize the reader with the PDL interface to PGPLOT and show how complicated datasets can be easily manipulated and displayed. The focus will be on interactive use to facilitate learning, but at the end we will turn to an object-oriented interface that might be more suited for scripts.</p>

<p>To use <code>PDL::Graphics::PGPLOT</code> it is necessary to have the PGPLOT package installed, and in addition have the Perl PGPLOT module (written by Karl Glazebrook and available through CPAN) installed and working. In the following we will assume that you have this all set up.</p>

<h2 id="Introducing-PDL::Graphics::PGPLOT">Introducing <code>PDL::Graphics::PGPLOT</code></h2>

<p>2-dimensional graphics in PDL is normally performed by the <code>PDL::Graphics::PGPLOT</code> module. The <code>PDL::Graphics::PGPLOT</code> package must be <code>use</code>&#39;ed to give access to the commands. This introduction will be based on interactivity and use of <code>perldl</code></p>

<pre><code>    pdl&gt; use PDL::Graphics::PGPLOT;</code></pre>

<p>That is what you need to get running. We will now play around with a couple of commands before we turn to a systematic overview in the next two sections. We will concentrate on the <code>line</code> and <code>points</code> commands which draws continuous lines and individual plotting symbols respectively. The final result should look similar to Figure 1.</p>

<p> <img width="400" alt="" src="content/book/PGPLOTFigs/ex_linepoint.8.png"/></p>

<p> <img width="400" alt="" src="content/book/PGPLOTFigs/ex_errorbars.8.png"/></p>

<p>The first step is to start <code>perldl</code> and use the <code>PDL::Graphics::PGPLOT</code> package (some output is suppressed)</p>

<pre><code>    &gt; perldl
    Type &#39;help&#39; for online help
    Type &#39;demo&#39; for online demos
    Loaded PDL v2.4.3
    pdl&gt; use PDL::Graphics::PGPLOT </code></pre>

<p>Now we need to open a graphics device - there are quite a few that are supported by PGPLOT, here we will use a normal plot window that can be re-used:</p>

<pre><code>    pdl&gt; dev(&#39;/xs&#39;)</code></pre>

<p>You should now have a large plot window on your screen, if you had some problems try to do <code>dev(&#39;?&#39;)</code> which will give you a list of available devices and allow you to choose one.</p>

<p>We first need to define a variable to have something to plot. The first plan is to simply plot a parabola and a Gaussian (bell) function as in the left panel in Figure 1, so we need an x-variable that is both positive and negative.</p>

<pre><code>    pdl&gt; $x=zeroes(100)-&gt;xlinvals(-5, 5)</code></pre>

<p>This creates a 100 element ndarray starting at -5 and ending at 5. We can then very easily draw a parabola:</p>

<pre><code>    pdl&gt; line $x, $x*$x/12.5, {LINESTYLE=&gt;&#39;Dashed&#39;, Colour=&gt;red}</code></pre>

<p>which should draw a nice parabola with a dashed red line. As should be clear the <code>line</code> command draws a line and takes the x and y coordinates of the points on the line as arguments and options to the command are given as an anonymous hash.</p>

<p>We now want to plot a Gaussian on top of this, but if we were just to issue another plot command it would by default erase the screen, so instead we call the <code>hold</code> function to stop that from happening:</p>

<pre><code>    pdl&gt; hold</code></pre>

<p>We can then continue plotting, now using symbols instead of a line:</p>

<pre><code>    pdl&gt; points $x, exp(-$x*$x/2), {Symbol =&gt; &#39;Plus&#39;};</code></pre>

<p>Again, note that the function <code>points</code> function plots symbols instead of lines. PGPLOT has a large array of symbols, normally accessed using numbers, but the most common have text aliases defined.</p>

<p>The only thing left for us now is to ensure that the next plot will start afresh. Since we issued the <code>hold</code> command all subsequent plots will overplot the existing ones and since we do not want that anymore, we therefore have to <code>release</code> the device to the next set of plot commands:</p>

<pre><code>    pdl&gt; release;</code></pre>

<p>As a second example we will show how you can create plots with error bars. We will just carry on so the previous plot will be erased (enjoy it while you can). We first have to define some variables for the plot, so we need the <i>x</i> and <i>y</i> variables and the error on <i>y</i>.</p>

<pre><code>    pdl&gt; $x = pdl(0.88, 0.223, 0.815, 0.606, 0.188, 0.360)
    pdl&gt; $y = pdl(24.52, 22.24, 25.43, 23.54, 22.63, 23.59)
    pdl&gt; $dy = pdl(0.57, 0.07, 0.84, 0.27, 0.12, 0.28)</code></pre>

<p>In the previous example we let PGPLOT decide on the plotting ranges we were going to use, but now we want some more control over it. To do so we set it up using the <code>env</code> command:</p>

<pre><code>    pdl&gt; env(0, 1, 22, 26)</code></pre>

<p>which sets the X-axis to go from 0 to 1 and the Y-axis from 22 to 26.</p>

<p>That is really all that is needed before plotting the error bars:</p>

<pre><code>    pdl&gt; errb $x, $v, $dv,  {Symbol =&gt; &#39;Square&#39;};</code></pre>

<p>And here we go! It almost looks like science. Of course in real life error-bars might not be symmetric (although you often wish they were), and we will explain how to do this later when we discuss <code>errb</code> in more detail below.</p>

<h2 id="An-overview-of-2D-plotting-commands">An overview of 2D plotting commands</h2>

<p>Before we proceed to an overview of all commands in <code>PDL::Graphics::PGPLOT</code> it is necessary to define a couple of terms: The first is the concept of <b>device</b> - this is what the plotting commands work on, often this will be a <i>screen</i> device which shows resulting output on the screen in a window, but it can also be output to a file in some sort of format. Then inside each device there is a <i>plotting area</i> within which plotting commands gives a noticeable result.</p>

<p>Another important concept is <i>holding</i> of plots. When a plot is held, any subsequent plot commands will plot on top of the existing plot. To explicitly hold a plot you issue the command <code>hold</code> and to release it again you use <code>release</code>.</p>

<p>Finally most commands described in the following take a set of <b>options</b>. These are values that can be set to modify the default behavior of the plotting routine and are very useful so we will first discuss the standard options and how options are specified.</p>

<h2 id="Options-in-plot-commands">Options in plot commands</h2>

<p>As mentioned above and seen in the brief introduction to the PGPLOT interface earlier, we use options to modify the behavior of plot commands. Below we will often see examples of <b>specific</b> options, those that are only recognized by a particular plot command. However in addition there are <b>general</b> options that are recognized by many or all plot commands. These are normally the options you use most so it is important to know these.</p>

<p>But first, how do you specify an option? If you read through the walk-through above you have probably already realized that they are set as keys in a hash:</p>

<pre><code>    line x, y {Colour =&gt; 3}</code></pre>

<p>However due to the way they are implemented in the code (using the <code>PDL::Options</code> package) the hash is more flexible than normal Perl hashes. Firstly the options are case-insensitive and secondly some have synonyms defined so that for instance <code>Color</code> and <code>Colour</code> are both accepted to avoid bad feelings on one side of the Atlantic. Finally most, if not all, options can be shortened so that <code>Lines</code> will be interpreted as <code>LineStyle</code>. This is mostly useful when working on the <code>perldl</code> command line however as it is error-prone in scripts (imagine that someone later implemented a <code>Lines</code> option which did something totally different, like draw 10 parallel lines, yeah, quite likely).</p>

<p>The following listing of standard options is based on the on-line documentation which you can access yourself inside <code>perldl</code> as</p>

<pre><code>    pdl&gt; help PDL::Graphics::PGPLOT::Window</code></pre>

<p>or using the <code>pdldoc</code> command</p>

<pre><code>    bash$ pdldoc PDL::Graphics::PGPLOT::Window</code></pre>

<p>It is not envisaged that the standard option set will be significantly expanded from that listed here, but the on-line documentation should reflect any changes if they take place.</p>

<dl>

<dt id="Arrow"><code>Arrow</code></dt>
<dd>

<p>This option allows you to set the arrow shape, and optionally size for arrows for the <code>vect</code> routine. The arrow shape is specified as a hash with the key <code>FS</code> to set fill style,</p>

</dd>
<dt id="Angle"><code>Angle</code></dt>
<dd>

<p>sets the opening angle of the arrow head, <code>Vent</code> to set how much of the arrow head is cut out and <code>Size</code> to set the arrowsize.</p>

<p>The following code:</p>

<pre><code>    pdl&gt; $opt = {Arrow =&gt; {FS=&gt;1, Angle=&gt;60, Vent=&gt;0.3, Size=&gt;5}};</code></pre>

<p>will set up an options hash for a broad arrow of five times the normal size.</p>

<p>Alternatively the arrow can be specified as a set of numbers corresponding to an extension to the syntax for the PGPLOT command <code>pgsah</code> . The equivalent to the above is</p>

<pre><code>    pdl&gt; $opt = {Arrow =&gt; pdl([1, 60, 0.3, 5])};</code></pre>

<p>For the latter the arguments must be in the given order, and if any are not given the default values of 1, 45, 0.3 and 1.0 respectively will be used.</p>

</dd>
<dt id="Arrowsize"><code>Arrowsize</code></dt>
<dd>

<p>The arrowsize can be specified separately using this option to the options hash. It is useful if an arrowstyle has been set up and one wants to plot the same arrow with several sizes. Please note that it is <b>not</b> possible to set arrowsize and character size in the same call to a plotting function. This should not be a problem in most cases.</p>

<pre><code>    pdl&gt; $opt = {ARROWSIZE =&gt; 2.5};</code></pre>

</dd>
<dt id="Axis"><code>Axis</code></dt>
<dd>

<p>Set the axis type (see the <code>env</code> command below in <a href="#Setting-up-the-plot-area">&quot;Setting up the plot area&quot;</a>). It can either be specified as a number, or by a name as in the following table</p>

<pre><code>    Name        Number  Explanation
    ----        ------  -----------

    Empty       -2      draw no box, axes or labels
    Box         -1      draw box only
    Normal       0      draw box and label it with coordinates
    Axes         1      same as Normal, but also draw X=0, Y=0 axes
    Grid         2      same as Axes, but also draw grid lines
    LogX        10      draw box and label X-axis logarithmically
    LogY        20      draw box and label Y-axis logarithmically
    LogXY       30      draw box and label both axes logarithmically</code></pre>

<p>The reason why this command is accepted by most commands is that when a command is called before a plot area is set up it will implicitly call <code>env</code> which interprets this option.</p>

</dd>
<dt id="AxisColour"><code>AxisColour</code></dt>
<dd>

<p>Set the axis colour using the same syntax as for the <code>Colour</code> option below.</p>

</dd>
<dt id="Border"><code>Border</code></dt>
<dd>

<p>Normally the plot limits are chosen so that the plotted points just fit inside the plot area; with this option you can increase (or decrease) the limits by either a relative (i.e. a fraction of the original axis width) or an absolute amount. Either specify a hash array, where the keys are <code>Type</code> (set to &#39;<code>Relative</code> &#39; or &#39;<code>Absolute</code> &#39;) and <code>Value</code> (the amount to change the limits by), or set to 1, which is equivalent to <code>Border =&gt; { Type =&gt; &#39;Rel&#39;, Value =&gt; 0.05}</code>.</p>

</dd>
<dt id="Charsize"><code>Charsize</code></dt>
<dd>

<p>Set the character/symbol size as a multiple of the standard size. <code>$opt = {Charsize =&gt; 1.5}</code></p>

</dd>
<dt id="Colour"><code>Colour</code></dt>
<dd>

<p>Set the colour to be used for the subsequent plotting - it has <code>Color</code> as a synonym. This can be specified as a number, and the most used colours can also be specified with name, according to the following table:</p>

<pre><code>    0   White       4   Blue        8   Orange
    1   Black       5   Cyan        14  Dark  gray
    2   Red         6   Magenta     16  Light Gray
    3   Green       7   Yellow</code></pre>

<p>However there is a much more flexible mechanism to deal with colour. The colour can be set as a 3 or 4 element anonymous array (or ndarray) which gives the RGB colours. If the array has four elements the first element is taken to be the colour index to change. For normal work you might want to simply use a 3 element array with R, G and B values and let the package deal with the details. The R,G and B values go from 0 to 1.</p>

<p>In addition the package will also try to interpret non-recognized colour names using the default X11 lookup table, normally using the <code>rgb.txt</code> that came with PGPLOT.</p>

<p>For more details on the handling of colour it is best that the user consults the PGPLOT documentation. Further details on the handling of colour can be found in the documentation for the internal routine <code>_set_colour</code>.</p>

</dd>
<dt id="Filltype"><code>Filltype</code></dt>
<dd>

<p>Set the fill type to be used by <code>poly</code>, <code>circle</code>, <code>ellipse</code> and <code>rectangle</code>. The fill can either be specified using numbers or name, according to the following table, where the recognized name is shown in capitals-it is case-insensitive, but the whole name must be specified.</p>

<pre><code>    1   Solid
    2   Outline
    3   Hatched
    4   CrossHatched</code></pre>

<p><code>$opt = {Filltype =&gt; &#39;Solid&#39;}</code> (see below for an example of hatched fill)</p>

</dd>
<dt id="Font"><code>Font</code></dt>
<dd>

<p>Set the character font. This can either be specified as a number following the PGPLOT numbering or name as follows (name in capitals):</p>

<pre><code>    1   Normal
    2   Roman
    3   Italic
    4   Script</code></pre>

<p>Note that in a string, the font can be changed using the escape sequences <code>\fn</code> , <code>\fr</code> , <code>\fi</code> and <code>\fs</code> respectively. See the documentation in <a href="#Text-and-legends">&quot;Text and legends&quot;</a> for more information regarding escape sequences.</p>

<p><code>$opt = {Font =&gt; &#39;Roman&#39;};</code> gives the same result as <code>$opt = { Font=&gt; 2 };</code></p>

</dd>
<dt id="Hatching"><code>Hatching</code></dt>
<dd>

<p>Set the hatching to be used if either filltype 3 or 4 is selected (see above). The specification is similar to the one for specifying arrows. The arguments for the hatching is either given using a hash with the key <code>Angle</code> to set the angle that the hatch lines will make with the horizontal, <code>Separation</code> to set the spacing of the hatch lines in units of 1% of <code>min(height,width)</code> of the view surface, and <code>Phase</code> to set the offset the hatching. Alternatively this can be specified as a 1x3 ndarray <code>$hatch=pdl[$angle, $sep, $phase]</code>.</p>

<pre><code>    $opt = {Filltype =&gt; &#39;Hatched&#39;, Hatching =&gt; {Angle=&gt;30, Separation=&gt;4}};</code></pre>

<p>Can also be specified as</p>

<pre><code>    $opt = {Fill=&gt; &#39;Hatched&#39;, Hatch =&gt; pdl [30,4,0.0]};</code></pre>

<p>For another example of hatching, see the command <code>poly</code> in <a href="#Drawing-lines-and-plotting-points">&quot;Drawing lines and plotting points&quot;</a> below.</p>

</dd>
<dt id="Justify"><code>Justify</code></dt>
<dd>

<p>A boolean value which, if true, causes both axes to drawn to the same scale. If you want more information about this option you are advised to consult the PGPLOT documentation for the <code>pgenv</code> command.</p>

</dd>
<dt id="Linestyle"><code>Linestyle</code></dt>
<dd>

<p>Set the line style. This can either be specified as a number following the PGPLOT numbering or as a name as shown in the following table.</p>

<pre><code>    1   Solid
    2   Dashed
    3   Dot-dash
    4   Dotted
    5   Dash-dot-dot</code></pre>

<p>Thus the following two specifications both specify the line to be dotted:</p>

<pre><code>    $opt = {Linestyle =&gt; 4};
    $varopt = {Linestyle =&gt; &#39;Dotted&#39;};</code></pre>

<p>The names are not case sensitive, but the full name is required.</p>

</dd>
<dt id="Linewidth"><code>Linewidth</code></dt>
<dd>

<p>Set the line width. It is specified as a integer multiple of 0.13 mm.</p>

<pre><code>    $opt = {Linewidth =&gt; 10}; # A rather fat line</code></pre>

</dd>
<dt id="PlotPosition"><code>PlotPosition</code></dt>
<dd>

<p>The position of the plot on the page relative to the view surface in normalized coordinates as an anonymous array. The array should contain the lower and upper X-limits and then the lower and upper Y-limits. To place two plots above each other with no space between them you could do</p>

<pre><code>    $win-&gt;env(0, 1, 0, 1, {PlotPosition =&gt; [0.1, 0.5, 0.1, 0.5]});
    $win-&gt;env(5, 9, 0, 8, {PlotPosition =&gt; [0.1, 0.5, 0.5, 0.9]});</code></pre>

</dd>
<dt id="Symbol"><code>Symbol</code></dt>
<dd>

<p>The plot symbol to use, with the default being 17 which gives a small filled circle. This is an option for <code>points</code> and <code>errb</code> at the moment, but could be used for others too. It is either given an ndarray with the same number of elements as the plot variable, a name (or number) specifying the symbol to use according to the following (recognized name in capital letters):</p>

<pre><code>    0   Square      4   Circle      9   Sun
    1   Dot         5   Cross       11  Diamond
    2   Plus        7   Triangle    12  Star
    3   Asterisk    8   Earth       17  Default</code></pre>

<p>PGPLOT has support for a much larger number of symbols. The reader is advised to consult the PGPLOT documentation for further information or write a short program that loops through all symbols. Note however that there are a <b>lot</b>. For instance symbol 2830 is a Cyrillic character - the system used is the Hershey system for symbols. In addition you can draw regular polygons with <i>n</i>-sides by setting the symbol to <i>-n</i>, so that <code>$opt = {Symbol =&gt; -n };</code> but be aware that <i>-1</i> and <i>-2</i> draws a dot with the diameter set to the current linewidth.</p>

</dd>
<dt id="Title"><code>Title</code></dt>
<dd>

<p>The title on top of the plot box.</p>

</dd>
<dt id="XTitle"><code>XTitle</code></dt>
<dd>

<p>The title for the X-axis of the plot.</p>

</dd>
<dt id="YTitle"><code>YTitle</code></dt>
<dd>

<p>The title along the Y-axis.</p>

</dd>
</dl>

<h2 id="Hard-copies-and-plot-options">Hard-copies and plot options</h2>

<p>The default options for screen display are not ideal for hard-copies (typically PostScript). Thus there is a separate set of options for certain properties when the output device is a hard-copy one. Here we will quickly summarize these</p>

<dl>

<dt id="HardLW"><code>HardLW</code></dt>
<dd>

<p>The line width used on hard-copy devices. The default is 4.</p>

</dd>
<dt id="HardCH"><code>HardCH</code></dt>
<dd>

<p>The character size used on hard-copy devices. The default is 1.4.</p>

</dd>
<dt id="HardFont"><code>HardFont</code></dt>
<dd>

<p>The default font used on hard-copy devices. It defaults to 2.</p>

</dd>
<dt id="HardAxisColour"><code>HardAxisColour</code></dt>
<dd>

<p>The default colour to draw the axis with on a hard-copy device. This is particularly important since light green (default screen colour) is not very visible on paper. The default is 1 (black). The setting of colours work as with <code>Colour</code></p>

</dd>
<dt id="HardColour"><code>HardColour</code></dt>
<dd>

<p>The default plot colour on hard-copy devices, it defaults to 1 (black).</p>

<p>These options should be set either in the call to <code>dev</code> (see <a href="#Setting-up-the-plot-area">&quot;Setting up the plot area&quot;</a>) or redefined using the method outlined in the next section.</p>

</dd>
</dl>

<h3 id="Setting-default-values-for-options">Setting default values for options</h3>

<p>You might not be happy with the default settings for the various options and want to set a different value permanently instead of specifying it with every call to <code>dev</code> , <code>env</code> or some other command. There is some support for this, but it is limited in that it is not case-insensitive nor does it have synonyms (except for colour/color) so the options <b>must</b> be written as above. (You will be notified if you did something wrong).</p>

<p>That said it is fairly easy to use. You would normally set this in your <code>.perldlrc</code> file (see &#39; <code>help perldl</code> &#39; in the perldl shell or &#39; <code>pdldoc perldl</code> &#39;). The relevant function is <code>set_pgplot_options</code> which takes a hash as argument with the options and their values, as in the following example:</p>

<pre><code>    use PDL::Graphics::PGPLOTOptions (&#39;setpgplotoptions&#39;);
    setpgplotoptions(&#39;Device&#39; =&gt; &#39;/xs&#39;, &#39;LineWidth&#39; =&gt; 10);</code></pre>

<p>Note that some settings might affect more than you like. In particular the <code>LineWidth</code> and <code>LineStyle</code> options will also affect the axis and axis labels drawn. However, character size, device default plot symbol, border and other options can be conveniently be specified in this way.</p>

<h3 id="Setting-up-the-plot-area">Setting up the plot area</h3>

<p>The first step for the budding plot maker is to set up the drawing area. This involves selecting what device you want to create the plots on and then setting the region you want to plot in .</p>

<p>The destination for your plot commands is set with the <code>dev</code> command, and with different arguments to <code>dev</code> you can send plots to various output devices such as:</p>

<p>GIF files - <code>dev(&#39;giffile.gif/gif&#39;)</code></p>

<p>Postscript files - <code>dev(&#39;filename.ps/ps&#39;)</code></p>

<p>Colour Postscript files - <code>dev(&#39;filename.ps/cps&#39;)</code></p>

<p>X-windows plotting windows - <code>dev(&#39;/xs&#39;)</code></p>

<p>If you wish to have several plotting panels per page you can specify the number in the x and y directions as further arguments to <code>dev</code> so that to get four panels you would write <code>dev(&#39;/xs&#39;, 2, 2)</code>.</p>

<p>For more detailed control over the created device, you can specify various options. The main four options you might use are:</p>

<dl>

<dt id="Aspect"><code>Aspect</code></dt>
<dd>

<p>The aspect ratio of a newly created output device. If your device is a graphics window under a window system, this might or might not be applied when the window is created, but it should be updated as soon as you plot to it. The default value is 0.618, i.e. the golden ratio.</p>

</dd>
<dt id="WindowWidth"><code>WindowWidth</code></dt>
<dd>

<p>The width of the created output window. The width is specified in units of inches, which is reasonably easy to deal with when printing out, but if your device is a graphics window it is all a bit more unclear since different setups might have different ideas of what an inch corresponds to in pixels.</p>

</dd>
<dt id="WindowXSize"><code>WindowXSize</code></dt>
<dd>

<p>The X-size of the plot window, specified as <code>WindowWidth</code> and combined with <code>Aspect</code> if <code>WindowYSize</code> is not set.</p>

</dd>
<dt id="WindowYSize"><code>WindowYSize</code></dt>
<dd>

<p>As above but for the Y-size.</p>

</dd>
<dt id="NX-and-NY"><code>NX</code> and <code>NY</code></dt>
<dd>

<p>These two options set the number of panels in the X and Y direction respectively and are alternatives to specifying the numbers of panels directly in the call to <code>dev</code> as <code>dev(&lt;device&gt;, &lt;nx&gt;, &lt;ny&gt;)</code>.</p>

<p>The options are specified in an anonymous hash so that:</p>

<pre><code>    pdl&gt; dev(&#39;/xs&#39;, {NX =&gt; 4, NY =&gt; 2})</code></pre>

<p>will create a plot window with four panels in the X-direction and 2 in the Y-direction, with a default aspect ration and size. Alternatively the same window could have a specified width and aspect ratio by specifying those options as</p>

<pre><code>    pdl&gt; dev(&#39;/xs&#39;, {NX =&gt; 4, NY =&gt; 2, Aspect =&gt; 1, WindowWidth =&gt; 5})</code></pre>

<p>However dev does not actually draw anything for you, it merely selects the output device. To set up a plot you either call a plot command directly, or if you want more control over the axis ranges you use the command <code>env</code>. This useful command takes the upper and lower limits in X and Y as input:</p>

<pre><code>    env(0, 1, 0, 1);</code></pre>

<p> <img width="400" alt="" src="content/book/PGPLOTFigs/ex_env1.8.png"/></p>

<p>sets up a plotting area with both axes going from 0 to 1. If a logarithmic axis is desired this can be achieved by passing an option to the env command, we can also use this to set the axis labels:</p>

<pre><code>    env(1, 1000, 0, 1, {Axis =&gt; &#39;LOGX&#39;, Xtitle =&gt; &#39;X-axis&#39;, Ytitle =&gt; &#39;Y-axis&#39;});</code></pre>

<p> <img width="400" alt="" src="content/book/PGPLOTFigs/ex_env2.8.png"/></p>

<p>Further information on the <code>Axis</code> option can be found in <a href="#Options-in-plot-commands">&quot;Options in plot commands&quot;</a>.</p>

<p>It is important to realize that when you call <code>env</code> explicitly it automatically holds the plot for you, so subsequent plot commands will plot on top of the plotting area, and if you want to make a new plot you need either to call <code>env</code> again or call <code>release</code> explicitly.</p>

</dd>
</dl>

<h2 id="Drawing-lines-and-plotting-points">Drawing lines and plotting points</h2>

<p>The most important commands in the graphics package are probably the line drawing and point plotting commands <code>line</code> and <code>points</code> . The most basic command is <code>points</code> which plots particular symbols at given x and y values:</p>

<p> <img width="400" alt="" src="content/book/PGPLOTFigs/ex_points.8.png"/></p>

<pre><code>    pdl&gt; $x = sequence(10)
    pdl&gt; $y = $x*$x + 1
    pdl&gt; points $x, $y</code></pre>

<p>The action of the <code>points</code> command can be modified by adding options. The most important is <code>Symbol</code> which changes the plot symbol and <code>Charsize</code> which changes the size of plot symbols; in addition the <code>Plotline</code> option is a toggle which if set causes a line to be drawn through the plots:</p>

<pre><code>    pdl&gt; points $x, $y, {Symbol =&gt; &#39;Triangle&#39;, Plotline =&gt; 1, Charsize =&gt; 5}</code></pre>

<p> <img width="400" alt="" src="content/book/PGPLOTFigs/ex_points2.8.png"/></p>

<p>The string <code>Triangle</code> is equivalent to symbol number 7 and in general symbols will have to be accessed using the numerical system, but there are textual equivalents for many commonly used symbols (see <a href="#Options-in-plot-commands">&quot;Options in plot commands&quot;</a>). The <code>points</code> command does also accept an ndarray as the symbol value, in which case it should have the same length as <code>$x</code> and <code>$y</code> and each point will be plotted with the corresponding symbol value.</p>

<h2 id="Plotting-error-bars">Plotting error-bars</h2>

<p>Closely related to <code>points</code> is the routine for plotting symbols with error-bars, <code>errb</code> . This can be called in a variety of ways to allow for various ways of giving errorbars and whether horizontal or vertical errorbars are required. A typical call is:</p>

<pre><code>    pdl&gt; env(0, 5, -2, 30) 
    pdl&gt; $x=sequence(10)/2.0; $y=$x*$x 
    pdl&gt; $dy = sqrt($x+1); 
    pdl&gt; errb $x, $y, $dy, { Symbol =&gt; &#39;Square&#39; }</code></pre>

<p> <img width="400" alt="" src="content/book/PGPLOTFigs/ex_errb.8.png"/></p>

<p>which plots squares with symmetrical vertical error-bars. To get error bars in the horizontal direction one gives these before the y-errors. Likewise it is possible to get asymmetric error-bars by giving the upper and lower limits of the error bars separately for the X and Y variables as in the following example:</p>

<pre><code>    pdl&gt; $x2 = pdl(1.5, 2.3, 4.7) 
    pdl&gt; $y2 = pdl(10, 22, 0) 
    pdl&gt; $dx = $x2-&gt;zeroes(); # No X-errors 
    pdl&gt; $yu= pdl(12,29,1)-$y2 
    pdl&gt; $yl= $y2 - pdl(7, 20, -2) 
    pdl&gt; errb $x2, $y2, $dx, $dx, $yl, $yu, {Symbol =&gt; &#39;Triangle&#39;}</code></pre>

<p> <img width="400" alt="" src="content/book/PGPLOTFigs/ex_errb2.8.png"/></p>

<h2 id="Drawing-lines">Drawing lines</h2>

<p>We saw above that we could draw lines between points by setting the <code>PlotLine</code> option to <code>points</code>, however there are much better ways to draw lines. The basic line-drawing command is <code>line</code> which draws a straight line between each point.</p>

<pre><code>    pdl&gt; $x = zeroes(10)-&gt;xlinvals(-3, 3)
    pdl&gt; line $x, sin($x)</code></pre>

<p> <img width="400" alt="" src="content/book/PGPLOTFigs/ex_line1.8.png"/></p>

<p>The style, width and colour of the line can be changed with the options <code>Style</code>, <code>LineWidth</code> and <code>Colour</code> / <code>Color</code> respectively as outlined in <a href="#Options-in-plot-commands">&quot;Options in plot commands&quot;</a>.</p>

<h2 id="Plotting-histograms">Plotting histograms</h2>

<p>A very similar command is <code>bin</code> which is useful for plotting histograms. This command draws horizontal lines between <i>x(i)</i> and <i>x(i+1)</i> with the value <i>y(i)</i>.</p>

<pre><code>    pdl&gt; $x = zeroes(10)-&gt;xlinvals(-3, 3) 
    pdl&gt; bin $x, sin($x)</code></pre>

<p> <img width="400" alt="" src="content/book/PGPLOTFigs/ex_bin.8.png"/></p>

<p>By default the routine assumes that the X-values are the start points of the bin, if instead your values are for the centers of the bins, you need to set the option <code>Centre</code>/<code>Center</code> to a true value. In addition the appearance of the lines can be modified using the same options as for the <code>line</code> command.</p>

<h2 id="Drawing-polygons">Drawing polygons</h2>

<p>Finally the <code>poly</code> command is like <code>line</code> but fills the polygon defined by <code>$x</code> and <code>$y</code> with the chosen fillstyle (defaults to solid fill). If you display this you should consider putting <code>FillStyle =&gt; &#39;Outline&#39;</code> in your <code>.perldlrc</code> file as explained in <a href="#Setting-default-values-for-options">&quot;Setting default values for options&quot;</a>, or you can set it explicitly as in the following example:</p>

<pre><code>    pdl&gt; $x=zeroes(20)-&gt;xlinvals(-2,2);
    pdl&gt; $y=exp(-$x*$x); 
    pdl&gt; $xpoly = append($x-&gt;where($x &lt;= 0), pdl(0)); 
    pdl&gt; $ypoly = append($y-&gt;where($x &lt;= 0), pdl(0)); 
    pdl&gt; poly $xpoly, $ypoly, {FillType =&gt; &#39;Hatched&#39;};</code></pre>

<p> <img width="400" alt="" src="content/book/PGPLOTFigs/linepoly_ex.8.png"/></p>

<p>In this example it is worth noting the added complications to ensure that the polygon is closed. In addition we have used the option <code>FillType</code> to change the style of fill used. This can be finely adjusted if necessary, for further examples see <a>PDL::Graphics::PGPLOT</a> and the discussion of <code>FillType</code> in <a href="#Options-in-plot-commands">&quot;Options in plot commands&quot;</a>.</p>

<h2 id="Displaying-images">Displaying images</h2>

<p>PGPLOT was originally designed for astronomy and as such it has good support for the display of 2D-data. In PDL this support has been simplified and there is now only one command for image display, <code>imag</code> , which internally chooses between different PGPLOT display commands. The simplest use of <code>imag</code> is to let it act on a 2D ndarray so:</p>

<pre><code>    pdl&gt; $a = rvals(50,50, {Center =&gt; [ 25, 25]}); 
    pdl&gt; imag $a;</code></pre>

<p> <img width="400" alt="" src="content/book/PGPLOTFigs/ex_imag1.8.png"/></p>

<p>However, most likely you will find that the shape is not circularly symmetric because the aspect ratio of your graphics window is different from 1. How then can we correct this? The easiest solution is probably to make sure that your graphics device has aspect ratio 1 by giving the <code>Aspect</code> option to the <code>dev</code> command (see <a href="#Setting-up-the-plot-area">&quot;Setting up the plot area&quot;</a>).</p>

<p>That isn&#39;t always an option though, and an alternative approach is to use the option <code>Pix</code> to the <code>imag</code> command. This lets you adjust the aspect ratio of the image pixels. You can in addition specify the number of image pixels per screen unit with the option <code>Pitch</code> so that to display the previous image with square pixels and 2 image pixels per screen pixel you use:</p>

<pre><code>    pdl&gt; imag $a, { Pix =&gt; 1, Pitch =&gt; 2 }</code></pre>

<p>You can also use <code>Unit</code> to specify the unit used for scaling and <code>Scale</code> for the reciprocal of <code>Pitch</code>, see the PDL::Graphics::PGPLOT documentation for details. The <code>Pix</code> option only adjusts the coordinate ranges and this might not always be what you require. In such situations a solution might be to create a square plot window directly as mentioned earlier.</p>

<p>In addition you might want to specify a stretch of the gray-scale of the image. This can be obtained first by specifying the max and min values of the displayed image (everything above is set to the max value and everything below to the min value). This is set with the <code>Min</code> and <code>Max</code> options. Additionally it is possible to adjust the image transfer function using the option <code>ITF</code>. Allowed values are <code>Linear</code>, <code>Log</code> and <code>Sqrt</code>.</p>

<p>You can also add a colour bar (colour wedge in PGPLOT parlance) to the image display. This is accomplished either using the <code>draw_wedge</code> (see below) command directly or by setting the <code>DrawWedge</code> option to true in your call to <code>imag</code> . If you want to pass options to the <code>draw_wedge</code> command, you can do that with the <code>Wedge</code> option. See below for further details.</p>

<h2 id="Transforms">Transforms</h2>

<p>Finally a very useful feature of PGPLOT that is relevant both to images and also the contour plots (see below) is the concept of a transform matrix. This is a <i>6</i> element vector, <i>T(i)</i> which maps input pixels into display pixels so that pixel <i>i,j</i> is mapped to:</p>

<pre><code>    X(ij) = T0 + T1(i) + T2(j)
    Y(ij) = T3 + T4(i) + T5(j)</code></pre>

<p>It is always simplest to refer to this equation the first few times one sets up a transform vector.You use this whenever your pixel positions in the real world were different from that represented by your input image array.</p>

<pre><code>    use PDL;
    use PDL::Graphics::PGPLOT;
    # Create two plot areas in the X-directions dev(&#39;/xs&#39;, 2, 1);
    # Create a Gaussian around the center of the image
    $a = rvals(101, 101, {Center =&gt; [50, 50]});
    $y = exp(-$a*$a/50.);
    # Display with a linear transfer function
    imag $y;
    # This transform vector maps the extreme points to 
    my $tr = pdl(-10, 1.0/5.0, 0, -10, 0, 1.0/5.0);
    # Finally display the image with the transform and
    # a logarithmic transfer function.
    imag $y, {Transform =&gt; $tr, ITF =&gt; &#39;Log&#39;}; </code></pre>

<p> <img width="400" alt="" src="content/book/PGPLOTFigs/ex_imag2.8.png"/></p>

<p>Here we are contrasting two different ways of displaying the same image. On the left is the default display of a Gaussian, whereas on this right is the result when mapping the pixels to a range from <i>-10</i> to <i>10</i> with a logarithmic transfer function. Here we show the use of the <code>ITF</code> and and <code>Transform</code> options. Note that using <code>Transform</code> in conjunction with <code>Pix</code> is going to lead to unwanted results!</p>

<h2 id="Colour-bar-wedge">Colour bar/wedge</h2>

<p>It is often desirable to annotate an image with a colour wedge showing the range of values in the image. This is accomplished with the <code>draw_wedge</code> function in PDL::Graphics::PGPLOT (but you can avoid calling this directly by setting the <code>DrawWedge</code> option in your call to <code>imag</code> , see above). This function should normally give a decent result without the user setting any options except the <code>Label</code> option which sets the annotation, but occasionally it is necessary to change its behavior and that is done by setting the following options:</p>

<dl>

<dt id="Side"><code>Side</code></dt>
<dd>

<p>What side the wedge will appear on, the default is the right side and it is specified as a single character, &#39; <code>B</code> &#39; for bottom, &#39; <code>L</code> &#39;, &#39; <code>T</code> &#39; and &#39; <code>R</code> &#39; for left, top and right respectively.</p>

</dd>
<dt id="Displacement"><code>Displacement</code></dt>
<dd>

<p>The distance away from the axis. Default=2.</p>

</dd>
<dt id="Width"><code>Width</code></dt>
<dd>

<p>The width of the wedge. Default=3</p>

</dd>
<dt id="Foreground"><code>Foreground</code></dt>
<dd>

<p>The value to set the foreground colour to. This can be referred to as <code>Fg</code> as well. The default is the max value used by <code>imag</code> when drawing the image.</p>

</dd>
<dt id="Background"><code>Background</code></dt>
<dd>

<p>The value to set the background colour to. This can be referred to as <code>Bg</code> as well. The default is the min value used by <code>imag</code> when drawing the image.</p>

</dd>
<dt id="Label"><code>Label</code></dt>
<dd>

<p>The label used to annotate the wedge.</p>

</dd>
</dl>

<p> <img width="400" alt="" src="content/book/PGPLOTFigs/eg_wedge.8.png"/></p>

<pre><code>    dev &#39;/xs&#39;, {WindowWidth =&gt; 6, Aspect =&gt; 1};
    $im = rfits(&#39;Frei/n4013lJ.fits&#39;);
    $im += abs(min($im)-1);
    $im = log10($im);
    imag($im, {PlotPosition =&gt; [0.1, 0.85, 0.175, 0.925], Min =&gt; 2.6, Max =&gt; 2.0 });
    draw_wedge({Wedge =&gt; {Width =&gt; 4, Label =&gt; &#39;Log Counts&#39;, Displacement =&gt; 1}});</code></pre>

<p>Note that you will sometimes need to directly set the plot size to avoid clipping in the display. A full example that shows the use of <code>draw_wedge</code> can be seen in the Figure above where we display a galaxy and display a look-up table next to it.</p>

<h2 id="Contour-plots-and-vector-fields">Contour plots and vector fields</h2>

<p>Contour plots are very similar to image displays and display lines at particular levels of the image. The function to create contour plots is <code>cont</code> which at the simplest level only takes a 2D array as its argument.</p>

<pre><code>    $a = sequence(100,100); cont $a;</code></pre>

<p> <img width="400" alt="" src="content/book/PGPLOTFigs/ex_cont1.8.png"/></p>

<p>That might be all you need, but most likely you would like to specify contour levels, label contours and maybe draw them in different colours.</p>

<p>You use the option <code>Contours</code> to give the wanted contour levels as an ndarray and <code>Labels</code> to give an anonymous array of strings for labels as shown in the example below:</p>

<pre><code>    use PDL; use PDL::Graphics::PGPLOT; 
    dev(&#39;/xs&#39;);
    $y = ylinvals(zeroes(100,100), -5, 5); 
    $x = xlinvals(zeroes(100,100), -5, 5);
    $z = cos($x**2)+sin($y*2);
    cont $z, {Contours =&gt; pdl(-1, 0, 1), Labels =&gt; [&#39;-1&#39;, &#39;0&#39;, &#39;1&#39;]};</code></pre>

<p> <img width="400" alt="" src="content/book/PGPLOTFigs/ex_cont2.8.png"/></p>

<p>In addition it is possible to colour the labels differently from the contour lines (<code>LabelColour</code>), to specify the number of contours instead of their values (<code>NContours</code>) and to draw negative contours as dashed lines and positive as solid lines by setting the option <code>Follow</code> to a value <i>&gt;0</i>.</p>

<p>Overlaying a contour plot on top of an image is as easy as displaying the image, call <code>hold</code> and display the contour plot. The reader might want to try a colour version of the example above ( <code>$z</code> as in the example):</p>

<pre><code>    pdl&gt; ctab(&#39;Fire&#39;);
    pdl&gt; imag $z; hold;
    pdl&gt; cont $z, {Contours =&gt; pdl(-1,0,1)};</code></pre>

<p>The final 2D plot command we will deal with here is the command for plotting a vector field, <code>vect</code>. This command takes two arrays as arguments. The first gives the horizontal component and the second the vertical component of the vector field. The length of the vectors can be set using the <code>SCALE</code> option and the position relative to the pixel centers with the option <code>POS</code>.</p>

<p>What is important to note with a command like <code>vect</code> is that you can use the <code>Transform</code> option to map a smaller vector array to a larger image. This is often useful because a vector field with <i>256 x 256</i> arrows on top of a similarly sized image will quickly be unreadable. The result of using this technique is shown below together with the code that produced the plot.</p>

<p> <img width="400" alt="" src="content/book/PGPLOTFigs/ex_vec1.8.png"/></p>

<pre><code>    pdl&gt; $x = xlinvals(zeroes(100,100), -5, 5)
    pdl&gt; $y = ylinvals(zeroes(100,100), -5, 5)
    pdl&gt; $z = sin($x*$y/2)
    pdl&gt; imag $z;
    pdl&gt; hold;
    # Show the partial derivatives wrt.  x &amp; y as vectors
    pdl&gt; $xcomp = $x*cos($x*$y/2)/2
    pdl&gt; $ycomp = $y*cos($x*$y/2)/2
    # We want to show only every tenth vector for clarity
    pdl&gt; $s = &#39;0:-1:10,0:-1:10&#39;;
    # Finally we need to map the final 10x10 array to the 100x100 image
    pdl&gt; $tr = pdl(0,10,0,0,0,10)
    pdl&gt; vect $xcomp-&gt;slice($s), $ycomp-&gt;slice($s), {Transform=&gt;$tr} </code></pre>

<h2 id="Drawing-simple-shapes">Drawing simple shapes</h2>

<p>In addition to the simple commands described above, there are a few convenient commands for drawing simple shapes such as circles, ellipses and rectangles. These are fairly straightforward commands with similar options and invocations so we will go through them fairly quickly. A common issue with these commands as with the <code>poly</code> command is that they draw filled shapes, if you want outlined shapes to be drawn you have to set the <code>Filltype</code> option to <code>Outline</code>.</p>

<p>The circle command is probably the simplest, it draws a circle (which may or may not look like a circle depending on the aspect ratio of your display - see <a href="#Setting-up-the-plot-area">&quot;Setting up the plot area&quot;</a>. The user specifies the radius and the x and y position of the center:</p>

<pre><code>    pdl&gt; dev &#39;/xs&#39;, {Aspect =&gt; 1, WindowWidth =&gt; 5} 
    pdl&gt; env 0, 10, 0, 10 
    pdl&gt; $radius=2; ($x, $y) = (4, 4) 
    pdl&gt; circle $x, $y, $radius, {LineWidth =&gt; 3}</code></pre>

<p> <img width="400" alt="" src="content/book/PGPLOTFigs/ex_circle1.8.png"/></p>

<p>The <code>ellipse</code> function is like the <code>circle</code> function but it requires the user to specify the minor and major axis and the angle between the major axis and the horizontal. For ease of use it is probably better to specify these as options, but if you remember the order you can also give them directly as arguments to the function (<i>x</i>-position, <i>y</i>-position, major axis, minor axis, angle):</p>

<pre><code>    pdl&gt; dev &#39;/xs&#39;, {Aspect =&gt; 1, WindowWidth =&gt; 5} 
    pdl&gt; env 0, 10, 0, 10 
    pdl&gt; ellipse 4, 4, {MajorAxis =&gt; 2, MinorAxis =&gt; 1, Theta =&gt; atan2(1,1)}</code></pre>

<p> <img width="400" alt="" src="content/book/PGPLOTFigs/ex_ellipse1.8.png"/></p>

<p>And finally the <code>rectangle</code> command draws rectangles where you can give the position of the centre, the length of the sides and the angle with the horizontal. The operation is very similar to the <code>ellipse</code> command with the length of the sides of the rectangle taking place of the major and minor axis.</p>

<pre><code>    pdl&gt; dev &#39;/xs&#39;, {Aspect =&gt; 1, WindowWidth =&gt; 5} 
    pdl&gt; env 0, 10, 0, 10 
    pdl&gt; rectangle 4, 4, {XSide =&gt; 2, YSide =&gt; 1, Angle =&gt; atan2(1,1)}</code></pre>

<p> <img width="400" alt="" src="content/book/PGPLOTFigs/ex_rect1.8.png"/></p>

<p>Note that <code>Angle</code> and <code>Theta</code> are synonyms.</p>

<p>In addition you can set the sides to be similar by setting the <code>Side</code> option to the length you require. The lengths are all specified in data-coordinates (which is why you should do a plot or call <code>env</code> before using any of these commands).</p>

<p>For other shapes or when these are not sufficiently flexible you should use the <code>poly</code> command which is called by both <code>rectangle</code> and <code>ellipse</code> .</p>

<h2 id="Text-and-legends">Text and legends</h2>

<p>The main command for drawing text on the plotting surface is the <code>text</code> command which at its basic level just draws a string from the given <i>x</i> and <i>y</i> position:</p>

<pre><code>    pdl&gt; dev &#39;/xs&#39; 
    pdl&gt; env 0,10,0,10, {Axis =&gt; &#39;GRID&#39;} 
    pdl&gt; text &#39;Left justified&#39;, 4, 1 
    pdl&gt; text &#39;Centered&#39;, 4, 2, { Justification =&gt; 0.5} 
    pdl&gt; text &#39;Right justfied&#39;, 4, 3, { Justification =&gt; 1.0}</code></pre>

<p> <img width="400" alt="" src="content/book/PGPLOTFigs/ex_text1.8.png"/></p>

<p>Here we have included grid-lines to show the effect of the different justifications. Note that <code>Justify</code> is a synonym for <code>Justification</code>, and that you need to give numerical values for the position. Normally the text background is transparent as shown here, but you can also set an opaque background by setting the <code>BackgroundColour</code> option to a colour name or value (see also the next section).</p>

<p>In addition to the justification option one can also change the angle of the text using the <code>Angle</code> option and specify the text and/or <i>x</i> and <i>y</i> as options (the best advice is to either do all or none).</p>

<pre><code>    pdl&gt; text {XPos =&gt; 1, YPos=&gt; 4, Angle =&gt; 25, Text =&gt; &#39;Tilted&#39;}</code></pre>

<h3 id="Non-alphanumeric-symbols">Non-alphanumeric symbols</h3>

<p>PGPLOT has extensive support for non-alphanumeric characters in text strings and also offers reasonable control over the display of superscripts, subscripts etc. This is all achieved using <i>escape sequences</i>. In PGPLOT these are all signaled by the character <code>\</code> . Thus <code>\u</code> starts a superscript or ends a subscript - it signals a shift &quot;up&quot;. Likewise <code>\d</code> starts a subscript or ends a superscript. Consult the PGPLOT documentation for a full list.</p>

<h2 id="Labeling-your-figures-in-PGPLOT">Labeling your figures in PGPLOT</h2>

<p>The only additional text-related function in the PDL::Graphics::PGPLOT interface is the <code>legend</code> command which draws a legend in the plot window. This is a more complex routine which can be a time-saver as soon as you have learned how to use it. It takes the same arguments as the <code>text</code> command with the exception that the text argument is an anonymous array of labels for the legend, and that a fourth argument is accepted which specifies the width of the box in which the legend will be drawn. If this is not set or it is set to the string <code>Automatic</code> it will be adjusted to contain the legend with the default font-size (or that set by the user via the <code>CharSize</code> option).</p>

<p> <img width="400" alt="" src="content/book/PGPLOTFigs/ex_legend1.8.png"/></p>

<pre><code>    pdl&gt; $x = sequence(100) / 5; $y1 = sqrt($x); $y2 = $x**2;
    pdl&gt; env(0, 4, 0, 15);
    pdl&gt; line $x, $y1, {LineStyle =&gt; &#39;Dashed&#39;, Colour =&gt; &#39;Red&#39;}
    pdl&gt; line $x, $y2, {LineWidth =&gt; 3, Colour =&gt; &#39;Blue&#39;}
    pdl&gt; legend [&#39;sqrt(x)&#39;, &#39;x \backslash u2&#39;], 0.5, 10,
                    {LineStyle =&gt; [&#39;Dashed&#39;, undef],
                    LineWidth =&gt; [undef, 3], Colour =&gt; [&#39;Red&#39;, &#39;Blue&#39;] }
                  # ,Width =&gt; 1.0 } makes x**2 legend disappear, why?</code></pre>

<p>The idea of the <code>legend</code> command is that you give the line-styles, line-widths, colours or symbols you want to illustrate as anonymous arrays to the <code>LineStyle</code>, <code>LineWidth</code>, <code>Colour</code> and <code>Symbol</code> options. Not very clear? Well, maybe an example will help.</p>

<p>The figure above is an example of <code>legend</code> in use. Two lines are drawn, a red dashed line and a blue thick line. To annotate this plot using <code>legend</code> you give the text annotations as an (anonymous) array of strings, the x and y position of the legend box and an anonymous hash containing information about the legends to draw as shown in the example. The options used to specify a particular draw style are the same as the ones used in the call to <code>line</code> and will undergo the same translations-note however that you can specify a value of <code>undef</code> which requests that the current default for the linestyle/linewidth/colour etc. is used. The <code>Width</code> option is used to set the width of the legend box and is given in data coordinates. The idea is that you will create the plot, see where you want the legends to go and then set the x and y width to the appropriate settings and redoing the plot, possibly using the replay mechanism, see <a href="#Recording-and-playing-back-plot-commands">&quot;Recording and playing back plot commands&quot;</a>.</p>

<p>The legend command has several options, the main of which are illustrated above. The remaining options are useful for tweaking the appearance, and a full list is as follows:</p>

<dl>

<dt id="Text"><code>Text</code></dt>
<dd>

<p>The text, this is an alternative to specifying it as the first argument to the function.</p>

</dd>
<dt id="XPos"><code>XPos</code></dt>
<dd>

<p>The X-position of the text, again as an alternative to specifying it as the second argument.</p>

</dd>
<dt id="YPos"><code>YPos</code></dt>
<dd>

<p>The Y-position of the text, again as an alternative to specifying it as the third argument.</p>

</dd>
<dt id="Width1"><code>Width</code></dt>
<dd>

<p>The width of the (invisible) box the legend is drawn inside. This can also be specified as the fourth argument to the <code>legend</code> command. If this is set to the string <code>Automatic</code> the width is calculated from the character size used.</p>

</dd>
<dt id="Height"><code>Height</code></dt>
<dd>

<p>This can be used as an alternative constraint on size, giving the height of the legend box. If both <code>Width</code> and <code>Height</code> are specified the smallest size is used (characters are not compressed or stretched to fit).</p>

</dd>
<dt id="TextFraction"><code>TextFraction</code></dt>
<dd>

<p>The fraction of the box set aside for text. The default is 0.5 which usually is ok. Note that this option used to be called <code>Fraction</code> , which still is available as a synonym.</p>

</dd>
<dt id="TextShift"><code>TextShift</code></dt>
<dd>

<p>This option allows for fine control of the spacing between the text and the start of the line/symbol. It is given in fractions of the total width of the legend box. The default value is 0.1.</p>

</dd>
<dt id="VertSpace"><code>VertSpace</code></dt>
<dd>

<p>By default the text lines are separated by one character height (in the sense that if the separation were 0 then they would lie on top of each other). The <code>VertSpace</code> option allows you to increase (or decrease) this gap in units of the character height; a value of 0.5 would add half a character height to the gap between lines, and -0.5 would remove the same distance. The default value is 0. This option has <code>VSpace</code> as a synonym (more natural for the TeX-heads out there).</p>

</dd>
</dl>

<h2 id="Using-colour">Using colour</h2>

<p>PGPLOT has a two disjoint sets of colours. One set determines the colour table used when displaying images and is initialized to a grayscale, and the other is a set of 15 colours used to colour all other plotting objects. The latter set is accessible through the <code>Colour</code> option described in <a href="#Options-in-plot-commands">&quot;Options in plot commands&quot;</a> Here we will concentrate on accessing the lookup-table for image display.</p>

<p>The command used to change the colour table is <code>ctab</code>, which in its generic form takes six arguments specifying the intensity levels, red, green and blue colour components, contrast and brightness levels. The contrast and brightness are optional so that we can say:</p>

<pre><code>    pdl&gt; $int = pdl([0, 0.33, 0.66, 1.0]) 
    pdl&gt; $r = pdl([0.5, 0, 0.5, 1]) 
    pdl&gt; $b = pdl([0.0, 0.5, 1.0, 0.5]) 
    pdl&gt; $g = pdl([1.0, 0.5, 0.0, 0.5]) 
    pdl&gt; ctab($int, $r, $g, $b); 
    pdl&gt; $a = rvals(100, 100)
    pdl&gt; imag $a</code></pre>

<p> <img width="400" alt="" src="content/book/PGPLOTFigs/ex_col1.8.png"/></p>

<p>...which should display a circularly symmetric figure with green in the centre, going through blue to red-ish where <code>$a</code> is at a maximum.</p>

<p>It is however normally sufficient to use the colour tables made available by <code>PDL::Graphics::LUT</code>. This package makes available a large number of standard colour tables which can be accessed using the following commands:</p>

<dl>

<dt id="lut_names"><code>lut_names</code></dt>
<dd>

<p>This returns a perl list of the available colour tables.</p>

</dd>
<dt id="lut_ramps"><code>lut_ramps</code></dt>
<dd>

<p>As above, but returns a list of the names of the available intensity ramps.</p>

</dd>
<dt id="lut_data"><code>lut_data</code></dt>
<dd>

<p>And finally the data in the tables can be accessed with this function which takes as arguments the name of the colour table, and optionally a scalar determining if the colour table is to be reversed and the name of an intensity ramp (default is a linear intensity ramp). The function returns four ndarrays with intensity and RGB values which can immediately be passed to <code>ctab</code>.</p>

</dd>
</dl>

<p>Note that these commands do not set the colour table for you, you will still need to call <code>ctab</code> to do that.</p>

<p>Thus to set one of the colour tables in the <code>PDL::Graphics::LUT</code> package, you do:</p>

<pre><code>    pdl&gt; use PDL::Graphics::LUT;
    pdl&gt; print &quot;Available tables: &quot;.join(&#39;, &#39;, lut_names());
    Available tables: aips0, backgr, bgyrw, blue, blulut, color, green,
    heat, idl11, idl12, idl14, idl15, idl2, idl4, idl5, idl6, isophot, light,
    manycol, pastel, rainbow, rainbow1, rainbow2, rainbow3,
    rainbow4, ramp, random, random1, random2, random3,
    random4, random5, random6, real, red, smooth, smooth1,
    smooth2, smooth3, staircase, stairs8, stairs9, standard
    pdl&gt; ctab( lut_data \series default (&#39;rainbow1&#39;));
    pdl&gt; imag rvals(100,100);</code></pre>

<p>which should give you a colour table that goes from black through green, blue and yellow to red.</p>

<p>All the colour tables with their names overlaid can be generated with this script:</p>

<pre><code>    use PDL::Graphics::PGPLOT;
    use PDL::Graphics::LUT;
    dev(&quot;/xs&quot;,3,15);
    foreach(lut_names()){
        print&quot;$_\n&quot;;
        ctab(lut_data($_));
        imag sequence(250,1);
        text $_,20,-0.2,{CHARSIZE=&gt;20,LINEWIDTH=&gt;20,COLOUR=&gt;0};
        text $_,20,-0.2,{CHARSIZE=&gt;20,LINEWIDTH=&gt;1,COLOUR=&gt;1};
    }</code></pre>

<p>And the resultant figure is shown below:</p>

<p> <img width="400" alt="" src="content/book/PGPLOTFigs/ColorTables2.8.png"/></p>

<h2 id="Broadcasting-in-PDL::Graphics::PGPLOT">Broadcasting in PDL::Graphics::PGPLOT</h2>

<p>The plot commands do not always lend themselves to easy broadcasting because it can sometimes be difficult to know what the user intends to do when (say) an array of images is passed to the <code>imag</code> command. Are they to be displayed in several plot panels, are they to be plotted on top of each other, seamlessly plotted next to each other? But even more complex is the question of treatment of options and how to deal with these if there are less options than for instance, lines to draw (a common occurrence if you wanted to draw a <b>lot</b> of lines).</p>

<p>That said the <code>PDL::Graphics::PGPLOT</code> interface does have limited support for broadcasting in the <code>line</code> and <code>points</code> functions. These call the <code>tline</code> and <code>tpoints</code> internally, and work just like <code>line</code> and <code>points</code> except that they expect the input <i>y</i>-ndarray to be 2D, with each line in the array plotted against the <i>x</i>-ndarray.</p>

<p>The way the options are treated is the most interesting. To set options for a set of lines, give an anonymous array as argument to that option with a value for each line. If you give more options than there are lines, the surplus is ignored. However if you give less, the options are repeated from the start. Although possibly a bit confusing this is very powerful because you can get a large number of combinations of colour and linestyle. For instance if you give 4 colours and 5 linestyles, you get a total of 20 distinct combinations and should you give 3 linewidths as well you will suddenly have 80 different styles to work with with very little typing. Note however that you need to make sure that the numbers you give are relatively prime - otherwise you will get much less possibility, just think of the situation where you have 4 linestyles and 4 colours, they will just loop in harmony and result in only 4 combinations.</p>

<p>Anyway, let us see how it all works in practice by creating a plot of sine curves with different frequencies. This is a simple example where we want to colour all even frequencies with red and all odd with blue and vary the line-styles as well:</p>

<pre><code>    pdl&gt; $pi=4*atan2(1,1); 
    pdl&gt; $x=zeroes(50)-&gt;xlinvals(0, $pi) 
    pdl&gt; $freq = sequence(10) 
    pdl&gt; $y = sin($freq*transpose($x)) 
    pdl&gt; line $x, $y, {Colour =&gt; [&#39;Red&#39;, &#39;Blue&#39;], Linestyle=&gt;[0,1,2,3,4,5]}</code></pre>

<p> <img width="400" alt="" src="content/book/PGPLOTFigs/ex_tline1.8.png"/></p>

<h2 id="Recording-and-playing-back-plot-commands">Recording and playing back plot commands</h2>

<p>Have you ever created a good-looking plot on the command line of an interactive data program, be it PDL, IDL, MATLAB, Octave or any other package, and wished that you could make a quick Postscript copy of it only to find that you need to redo all the commands? I certainly have. In the newer versions of PDL this is thankfully not the case anymore. These have a recording facility built in. However this is not enabled by default (for reasons described later in this section), you need to turn it on yourself. The way to do this is to set the <code>$PDL::Graphics::PGPLOT::RECORDING</code> variable to a true value:</p>

<pre><code>    pdl&gt; $PDL::Graphics::PGPLOT::RECORDING = 1</code></pre>

<p>You can turn this on automatically in the <code>perldl</code> shell if you put this command in your <code>~/.perldlrc</code> file. Alternatively you can turn on recording for each plot device independently by setting the <code>Recording</code> option to true when starting a device:</p>

<pre><code>    pdl&gt; dev &#39;/xs&#39;, {Recording =&gt; 1}</code></pre>

<p>Note that if you set the variable it must be set <b>after</b> you have <code>use</code>&#39;d the PDL::Graphics::PGPLOT because this package sets the variable when it initializes to its default value of zero.</p>

<p>In the following I will focus my attention on using the recording and playback functions in the <code>perldl</code> shell as I envisage that it will be most useful there. There are a couple of potential uses in scripts as well which I will get back to below, but this is not well thought through yet.</p>

<p>Before we continue it should also be added that the recording facility is somewhat experimental. In particular it doesn&#39;t deal very well with multi-panel plotting where you jump back and forth between panels. If you want to do that, make sure you specify the <code>Panel</code> option for every call.</p>

<p>It is very easy to use the recording facilities with a few less obvious aspects. An example should go a long way to get you to understand the basics. First we set up a simple plot using the commands we learned above:</p>

<pre><code>    pdl&gt; use PDL::Graphics::PGPLOT
    pdl&gt; $PDL::Graphics::PGPLOT::RECORDING = 1
    pdl&gt; $x = sequence(10)
    pdl&gt; $y = random(10)
    pdl&gt; dev &#39;/xs&#39;
    pdl&gt; env(-1, 11, -0.5, 1.5, {Xtitle =&gt; &#39;Number&#39;})
    pdl&gt; points $x, $y, {Symbol =&gt; &#39;Plus&#39;}</code></pre>

<p>which should give you a scatter plot on screen. Now after constructing this fantastic piece of scientific illumination you decided to make a Postscript version of it, but you are loathe to use the up key to execute the commands again so you decide to use the recording facilities.</p>

<pre><code>    pdl&gt; $s = retrieve_state()
    pdl&gt; dev &#39;replay_ex.ps/ps&#39;
    pdl&gt; replay $s</code></pre>

<p>That is all. These commands should now have created a file called <code>replay_ex.ps</code> in the present directory.</p>

<p>The <code>retrieve_state</code> commands retrieves the current state of the plot device and returns a variable to hold this in. This state contains references to the data plotted and plot commands executed and can be replayed, or re-executed, at a later stage using the <code>replay</code> command. You can also turn on and off recording temporarily with the <code>turn_off_recording</code> and <code>turn_on_recording</code> commands.</p>

<p>This suffices for most situations and should work for any complexity of plot constructed. There are however a few rules that needs to be observed and possible pitfalls:</p>

<p>If you turn on recording globally using <code>$PDL::Graphics::PGPLOT::RECORDING</code>, you must set the variable <b>before</b> opening a plot device because the value of the variable is only checked then. If you forget, you can of course always turn it on with the <code>turn_on_recording</code> function.</p>

<p>The state is cleared whenever the plot window is erased, or if the user executes the <code>clear_state</code> command. In particular this occurs when you change plotting device (although if you use several windows they will each have their own state; see also the following section), so use the <code>retrieve_state</code> command <b>before</b> you change device!</p>

<p>The state contains references to the data plotted. This does not use memory (at least not appreciably!), but it does mean that an extra reference to the data is kept and the memory to the data might not be freed when you expect it to. This can be problematic if you make a lot of image displays. The best ways to avoid this problem in the <code>perldl</code> shell is to call the <code>clear</code> on the state: <code>perldl&gt; $s-&gt;clear()</code> or to re-use the variable next time you call <code>retrieve_state</code>. Note that this should only be a problem if you explicitly call <code>retrieve_state</code>.</p>

<p>Finally since only references to the data are held, make sure you do not modify them before calling <code>replay</code> or you might end up with a rather different looking plot!</p>

<p>What we covered now is the basic use of the recording facility, which hopefully will come in handy rather often (which is why I recommend enabling it permanently in the <code>perldl</code> shell as outlined above). However there are slightly less common uses of the facility that might come in handy:</p>

<h3 id="Redoing-a-plot-with-slightly-different-data">Redoing a plot with slightly different data</h3>

<p>The fact that the recording state contains references to the data enables a somewhat tricky but potentially very useful trick to be executed: Redoing the plot with adjusted data. Sometimes you make a complex plot only to discover that you had made an error with your data and you need to redo it. This is where you can use the recording functions: Retrieve the state, make adjustments to the data making sure not to break the link and run <code>replay</code>.</p>

<p>However, although this sounds quite easy it has a few subtleties that can give surprising results at times. It might therefore be a good idea to look at a few, very similar and very basic, examples and compare their effects. So let us first of all open a plot device:</p>

<pre><code>    pdl&gt; dev &#39;/xs&#39;, {Recording =&gt; 1}</code></pre>

<p><b>NOTE: What I describe here is not well tested and is probably buggy. This needs to be sorted out before finishing - at least I have had a few weird results when trying this out.</b></p>

<p>We are going to use our example of plotting a parabola, and replaying it with various parameter sets. Let us therefore define a couple of variables and plot this, first letting PDL decide on the plot limits:</p>

<pre><code>    pdl&gt; $x = sequence(10); $y = $x*$x
    pdl&gt; line $x, $y;
    pdl&gt; $s = retrieve_state()</code></pre>

<p>The whole point of this problem is to change the variables, so let us add 3 to the X-values and replay the command:</p>

<pre><code>    pdl&gt; $x += 3
    pdl&gt; replay $s</code></pre>

<p>This should give you a part of a parabola from <code>x=3</code> to <code>x=12</code>, but now defined by the equation <code>y=pow((x-3),2)</code> . Also the limits of the plot window should have adjusted themselves to the new <i>x</i> values. Note that the <i>y</i> values are unchanged.</p>

<p>In the previous example the limits in the plot window adjusted to the new values for <i>x</i> and <i>y</i> because the <code>line</code> command sets the plot limits if the plot is not held (such as with an explicit call to <code>env</code>). But what happens if we redo the example with our own chosen limits?</p>

<pre><code>    pdl&gt; $x = sequence(10); $y = $x*$x
    pdl&gt; env (0, 9, 0, 81)
    pdl&gt; line $x, $y;
    pdl&gt; $s = retrievestate()
    pdl&gt; $x += 3; replay $s</code></pre>

<p>The result now should be as shown in Figure XXXXXXXX which has the same plot limits as before, but a shifted parabola. This is because the state now remembers the explicit <code>env</code> statement that you had made and uses that to set the limits.</p>

<p>Finally you must remember that the reference is not to a variable name, but to an ndarray which exists separately from the variable. Thus you cannot change your data at a whim, so the following change will change the data back to where we started</p>

<pre><code>    pdl&gt; $x -= 3; replay $s</code></pre>

<p>But the following will <b>not</b> plot a parabola starting at <i>x=5</i>:</p>

<pre><code>    pdl&gt; $x = sequence(10)+5.0; replay $s</code></pre>

<p>The reason for this is that the reference kept in the state object is to the actual <b>data</b> in the previous <i>$x</i>-object and not to the variable name.</p>

<p>However sometimes you want to give a entirely new dataset to the plot. Say you wanted to plot a sine curve instead of a parabola. Is there any way to do that? The answer is yes, but it looks rather ugly, so you might want to consider whether this is something you want to do</p>

<pre><code>    pdl&gt; $x = sequence(10); $y = $x*$x
    pdl&gt; line $x, $y; $s=retrievestate()
    # Now let us transfer this to a sine plot
    pdl&gt; $y -= $y; $y += sin($x)
    pdl&gt; replay $s</code></pre>

<p>And voila! a sine curve does step forth. Not exactly elegant, but this trick allows you to replace any variable used in a complex plot with a totally different content.</p>

<h3 id="Using-recording-in-scripts">Using recording in scripts</h3>

<p>In general the recording facility is of rather limited use in scripts because you can just as easily encapsulate your plot commands in a subroutine and just call the subroutine when need be. At present the only saving is probably in typing, but if the facility is extended to saving and restoring plot commands the situation would change.</p>

<h2 id="The-object-oriented-approach">The object oriented approach</h2>

<p>Assume that you are developing a simulation. When you are testing the code (all written in PDL of course) you have to keep track of how some data changes at every time-step, but at the same time you want to look at time-averages. If you were to use what we discussed above you would probably want to display the time-steps in one panel and the time-averages in another panel in a plot window. The problem with this is of course that one panel is updated a lot more often than the other so you have to waste a lot of time re-plotting the time-average.</p>

<p>Clearly there are two possible ways to improve this: a) have a method which allows you to plot to a given panel when you want and b) have to plot windows. It is possible to use the first approach by giving the <code>Panel</code> option to the plot commands:</p>

<pre><code>    dev(&#39;/xs&#39;);
    for (my $i=0; $i&lt;$n; $i++) {
       $integrand = func($x, $i); 
       points $x, $integrand, {Panel =&gt; 2};
       $sum += $integrand;
    }
    points $x, $sum/$n, {Panel =&gt; 1};</code></pre>

<p>So that this hypothetical code-bit would keep plotting in panel 2, updating the plot there until the loop is over at which point panel 1 is updated.</p>

<p>This can be practical, but it is rather limited given the requirement of giving the panel number every time. Instead an alternative approach would be to create several plot windows, and for this you really ought to use an object oriented approach. In this approach every plot device is a separate object and you call every plot command via this object. So the previous example would be</p>

<pre><code>    my $opt = {Device =&gt; &#39;/xs&#39;, WindowWidth =&gt; 7, Aspect =&gt; 1};
    my $integrandwindow = PDL::Graphics::PGPLOT::Window-&gt;new($opt);
    my $integralwindow = PDL::Graphics::PGPLOT::Window-&gt;new($opt);
    for (my $i=0; $i&lt;$n; $i++) {
       $integrand = func($x, $i);
       $integrandwindow-&gt;points($x, $integrand);
       $sum += $integrand;
    }
    $integralwindow-&gt;points($x, $sum/$n);</code></pre>

<h3 id="Why-use-the-OO-interface">Why use the OO interface</h3>

<p>So, you may say, what is the point with the OO interface except appeasing the OO fanatics around? It seems to require more typing and I can see no significant advantage.</p>

<p>In many situations these are valid arguments, if you are just plotting data on the command line in <code>perldl</code> , for instance, or do not need multiple plot windows. And at some level the OO interface is primarily a convenience for the programmer, and it is in fact how the PDL::Graphics::PGPLOT package is implemented. That said though there are some (possibly strong) arguments for using the OO interface:</p>

<ul>

<li><p>You do not pollute your namespace, which means that you are free to define routines that are called <code>line</code> , <code>points</code> and so on. This is the main reason why I use this interface personally when doing simple plots in programs.</p>

</li>
<li><p>It is a <b>lot</b> easier to deal with multiple plot windows when using the OO interface, in fact I would personally discourage people from having multiple plot windows without using the OO interface.</p>

</li>
</ul>

<p>Eventually an argument in favor of the OO interface will hopefully be that it would enable an easier mix of different plotting packages so that they can all be accessed in a similar way, but we are not there yet.</p>

<h3 id="Usage-of-the-OO-interface">Usage of the OO interface</h3>

<p>To use the OO interface one needs to create a new plot object and then call the plot routines through this object. If you want several windows, you just create more objects and switching between these should be straightforward as you should be able to see in the following examples.</p>

<p>Note that since the OO interface is less suited to use on the command line, I have opted to show the examples as small code-bits but they should all be possible to execute from the <code>perldl</code> command line. In addition this section will merely give several examples of use of the OO interface and not discuss (again) the different commands since they are the same as we went through above, it is just a different way of calling them.</p>

<p>Opening a plot object and plotting a simple plot</p>

<p>To create a plot object we first need to <code>use</code> the PDL::Graphics2D package - this is merely a shortcut for the true PDL::Graphics::PGPLOT::Window package, but why type more when it doesn&#39;t gain you anything? Then we create the object using the standard Perl notation <code>PDL::Graphics2D-</code>new()&gt; :</p>

<pre><code>    use PDL;
    # Note that we could also access this as
    # PDL::Graphics::PGPLOT::Window, but since this is
    # shorter I advocate its use.

    use PDL::Graphics2D;
    # Now create a plot window
    my $winopt = {Device =&gt; &#39;/xs&#39;, WindowWidth =&gt; 7, Aspect =&gt; 1};
    my $w = PDL::Graphics2D-&gt;new($winopt);

    # Create a simple plot
    $x = sequence(10);
    $w-&gt;points($x, $x*$x, {Symbol =&gt; &#39;Triangle&#39;};</code></pre>

<p>Note how we use the window object (<code>$w</code>) when calling the <code>points</code> routine - since we didn&#39;t <code>use</code> the PDL::Graphics::PGPLOT package there isn&#39;t any function called <code>points</code> in our namespace and we use the window object to get hold of it. The structure is of course very similar to what we did in <a href="#Drawing-lines-and-plotting-points">&quot;Drawing lines and plotting points&quot;</a> above and there really is little practical difference between the two interfaces when plotting to only one window.</p>

<p>Therefore let us up the stakes somewhat and try a more practical example. In many situations you might have one plot where each point in the plot has many values associated to it (i.e. your plot is a slice in a multidimensional space). When you examine such data you often would like to click on a point on your plot and bring up associated data for that point in a different display - this is an obvious situation for the OO interface.</p>

<p>The logic for this project is easy: We first create two windows</p>

<pre><code>    use PDL;
    use PDL::Graphics2D;
    # Create two identical windows
    my $winopt = {Device =&gt; &#39;/xs&#39;, WindowWidth =&gt; 7, Aspect =&gt; 1};
    my $data = PDL::Graphics2D-&gt;new($winopt);
    my $associated = PDL::Graphics2D-&gt;new($winopt);</code></pre>

<p>Note that it is a good idea to name your variables containing the window objects with sensible names for later use.</p>

<p>The next step is to plot data (well, in this example I will merely create them):</p>

<pre><code>    my $x = sequence(10);
    my $y = $x**2;
    # Plot points using standard symbol
    $data-&gt;points($x, $y);</code></pre>

<p>which should draw a nice parabola on your screen. Now the user (that is you, reader) has to click on (or near) a point to select it - we will then use the X-value of that point to set the period of sine curve:</p>

<pre><code>    print &quot;Dear user, please click on (or close to) a point\n&quot;;
    my ($xin, $yin) = $data-&gt;cursor();
    # closest will now contain the index of the point closest to
    # where the user clicked.
    my $closest = minimum_ind(abs($x-$xin) + abs($y-$yin));
    my $y_associated = sin($x-&gt;at($closest)*$x);
    $associated-&gt;line($x, $y_associated);</code></pre>

<p>That should now give you a sine wave in the second window with a frequency dependent on where along the X-axis you clicked. Of course it would be a lot easier to use <code>$xin</code>, but that wasn&#39;t what we tried to do after all.</p>

<p>This is of course a very simplified example, but it does provide a framework for a more comprehensive data explorer. From astronomy a typical example would be to plot scatter-plots for two variables and bringing up images of the objects by clicking at their data in the plot window. In other situations the data might be financial data for a set of companies and clicking on the points would bring up a comprehensive summary of that company. You are limited by your imagination!</p>

<p>The bottom line is that whatever your requirements are, the OO approach is probably better when you need more than one plot window, but when you only use one window, and particularly on the <code>perldl</code> command line.</p>

<h2 id="Using-PGPLOT-commands-directly">Using PGPLOT commands directly</h2>

<p>The Perl module PGPLOT contains interfaces to all PGPLOT functions. The majority of these functions have alternative interfaces in the PDL package, but there might be situations when you need to use these functions directly. And in addition if you are used to using PGPLOT from before you might prefer the interface, although it is rather inconvenient when dealing with PDL.</p>

<p>Full documentation for the PGPLOT functions can be found at Tim Pearson&#39;s WWW page: <code>http://astro.caltech.edu/~tjp/pgplot/</code> . This is not the place to discuss the details of PGPLOT, but it is interesting to learn how to access these routines from PDL with ndarrays as arguments.</p>

<p>Typical PGPLOT drawing functions take as arguments the number of points and references to perl arrays to give x and y coordinates, thus:</p>

<pre><code>    @x = (1,2,3);
    @y = (3,-1,7);
    pgpoint(3, \@x, \@y, 4);</code></pre>

<p>will plot three points with the x and y values indicates and using plotting symbol 4 (circle).</p>

<p>The complication for PDL users is that ndarrays are not perl arrays and hence have to be converted to array references before they can be passed to a PGPLOT function. This is achieved with the <code>get_dataref</code> command which returns a reference to the data in an ndarray. Thus the example above would be written:</p>

<pre><code>    $x = pdl(1,2,3);
    $y = pdl(3,-1,7);
    pgpoint($x-&gt;nelem, $x-&gt;getdataref, $y-&gt;getdataref, 4);</code></pre>

<p>in PDL.</p>

<p>In general you should use the provided wrapper routines for readability, but feel free to combine the two if you prefer. You should be able to pick&#39;n&#39;mix functions from the PDL interface and from PGPLOT directly, although a few subtle bugs might creep in (in particular the handling of several plot windows).</p>

<p>There are several situations where direct access to PGPLOT might be necessary. Although hopefully they are not very common, it can be useful to look at a few to see what the PDL::Graphics::PGPLOT module doesn&#39;t do. Since it is possible to mix PGPLOT commands with the PDL::Graphics::PGPLOT commands this is not a major problem though, although it might require you to learn some PGPLOT. So to turn to some examples, I have decided to list a few simple problems:</p>

<ul>

<li><p>Drawing several plot boxes on top of each other to get differently shaded grids. This is done in one of the demonstration programs that come with PGPLOT and can&#39;t be easily done in PDL::Graphics::PGPLOT without some playing around with the <code>PlotPosition</code> option. It is a lot easier to call <code>pgbox</code> directly.</p>

</li>
<li><p>Complex contour plots - in particular non-rectangular. At present there is no support for non-rectangular contour plots in PDL::Graphics::PGPLOT, and neither is any support planned for the near future. You are advised to read the PGPLOT documentation for <code>pgconx</code> and have a look at demo #3 in the PGPLOT distribution for an example.</p>

</li>
</ul>

<p>The bottom line is that as your plots get more and more complex you might end up in a situation where you need the finer control offered by the <code>PGPLOT</code> package, but for day-to-day use it is hoped that PDL::Graphics::PGPLOT will address most people&#39;s needs. And if doesn&#39;t then let us know!</p>

<h1 id="Graphics-with-PLplot">Graphics with PLplot</h1>

<p>The <b>PDL::Graphics::PLplot</b> perl module, is an interface to the <a href="http://plplot.sourceforge.net">http://plplot.sourceforge.net</a> PLplot C library. It is a 2d plotting library, but also does 1-D bargraphs and 3-D projection graphs.</p>

<p>Many of the examples, discussed below, are from the PDL::Graphics-PLplot/t subdirectory, of the source module. These are written in the functional style, and are direct translations of the examples which come with the <b>PLplot C library</b></p>

<p>The rest of the examples, are object-oreiented, derived from David Merten&#39;s slideshow on <b>PDL::Graphics::PLplot</b>. His very informative slideshow can be downloaded or viewed at <a href="http://www.slideshare.net/dcmertens/p-lplot-talk">http://www.slideshare.net/dcmertens/p-lplot-talk</a></p>

<h2 id="Introducing-PDL::Graphics::PLplot">Introducing <code>PDL::Graphics::PLplot</code></h2>

<p>The basic methods available:</p>

<pre><code>  new, close -&gt;  create and finalize plot objects
  xyplot, stripplots -&gt;   2D plotting
  shadeplot -&gt;   &quot;topographical&quot; 3D data representation
  histogram -&gt;   plot distribution of 1D data
  bargraph -&gt;    plot distribution of categorical data
  text -&gt;   annotate plots
  setparm -&gt;  set various plotting parameters</code></pre>

<p>Once you specify a plotting option, the option will carry over to future calls on the same PLplot object.</p>

<p>The first thing you will notice about invoking PLplot, is that it will prompt you for an output device, or maybe a file to save to, if you do not specify one either in <b>perldl</b> or a script</p>

<p> <img width="400" alt="using PDL::Graphics::PLplot, invoking the output device menu" src="content/book/PLplot/w00.pl.800.png"/></p>

<p>Figure 00: using PDL::Graphics::PLplot, invoking the output device menu.</p>

<p>You can specify a device</p>

<pre><code>   To specify the output device:

      pdl&gt; dev(&#39;/xwin&#39;)
   
   or in a script
      
      use PDL::Graphics::PLplot;
      # display the image in the xwindow
      my $pl = PDL::Graphics::PLplot-&gt;new(
                    DEV =&gt; &#39;xwin&#39;
                    );
                  </code></pre>

<h2 id="Plotting-a-simple-parabola">Plotting a simple parabola</h2>

<p>This code:</p>

<pre><code>        #!/usr/bin/perl
        use warnings;
        use strict;
        use PDL;
        use PDL::Graphics::PLplot;
        my $pl = PDL::Graphics::PLplot-&gt;new( DEV =&gt; &quot;png&quot;, FILE =&gt; &quot;$0.png&quot; );
        my $x  = sequence( 10 );
        my $y  = $x**2;
        $pl-&gt;xyplot( $x, $y );  
        $pl-&gt;close;</code></pre>

<p>produces a nice parabola, in a PNG file.</p>

<p><img width="400" alt="A parabola" src="content/book/PLplot/w01.pl.800.png"/></p>

<h2 id="Object-Oriented-Examples">Object Oriented Examples</h2>

<p>This section shows how to use the object oriented methods of the <b>Perl</b> interface to <b>PDL::Graphics::PLplot</b></p>

<h3 id="Axis-labelling-and-titles">Axis labelling and titles</h3>

<pre><code>        use PDL;
        use PDL::Graphics::PLplot;

        # Generate a time series
        my $time = sequence(100)/10;
        my $sinewave = 5 * sin($time);
        # Create the PLplot object: use xwin for display
        my $pl = PDL::Graphics::PLplot-&gt;new( DEV =&gt; &quot;xwin&quot;);

        # Plot the time series
        $pl-&gt;xyplot($time, $sinewave
             , XLAB =&gt; &#39;time [s]&#39;
             , YLAB =&gt; &#39;position [cm]&#39;
             , TITLE =&gt; &#39;Mass on Spring&#39;
             );
        # Close the PLplot object to finalize
        $pl-&gt;close;</code></pre>

<p><img width="400" alt="" src="content/book/PLplot/w02.pl.800.png"/></p>

<p><a href="content/book/PLplot/work/w02.pl"> w02.pl text source code</a></p><hr/>

<h2 id="Interactive-crosshairs-with-the-wxwidgets-output-device">Interactive crosshairs with the <code>wxwidgets</code> output device</h2>

<pre><code>        # Create the PLplot object: use wxwidgets for display
        # wxwidgets allows saving to many file types, and
        # has a Locate function under the Plot menu entry
        # providing interactive crosshairs to read individual plot values

        my $pl = PDL::Graphics::PLplot-&gt;new( DEV =&gt; &quot;wxwidgets&quot;);</code></pre>

<p><img width="400" alt="" src="content/book/PLplot/w03.pl.800.png"/></p>

<p><a href="content/book/PLplot/w03.pl"> w03.pl text source code</a></p><hr/>

<h2 id="Setting-the-DEV-and-FILE-options-and-using-the-aliased-option-for-new">Setting the DEV and FILE options, and using the aliased option for new()</h2>

<pre><code>  There are 2 ways to call new(), and the aliased module makes the syntax a bit easier.
  
  The conventional way:
      use PDL::Graphics::PLplot;
      my $pl = PDL::Graphics::PLplot-&gt;new( DEV =&gt; &quot;xwin&quot;);
      
  The aliased way:    
      use aliased &#39;PDL::Graphics::PLplot&#39;; 
      my $pl = PLplot-&gt;new( DEV =&gt; &quot;xwin&quot; );


  Specify the DEV in your call to new. 
      For output to a window:
         -- option DEV must be set to xwin, wxwidgets, or similar
  For output to a file:
         -- option DEV must be set to xfig, svg, pscairo, or similar
         -- option FILE must give the output file&#39;s name
  For output to a memory buffer:
         -- option DEV must be set to mem or memcairo
         --option MEM must be passed an ndarray where the results will be plotted</code></pre>

<h2 id="Outputting-postscript">Outputting postscript</h2>

<pre><code>        # Save the image to a postscript file
        my $pl = PDL::Graphics::PLplot-&gt;new(
               DEV =&gt; &#39;ps&#39;
             , FILE =&gt; &#39;myfile.eps&#39;
        );</code></pre>

<h2 id="Tools-for-plotting-points">Tools for plotting points</h2>

<p>You can plot lines, symbols, or both by using the PLOTTYPE option. You specify error bars in x and y by passing a scalar or an ndarray with those errors to XERRORBAR and YERRORBAR.</p>

<pre><code>   -- PLOTTYPE =&gt; LINE plots data as lines (default)
   -- PLOTTYPE =&gt; POINTS plots data as points
   -- PLOTTYPE =&gt; LINEPOINTS plots data as lines and points
   -- PLplot&#39;s built in error-bars can plot asymmetric error bars,
      but the high-level PDL bindings do not support this.</code></pre>

<p>To set the symbol type and size, use the SYMBOL and SYMBOLSIZE options.</p>

<pre><code>  --  Symbol sizes are measured as multiples of the default size
  -- Symbol sizes can be fractional, such as 0.7 or 4.5
  -- Symbols are identified by their number
 </code></pre>

<h2 id="A-Symbols-example">A <code>Symbols</code> example</h2>

<pre><code>  #!/usr/bin/perl
  use strict;
  use warnings;
  use PDL;
  use PDL::Graphics::PLplot;

  # Generate a time series
  my $time = sequence(100)/10;
  my $sinewave = 5 * sin($time);

  # Save the image to a postscript file

  my $pl = PDL::Graphics::PLplot-&gt;new(
       DEV =&gt; &#39;pscairo&#39;
     , FILE =&gt; &#39;Symbols.eps&#39;
  );

  # Plot the time series as points
  $pl-&gt;xyplot($time, $sinewave
          , PLOTTYPE =&gt; &#39;POINTS&#39;
          , SYMBOL       =&gt; 843
          , YERRORBAR =&gt; grandom($time)/2
     );

  $pl-&gt;close;</code></pre>

<p><img width="400" alt="" src="content/book/PLplot/w04.pl.800.png"/></p>

<p><a href="content/book/PLplot/w04.pl"> w04.pl text source code</a></p><hr/>

<h2 id="Plotting-multiple-curves">Plotting multiple curves</h2>

<p>Depending on what you want, there are at least five ways to plot multiple curves.</p>

<pre><code>    -- plot a multidimensional ndarray
    -- call xyplot multiple times
    -- use stripplots
    -- specify SUBPAGES in the constructor
    -- create insets using the VIEWPORT option</code></pre>

<h3 id="Plotting-multiple-curves-with-a-multi-dimensional-ndarray">Plotting multiple curves with a multi-dimensional ndarray</h3>

<pre><code>   #!/usr/bin/perl
   use strict;
   use warnings;
   use PDL;
   use aliased &#39;PDL::Graphics::PLplot&#39;;

   # Generate a time series
   my $time = sequence(100)/10;
   my $sinewave = 5 * sin($time);
   my $cosinewave = 4 * cos($time);
   my $toplot = cat($sinewave, $cosinewave);

   # Save the image to a postscript file

   my $pl = PLplot-&gt;new(
       DEV =&gt; &#39;pscairo&#39;,
       FILE =&gt; &#39;Multidimensional.eps&#39;
    );


  # Plot the time series
  $pl-&gt;xyplot($time, $toplot);

  $pl-&gt;close;</code></pre>

<p><img width="400" alt="" src="content/book/PLplot/w05.pl.800.png"/></p>

<p><a href="content/book/PLplot/w05.pl"> w05.pl text source code</a></p><hr/>

<h3 id="Colorizing-multiple-data-sets">Colorizing multiple data sets</h3>

<p>Use color to differentiate different data sets:</p>

<pre><code>   -- For multidimensional ndarrays, plot as POINTS and use the
      COLORMAP and PALETTE options.
   -- For multiple calls to xyplot, use POINTS, COLORMAP, and
      PALETTE, or use COLOR option.</code></pre>

<p>The COLORMAP option lets you specify a third value for each (x, y) pair, making it (x, y, colorval).</p>

<p>Which color is associated with the minimum colorval? Which color is associated with the maximum value? All of these are set with the PALETTE.</p>

<p>Valid PALETTEs include:</p>

<pre><code>  RAINBOW - from red to violet through the spectrum
  REVERSERAINBOW - violet through red
  GREYSCALE - from black to white via grey
  REVERSEGREYSCALE - from white to black via grey
  GREENRED - from green to red
  REDGREEN - from red to green</code></pre>

<p>Note:</p>

<pre><code>    --  the default palette is not named
    --  this only works when plotting points, not lines or error bars</code></pre>

<p>A multi-colored multi-curve plot</p>

<pre><code>   #!/usr/bin/perl
   use strict;
   use warnings;
   use PDL;
   use aliased &#39;PDL::Graphics::PLplot&#39;;

   my $pl = PLplot-&gt;new(
     DEV =&gt; &#39;pscairo&#39;,
     FILE =&gt; &#39;Multidimensional2.eps&#39;);

   # Generate a time series and phase offset
   my $time = sequence(100)/10;
   my $phi = zeroes(4)-&gt;xlinvals(0, 3)-&gt;transpose;

   my $sinewaves = 5*sin($time + $phi);
   # Plot the time series and phi color key
   $pl-&gt;xyplot($time, $sinewaves,
     PLOTTYPE =&gt; &#39;POINTS&#39;,
     COLORMAP =&gt; $phi,
     TITLE =&gt; &#39;sin(x + #gf)&#39;);

   $pl-&gt;colorkey($phi, &#39;v&#39;,
      TITLE =&gt; &#39;#gf&#39;,
      VIEWPORT =&gt; [0.93, 0.96, 0.15, 0.85]);
   $pl-&gt;close;</code></pre>

<p><img width="400" alt="" src="content/book/PLplot/w06.pl.800.png"/></p>

<p><a href="content/book/PLplot/w06.pl"> w06.pl text source code</a></p><hr/>

<h3 id="Plotting-multiple-curves-with-differently-colored-calls-to-xyplot">Plotting multiple curves with differently colored calls to <code>xyplot</code></h3>

<p>An alternative to plotting a multi-dimensional ndarray, you can plot multiple curves by multiple calls to xyplot, specifying a different color for each plot.</p>

<p>Legal colors are:</p>

<pre><code>    BLACK       GREEN         WHEAT
    BLUE        RED           AQUAMARINE
    GREY        BLUEVIOLET    YELLOW
    PINK        BROWN         CYAN
    TURQUOISE   MAGENTA       SALMON
    WHITE       ROYALBLUE     DEEPSKYBLUE
    VIOLET      STEELBLUE1    DEEPPINK
    MAGENTA     DARKORCHID1   PALEVIOLETRED2
    TURQUOISE1  LIGHTSEAGREEN SKYBLUE
    FORESTGREEN CHARTREUSE3   GOLD2
    SIENNA1     CORAL         HOTPINK
    LIGHTCORAL  LIGHTPINK1    LIGHTGOLDENROD</code></pre>

<p>Notes:</p>

<pre><code>   --  Curve clipping - the first plot sets the plotting boundaries
        and later plots fall outside of those boundaries
   --  Changing &quot;current&quot; color - the first plot sets the &quot;current&quot;
        color and the second does not specify a color
   --  PLplots has a discrete color limit of 16, including foreground and background color.</code></pre>

<p>When plotting multiple curves, the first plot sets the boundaries, and can result in subsequent plots being clipped. The obvious solution, is to plot your curve with largest values first. To force a separate color from the first set default color, always specify the colors in xyplot.</p>

<h3 id="A-multiple-curve-with-xyplot">A multiple curve with <code>xyplot</code></h3>

<pre><code>  #!/usr/bin/perl
  use strict;
  use warnings;
  use PDL;
  use aliased &#39;PDL::Graphics::PLplot&#39;;

  # Generate a time series
  my $time = sequence(100)/10;
  my $sinewave = 5 * sin($time);
  my $cosinewave = 4 * cos($time);

  # Save the image to a postscript file
  my $pl = PLplot-&gt;new(
        DEV =&gt; &#39;pscairo&#39;, 
        FILE =&gt; &#39;Multiple curves.eps&#39;
   );

  # Plot the sine in black, cosine in red
  $pl-&gt;xyplot($time, $sinewave);
  $pl-&gt;xyplot($time, $cosinewave , COLOR =&gt; &#39;RED&#39;);

  $pl-&gt;close;</code></pre>

<p><img width="400" alt="" src="content/book/PLplot/w07.pl.800.png"/></p>

<p><a href="content/book/PLplot/w07.pl"> w07.pl text source code</a></p><hr/>

<h3 id="Solving-curve-clipping-on-multiple-xyplots-with-the-BOX-option">Solving curve clipping on multiple xyplots with the <code>BOX</code> option</h3>

<p><img width="400" alt="" src="content/book/PLplot/w08a.pl.800.png"/></p>

<p>When you have multiple xyplots, with widely separated values, you can use the <code>xyplot BOX</code> option to prevent clipping.</p>

<pre><code>  #!/usr/bin/perl
  use strict;
  use warnings;
  use PDL;
  use aliased &#39;PDL::Graphics::PLplot&#39;;

  # Generate a time series
  my $time = sequence(100)/10;
  my $sinewave = 5 * sin($time);
  my $cosinewave = 6 * cos($time);

  # Save the image to a postscript file
  my $pl = PLplot-&gt;new(
      DEV =&gt; &#39;pscairo&#39;,
     FILE =&gt; &#39;Multiple curves3.eps&#39;
  );

  # Plot the sine with full bounds
  $pl-&gt;xyplot($time, $sinewave,
      BOX =&gt; [$time-&gt;minmax, $cosinewave-&gt;minmax]);

  # Plot the cosine in red
  $pl-&gt;xyplot($time, $cosinewave , COLOR =&gt; &#39;RED&#39;);

  $pl-&gt;close;</code></pre>

<p><img width="400" alt="" src="content/book/PLplot/w08.pl.800.png"/></p>

<p><a href="content/book/PLplot/w08.pl"> w08.pl text source code</a></p><hr/>

<h3 id="Plotting-multiple-curves-with-stripplot">Plotting multiple curves with <code>stripplot</code></h3>

<pre><code>  #!/usr/bin/perl
  use strict;
  use warnings;
  use PDL;
  use aliased &#39;PDL::Graphics::PLplot&#39;;

  # Save the image to a postscript file
  my $pl = PLplot-&gt;new(
      DEV =&gt; &#39;pscairo&#39;,
      FILE =&gt; &#39;stripplots.eps&#39;
   );

  # Generate a time series
  my $time = sequence(100)/10;

  # Make stripplots with the
  #      different time series
  $pl-&gt;stripplots($time,
       [sin($time), cos($time)],
       XLAB =&gt; &#39;x&#39;,
       YLAB =&gt; [&#39;sine&#39;, &#39;cosine&#39;],
       COLOR =&gt; [&#39;BLUE&#39;, &#39;RED&#39;],
       TITLE =&gt; &#39;Sine and Cosine&#39;
   );

  $pl-&gt;close;</code></pre>

<p><img width="400" alt="" src="content/book/PLplot/w09.pl.800.png"/></p>

<p><a href="content/book/PLplot/w09.pl"> w09.pl text source code</a></p><hr/>

<h3 id="Stripplots-and-reading-DATA-with-rcols">Stripplots and reading <code>DATA</code> with <code>rcols</code></h3>

<pre><code>  #!/usr/bin/perl
  use strict;
  use warnings;
  use PDL;
  use PDL::Graphics::PLplot;

  my ($t, $data) = rcols(*DATA, 0, []);

  my $pl = PDL::Graphics::PLplot-&gt;new( DEV =&gt; &quot;xwin&quot; );

  # Make stripplots with the different time series
  # notice data must be transposed                        
  $pl-&gt;stripplots($t, $data-&gt;transpose);                  
  $pl-&gt;close;                                             
  __DATA__                                                
  #    t      x1     x2     x3            
       1      4      6     -1             
       2      3      9      3             
       3      2      8      7             
       3     -1      4     10
       5      1      2      6             
       6      5     -1      5</code></pre>

<p><img width="400" alt="" src="content/book/PLplot/w10.pl.800.png"/></p>

<p><a href="content/book/PLplot/w10.pl"> w10.pl text source code</a></p><hr/>

<h3 id="Multiple-plots-with-SUBPAGE">Multiple plots with <code>SUBPAGE</code></h3>

<p>When you create your PLplot object, you can carve the canvas into immutable subpages. my $pl = PDL::Graphics::PLplot-&gt;new( # ... , SUBPAGES =&gt; [$nx, $ny] );</p>

<p>For example:</p>

<pre><code>  #!/usr/bin/perl
  use strict;
  use warnings;
  use PDL;
  use aliased &#39;PDL::Graphics::PLplot&#39;;

  # Generate a time series 
  my $time = sequence(100)/10;

  # Save the image to a postscript file
  my $pl = PLplot-&gt;new(
       DEV =&gt; &#39;pscairo&#39;,
       FILE =&gt; &#39;subpages.eps&#39;,
       SUBPAGES =&gt; [2,2]);

  # Plot the time series
  $pl-&gt;xyplot($time, sin($time), TITLE =&gt; &#39;Sine&#39;);

  $pl-&gt;xyplot($time, cos($time), TITLE =&gt; &#39;Cosine&#39;,
            SUBPAGE =&gt; 0);

  $pl-&gt;xyplot($time, tan($time), TITLE =&gt; &#39;Tangent&#39;,
            SUBPAGE =&gt; 4);

  $pl-&gt;xyplot($time, $time**2, TITLE =&gt; &#39;Squared&#39;,
            SUBPAGE =&gt; 3);

  $pl-&gt;close;</code></pre>

<p><img width="400" alt="" src="content/book/PLplot/w11.pl.800.png"/></p>

<p><a href="content/book/PLplot/w11.pl"> w11.pl text source code</a></p><hr/>

<h2 id="Boxes-and-Viewports">Boxes and Viewports</h2>

<h3 id="Using-Insets">Using Insets</h3>

<p>ometimes you want a small inset in one of the corners of your plot. If you ant to do this you should:</p>

<pre><code>  --  Specify the VIEWPORT
  --  Specify the BOX
  --  Use a smaller CHARSIZE
  --  If the underlying plot has a title, you should probably undefine it
  --  Undefine or change the XLAB and YLAB unless you want to use the
        values from the underlying plot


  #!/usr/bin/perl
  use strict;
  use warnings;
  use PDL::Graphics::PLplot; 
  use PDL;
  use PDL::NiceSlice;

  # Generate a noisy time series
  my $time = sequence(1000) /10;
  my $sinewave = 1 * sin($time) + grandom($time) / 3;

  # Save the image to a postscript file
  my $pl = PDL::Graphics::PLplot-&gt;new( DEV =&gt; &#39;pscairo&#39;, FILE =&gt; &#39;inset.eps&#39;);

  # Plot subset as the main plot
  $pl-&gt;xyplot($time(0:65), $sinewave(0:65), TITLE =&gt; &#39;Noisy Pendulum&#39;,
          YLAB =&gt; &#39;Displacement d [m]&#39;, XLAB =&gt; &#39;Time t [s]&#39;);

  # Plot full data set as inset
  $pl-&gt;xyplot($time, $sinewave,
     TITLE       =&gt; undef,
     VIEWPORT =&gt; [0.525, 0.825, 0.525, 0.775],
     BOX         =&gt; [$time-&gt;minmax, $sinewave-&gt;minmax],
     CHARSIZE =&gt; 0.6
    );
  $pl-&gt;close;</code></pre>

<p><img width="400" alt="" src="content/book/PLplot/w12.pl.800.png"/></p>

<p><a href="content/book/PLplot/w12.pl"> w12.pl text source code</a></p><hr/>

<h2 id="Basics-of-viewports">Basics of viewports</h2>

<p>PLplot has three distinct measurements for your plot at any point:</p>

<pre><code>    -- the plotting surface&#39;s dimensions
    -- the viewport&#39;s relative extent
    -- the &quot;natural&quot; coordinates within the viewport</code></pre>

<h2 id="Surface-dimensions">Surface dimensions</h2>

<p>The dimensions of the canvas or surface that you are using can be specified in the constructor (and cannot be changed later):</p>

<pre><code>   my $pl = PDL::Graphics::PLplot-&gt;new(
           # other options...
           PAGESIZE =&gt; [$width, $height]
          # other options...
      );</code></pre>

<p>These are measured either in pixels or milimeters depending on whether the underlying format is a raster or vector format.</p>

<h2 id="Viewport-positioning">Viewport positioning</h2>

<p>The viewport carves out a chunk of space on the canvas for plotting and can be changed with each plotting function.</p>

<pre><code>    $pl-&gt;xyplot($x, $y
             # other options
             , VIEWPORT =&gt; [$xmin, $xmax, $ymin, $ymax]
             # other options
         );
    # Plot on right half of the page
    VIEWPORT =&gt; [0.5, 1, 0, 1]
    # Plot in upper half of the page
    VIEWPORT =&gt; [0, 1, 0, 0.5]
    # Vertically centered, horizontally offset
    VIEWPORT =&gt; [0.5, 0.7, 0.4, 0.6]</code></pre>

<p>Viewport values are fractions of the full page (or sub-page) width all four values should be a number between 0 and 1.</p>

<h3 id="The-clipping-box">The clipping box</h3>

<p>If the viewport indicates the chunk of space you will be graphing on, the clipping box indicates the coordinates within that chunk of space.</p>

<pre><code>    $pl-&gt;xyplot($x, $y
              # other options...
              , BOX =&gt; [$xmin, $xmax, $ymin, $ymax]
              # other options...
         );
   
     # x runs from 0 to 10, y from -8 to 8:
     BOX =&gt; [0, 10, -8, 8]
     # ndarrays have the minmax method:
     BOX =&gt; [$x pdl-&gt;minmax, $y pdl-&gt;minmax]</code></pre>

<p>When plotting using the specified box, a data point near (0, -8) will be plotted near the lower left corner and a data point near (5, 0) will be plotted at the center. Viewports define where plots are drawn. Tick labels, axis labels, and plot titles are drawn outside the viewport.</p>

<h3 id="Page-size">Page size</h3>

<pre><code>  #!/usr/bin/perl
  use strict;
  use warnings;
  use PDL;
  use aliased &#39;PDL::Graphics::PLplot&#39;;

  my $x = zeroes(20)-&gt;xlinvals(-3, 3);
  my $y = $x**2;

  # Set a custom page size
  my $pl = PLplot-&gt;new(
       DEV =&gt; &#39;pscairo&#39;,
       FILE =&gt; &#39;box example 2.eps&#39;,
       BACKGROUND =&gt; &#39;SKYBLUE&#39;,
       PAGESIZE =&gt; [360, 240]
    );

  # Plot a quadratic function:
  $pl-&gt;xyplot($x, $y, YLAB =&gt; &#39;y&#39;, XLAB =&gt; &#39;x&#39;);

  $pl-&gt;close  </code></pre>

<p><img width="400" alt="" src="content/book/PLplot/w13.pl.800.png"/></p>

<p><a href="content/book/PLplot/w13.pl"> w13.pl text source code</a></p><hr/>

<h3 id="Viewport-upper-right">Viewport upper right</h3>

<pre><code>  #!/usr/bin/perl
  use strict;
  use warnings;
  use PDL;
  use aliased &#39;PDL::Graphics::PLplot&#39;;

  my $x = zeroes(20)-&gt;xlinvals(-3, 3);
  my $y = $x**2;

  my $pl = PLplot-&gt;new(
       DEV =&gt; &#39;pscairo&#39;,
       FILE =&gt; &#39;box example 3.eps&#39;,
       BACKGROUND =&gt; &#39;SKYBLUE&#39;
  );

  # Put the plot in the upper right:
  $pl-&gt;xyplot($x, $y,
       YLAB =&gt; &#39;y&#39;,
       XLAB =&gt; &#39;x&#39;,
       VIEWPORT =&gt; [0.5, 0.9, 0.6, 0.8]
       );

  $pl-&gt;close;</code></pre>

<p><img width="400" alt="" src="content/book/PLplot/w14.pl.800.png"/></p>

<p><a href="content/book/PLplot/w14.pl"> w14.pl text source code</a></p><hr/>

<h3 id="Viewport-centered">Viewport centered</h3>

<pre><code>  #!/usr/bin/perl
  use strict;
  use warnings;
  use PDL;
  use aliased &#39;PDL::Graphics::PLplot&#39;;

  my $x = zeroes(20)-&gt;xlinvals(-3, 3);
  my $y = $x**2;
  my $pl = PLplot-&gt;new(
       DEV =&gt; &#39;pscairo&#39;,
       FILE =&gt; &#39;box example 4.eps&#39;,
       BACKGROUND =&gt; &#39;SKYBLUE&#39;
      );

  # Center the plot
  $pl-&gt;xyplot($x, $y,
      YLAB =&gt; &#39;y&#39;, XLAB =&gt; &#39;x&#39;,
      VIEWPORT =&gt; [0.3, 0.7, 0.3, 0.7]
      );

  $pl-&gt;close;</code></pre>

<p><img width="400" alt="" src="content/book/PLplot/w15.pl.800.png"/></p>

<p><a href="content/book/PLplot/w15.pl"> w15.pl text source code</a></p><hr/>

<h3 id="Viewport-extreme-bounds">Viewport extreme bounds</h3>

<pre><code>  #!/usr/bin/perl
  use strict;
  use warnings;
  use PDL;
  use aliased &#39;PDL::Graphics::PLplot&#39;;

  my $x = zeroes(20)-&gt;xlinvals(-3, 3);
  my $y = $x**2;
  my $pl = PLplot-&gt;new(
       DEV =&gt; &#39;pscairo&#39;,
       FILE =&gt; &#39;box example 5.eps&#39;,
       BACKGROUND =&gt; &#39;SKYBLUE&#39;
      );

  # Try extreme bounds for the viewport
  $pl-&gt;xyplot($x, $y ,
       YLAB =&gt; &#39;y&#39;,
       XLAB =&gt; &#39;x&#39;,
       VIEWPORT  =&gt; [0, 1, 0.3, 1]
       );

  $pl-&gt;close;</code></pre>

<p><img width="400" alt="" src="content/book/PLplot/w16.pl.800.png"/></p>

<p><a href="content/book/PLplot/w16.pl"> w16.pl text source code</a></p><hr/>

<h3 id="Viewport-multiple-plots">Viewport multiple plots</h3>

<pre><code>  #!/usr/bin/perl
  use strict;
  use warnings;
  use PDL;
  use aliased &#39;PDL::Graphics::PLplot&#39;;

  my $x = zeroes(20)-&gt;xlinvals(-3, 3);
  my $y = $x**2;
  my $pl = PLplot-&gt;new(
       DEV =&gt; &#39;pscairo&#39;,
       FILE =&gt; &#39;box example 6.eps&#39;,
       BACKGROUND =&gt; &#39;SKYBLUE&#39;);

  # Big plot on left
  $pl-&gt;xyplot($x, $y, VIEWPORT
       =&gt; [0.1, 0.6, 0.1, 0.8]);
  
  # Medium plot on upper right
  $pl-&gt;xyplot($x, $y, VIEWPORT
       =&gt; [0.5, 0.9, 0.6, 0.9]);
  
  # Small plot on lower right
  $pl-&gt;xyplot($x, $y, VIEWPORT
       =&gt; [0.7, 0.9, 0.1, 0.4]);

  $pl-&gt;close;</code></pre>

<p><img width="400" alt="" src="content/book/PLplot/w17.pl.800.png"/></p>

<p><a href="content/book/PLplot/w17.pl"> w17.pl text source code</a></p><hr/>

<h3 id="The-basic-box">The basic box</h3>

<pre><code>  #!/usr/bin/perl
  use strict;
  use warnings;
  use PDL;
  use aliased &#39;PDL::Graphics::PLplot&#39;;

  my $x = zeroes(20)-&gt;xlinvals(-3, 3);
  my $pl = PLplot-&gt;new(
       DEV =&gt; &#39;pscairo&#39;,
       FILE =&gt; &#39;box example 7.eps&#39;,
       BACKGROUND =&gt; &#39;SKYBLUE&#39;);

  # Sine wave on top
  $pl-&gt;xyplot($x, sin($x),
     VIEWPORT =&gt; [0.1, 0.9, 0.55, 0.9]);

  # Quadratic on bottom
  # BOX is inherited from first plot
  $pl-&gt;xyplot($x, $x**2,
     VIEWPORT =&gt; [0.1, 0.9, 0.1, 0.45]);

  $pl-&gt;close;</code></pre>

<p><img width="400" alt="" src="content/book/PLplot/w18.pl.800.png"/></p>

<p><a href="content/book/PLplot/w18.pl"> w18.pl text source code</a></p><hr/>

<h3 id="The-tweaked-box">The tweaked box</h3>

<pre><code>  #!/usr/bin/perl
  use strict;
  use warnings;
  use PDL;
  use aliased &#39;PDL::Graphics::PLplot&#39;;

  my $x = zeroes(20)-&gt;xlinvals(-3, 3);
  my $pl = PLplot-&gt;new(
       DEV =&gt; &#39;pscairo&#39;,
       FILE =&gt; &#39;box example 8.eps&#39;,
       BACKGROUND =&gt; &#39;SKYBLUE&#39;);

  # Sine wave on top
   $pl-&gt;xyplot($x, sin($x),
       VIEWPORT =&gt; [0.1, 0.9, 0.55, 0.9]);

  # Quadratic on bottom
   $pl-&gt;xyplot($x, $x**2,
       VIEWPORT =&gt; [0.1, 0.9, 0.1, 0.45],
       BOX =&gt; [-3, 3, 0, 9]);

  $pl-&gt;close;</code></pre>

<p><img width="400" alt="" src="content/book/PLplot/w19.pl.800.png"/></p>

<p><a href="content/book/PLplot/w19.pl"> w19.pl text source code</a></p><hr/>

<h3 id="Box-with-2-plots">Box with 2 plots</h3>

<pre><code>  #!/usr/bin/perl
  use strict;
  use warnings;
  use PDL;
  use aliased &#39;PDL::Graphics::PLplot&#39;;

  my $x = zeroes(20)-&gt;xlinvals(-3, 3);
  my $pl = PLplot-&gt;new(
       DEV =&gt; &#39;pscairo&#39;,
       FILE =&gt; &#39;box example 9.eps&#39;,
       BACKGROUND =&gt; &#39;SKYBLUE&#39;);

  # Sine wave
  $pl-&gt;xyplot($x, sin($x));

  # Plotting a quadratic on top works
  # but the bounds are not good
  $pl-&gt;xyplot($x, $x**2);

  $pl-&gt;close;</code></pre>

<p><img width="400" alt="" src="content/book/PLplot/w20.pl.800.png"/></p>

<p><a href="content/book/PLplot/w20.pl"> w20.pl text source code</a></p><hr/>

<h3 id="Multiple-plots-changing-the-box-within-a-single-viewport">Multiple plots, changing the box within a single viewport</h3>

<pre><code>  #!/usr/bin/perl
  use strict;
  use warnings;
  use PDL;
  use aliased &#39;PDL::Graphics::PLplot&#39;;

  my $x = zeroes(20)-&gt;xlinvals(-3, 3);
  my $pl = PLplot-&gt;new(
       DEV =&gt; &#39;pscairo&#39;,
       FILE =&gt; &#39;box example 10.eps&#39;,
       BACKGROUND =&gt; &#39;SKYBLUE&#39;);

  # Sine wave
  $pl-&gt;xyplot($x, sin($x));

  # Changing the box for the quadratic
  # does not work - bad y ticks
  $pl-&gt;xyplot($x, $x**2,
       BOX =&gt; [-3, 3, 0, 9]);

  $pl-&gt;close;</code></pre>

<p><img width="400" alt="" src="content/book/PLplot/w21.pl.800.png"/></p>

<p><a href="content/book/PLplot/w21.pl"> w21.pl text source code</a></p><hr/>

<h3 id="Box-and-viewport-summary">Box and viewport summary</h3>

<p>For multiple plots on the same viewport, set the box with the first call to xyplot For non-overlapping plots (on different viewports), specify the box as necessary The viewport specifies the extent of the plotting region; tick labels, axis labels, and titles are drawn outside the viewport</p>

<h2 id="Other-types-of-plot">Other types of plot</h2>

<h3 id="Shadeplot">Shadeplot</h3>

<pre><code>   #!/usr/bin/perl
   use strict;
   use warnings;
   use PDL;
   use aliased &#39;PDL::Graphics::PLplot&#39;;
   my $pl = PLplot-&gt;new(
       DEV =&gt; &#39;pscairo&#39;,
       FILE =&gt; &#39;shadeplot3.eps&#39;);
   # Define z = sin(x) + cos(y), a 2D ndarray:
   my $x=zeroes(51)-&gt;xlinvals(-10, 10);
   my $y=zeroes(51)-&gt;xlinvals(1, 7);
   my $z=sin($x) + cos($y-&gt;transpose);
   # Make a shade plot with 15 color steps:
   $pl-&gt;shadeplot($z, 15,
       BOX =&gt; [$x-&gt;minmax, $y-&gt;minmax],
       XLAB =&gt; &#39;x&#39;, YLAB =&gt; &#39;y&#39;,
       TITLE =&gt; &#39;Egg Carton&#39;);
  # Add a &#39;vertical&#39; color key:
  $pl-&gt;colorkey($z, &#39;v&#39;, VIEWPORT =&gt; [0.93, 0.96, 0.15, 0.85],
           XLAB =&gt; &#39;&#39;, YLAB =&gt; &#39;&#39;, TITLE =&gt; &#39;depth&#39;);
  $pl-&gt;close;</code></pre>

<p><img width="400" alt="" src="content/book/PLplot/w22.pl.800.png"/></p>

<p><a href="content/book/PLplot/w22.pl"> w22.pl text source code</a></p><hr/>

<h3 id="Histogram">Histogram</h3>

<pre><code>   #!/usr/bin/perl
   use strict;
   use warnings;
   use PDL;
   use aliased &#39;PDL::Graphics::PLplot&#39;;
  
   my $pl = PLplot-&gt;new(
       DEV =&gt; &#39;pscairo&#39;,
       FILE =&gt; &#39;histogram.eps&#39;);
  
   # Generate some data:
   my $data = grandom(1000);
  
   # Make a histogram of that data in 20 bins:
   $pl-&gt;histogram($data, 20);
  
   $pl-&gt;close;</code></pre>

<p><img width="400" alt="" src="content/book/PLplot/w23.pl.800.png"/></p>

<p><a href="content/book/PLplot/w23.pl"> w23.pl text source code</a></p><hr/>

<h3 id="Histogram-height">Histogram height</h3>

<pre><code>   #!/usr/bin/perl
   use strict;
   use warnings;
   use PDL;
   use aliased &#39;PDL::Graphics::PLplot&#39;;

   my $pl = PLplot-&gt;new(
       DEV =&gt; &#39;pscairo&#39;,
       FILE =&gt; &#39;histogram2.eps&#39;);

   # Generate some data:
   my $data = grandom(1000);

   # Get approximate binning:
   my $nbins = 20;
   my $binwidth =  ($data-&gt;max-$data-&gt;min) / $nbins;

   my ($x, $y) = hist($data , $data-&gt;minmax, $binwidth);

   # Make a histogram of that data in 20 bins:
   my $fudgefactor = 1.1;

   $pl-&gt;histogram($data, $nbins,
           BOX =&gt; [$x-&gt;minmax, 0, $y-&gt;max * $fudgefactor]);

   $pl-&gt;close;</code></pre>

<p><img width="400" alt="" src="content/book/PLplot/w24.pl.800.png"/></p>

<p><a href="content/book/PLplot/w24.pl"> w24.pl text source code</a></p><hr/>

<h3 id="Bargraph">Bargraph</h3>

<pre><code>   #!/usr/bin/perl
   use strict;
   use warnings;
   use PDL;
   use aliased &#39;PDL::Graphics::PLplot&#39;;
  
   my $pl = PLplot-&gt;new(
       DEV =&gt; &#39;pscairo&#39;,
       FILE =&gt; &#39;bargraph.eps&#39;);
  
   # Generate some data:
   my @colors = qw(red orange yellow green blue purple);
   my $votes = random(scalar(@colors));
  
   # Normalize the votes
   $votes /= $votes-&gt;sum;
  
   # Make a barchart of the votes.
   $pl-&gt;bargraph(\@colors, $votes);
  
   $pl-&gt;close;</code></pre>

<p><img width="400" alt="" src="content/book/PLplot/w25.pl.800.png"/></p>

<p><a href="content/book/PLplot/w25.pl"> w25.pl text source code</a></p><hr/>

<h3 id="Bargraph-color-and-bar-height">Bargraph color and bar height</h3>

<pre><code>   #!/usr/bin/perl
   use strict;
   use warnings;
   use PDL;
   use aliased &#39;PDL::Graphics::PLplot&#39;;
  
   my $pl = PLplot-&gt;new(
       DEV =&gt; &#39;pscairo&#39;,
       FILE =&gt; &#39;bargraph2.eps&#39;);
  
   # Generate some data:
   my @colors = qw(red orange yellow green blue purple);
   my $votes = random(scalar(@colors));
  
   # Normalize the votes
   $votes /= $votes-&gt;sum;
  
   # Make a barchart of the votes.
   $pl-&gt;bargraph(\@colors, $votes,
        COLOR =&gt; &#39;BLUE&#39;,
        BOX =&gt; [0, scalar(@colors), 0, 1.1 * $votes-&gt;max]
     );
  
  $pl-&gt;close;</code></pre>

<p><img width="400" alt="" src="content/book/PLplot/w26.pl.800.png"/></p>

<p><a href="content/book/PLplot/w26.pl"> w26.pl text source code</a></p><hr/>

<h3 id="Bargraph-with-labelling">Bargraph with labelling</h3>

<pre><code>   #!/usr/bin/perl
   use strict;
   use warnings;
   use PDL;
   use aliased &#39;PDL::Graphics::PLplot&#39;;

   my $pl = PLplot-&gt;new(
         DEV =&gt; &#39;pscairo&#39;,
         FILE =&gt; &#39;bargraph3.eps&#39;);

   # voting on letters:
   my @letters = (&#39;a&#39; .. &#39;z&#39;);
   my $votes = random(0 + @letters);

   # Normalize the votes
   $votes /= $votes-&gt;sum;

   # Make a barchart of the votes.
   $pl-&gt;bargraph(\@letters, $votes,
         COLOR =&gt; &#39;LIGHTGOLDENROD&#39;,
         BOX =&gt; [0, scalar(@letters) , 0, 1.1 * $votes-&gt;max],
         MAXBARLABELS =&gt; 10
     );</code></pre>

<p>$pl-&gt;close;</p>

<p><img width="400" alt="" src="content/book/PLplot/w27.pl.800.png"/></p>

<p><a href="content/book/PLplot/w27.pl"> w27.pl text source code</a></p><hr/>

<h2 id="Using-the-MEM-device">Using the MEM device</h2>

<p>Use the MEM device to: -- load an image and plot over that image -- plot to a custom windowing device -- animated plots</p>

<p>The way the MEM device works, is that it needs an RGB or RGBA (RGB with alpha transparency) buffer to write on top of.</p>

<h3 id="Creating-a-MEM-memory-buffer">Creating a <code>MEM</code> memory buffer</h3>

<p>There are 2 drivers which handle the MEM device, mem and memcairo. mem is for plain RGB. memcairo can handle transparency values.</p>

<pre><code>  use PDL;
  ## creating the mem device buffer ##
  
  # the mem device
  # Allocate the buffer for plain rgb
  my $buffer = zeroes(byte, 3, $width, $height);
  
  # Create the PLplot object
  my $pl = PDL::Graphics::PLplot-&gt;new(
                 DEV =&gt; &#39;mem&#39;,
                 MEM =&gt; $buffer
          );                                            
  
  ## For the memcairo device which handles tranparencies ##
  
  # Allocate the buffer                                   
  my $buffer = zeroes(byte, 4, $width, $height);          
  
  # Create the PLplot object
  my $pl = PDL::Graphics::PLplot-&gt;new(
                 DEV =&gt; &#39;memcairo&#39;,
                 MEM =&gt; $buffer
          );</code></pre>

<h3 id="Plotting-over-an-image-with-the-MEM-device">Plotting over an image with the <code>MEM</code> device</h3>

<pre><code>  #!/usr/bin/perl
  use strict;
  use warnings;
  use PDL;
  use aliased &#39;PDL::Graphics::PLplot&#39;;
  use PDL::IO::Pic;

  # Load an image
  # (has dims 3 x width x height)
  my $pic = rpic(&#39;earth.jpg&#39;);


  # Flip the y axis
  $pic = $pic-&gt;slice(&#39;:,:,-1:0:-1&#39;);
  # Whiten the image a bit
  $pic = 127 + $pic / 2;

  my $pl = PLplot-&gt;new( DEV =&gt; &#39;mem&#39;,
                        MEM =&gt; $pic);

  # Plot a quadratic curve over the image
  my $x=zeroes(51)-&gt;xlinvals(-10, 10);
  $pl-&gt;xyplot($x, $x**2);
  $pl-&gt;close;

  # flip the y axis back and save the image
  $pic = $pic-&gt;slice(&#39;:,:,-1:0:-1&#39;);
  wpic($pic, &#39;earth_plot.png&#39;);</code></pre>

<p><img width="400" alt="" src="content/book/PLplot/w29.pl.800.png"/></p>

<p><a href="content/book/PLplot/w29.pl"> w29.pl text source code</a></p><hr/>

<h2 id="Functional-programming-style-examples"><b>Functional programming style examples</b></h2>

<p>This section uses the functional programming style of the original C library examples.</p>

<h3 id="Simple-line-plot-and-multiple-windows-demo-x01">Simple line plot and multiple windows demo x01</h3>

<p><img width="400" alt="" src="content/book/PLplot/x01.pl.800.png"/></p>

<p><a href="content/book/PLplot/x01.pl"> x01.pl text source code</a></p><hr/>

<h3 id="Multiple-window-and-color-map-0-demo-x02">Multiple window and color map 0 demo x02</h3>

<p><img width="400" alt="" src="content/book/PLplot/x02.pl.800.png"/></p>

<p><a href="content/book/PLplot/x02.pl"> x02.pl text source code</a></p><hr/>

<h3 id="Polar-plot-demo-x03">Polar plot demo x03</h3>

<p><img width="400" alt="" src="content/book/PLplot/x03.pl.800.png"/></p>

<p><a href="content/book/PLplot/x03.pl"> x03.pl text source code</a></p><hr/>

<h3 id="Log-plot-demo-x04">Log plot demo x04</h3>

<p><img width="400" alt="" src="content/book/PLplot/x04.pl.800.png"/></p>

<p><a href="content/book/PLplot/x04.pl"> x04.pl text source code</a></p><hr/>

<h3 id="Histogram-demo-x05">Histogram demo x05</h3>

<p><img width="400" alt="" src="content/book/PLplot/x05.pl.800.png"/></p>

<p><a href="content/book/PLplot/x05.pl"> x05.pl text source code</a></p><hr/>

<h3 id="Font-demo-x06">Font demo x06</h3>

<p><img width="400" alt="" src="content/book/PLplot/x06.pl.800.png"/></p>

<p><a href="content/book/PLplot/x06.pl"> x06.pl text source code</a></p><hr/>

<h3 id="Font-demo-x07">Font demo x07</h3>

<p><img width="400" alt="" src="content/book/PLplot/x07.pl.800.png"/></p>

<p><a href="content/book/PLplot/x07.pl"> x07.pl text source code</a></p><hr/>

<h3 id="d-plot-demo-x08">3-d plot demo x08</h3>

<p><img width="400" alt="" src="content/book/PLplot/x08.pl.800.png"/></p>

<p><a href="content/book/PLplot/x08.pl"> x08.pl text source code</a></p><hr/>

<h3 id="Contour-plot-demo-x09">Contour plot demo x09</h3>

<p><img width="400" alt="" src="content/book/PLplot/x09.pl.800.png"/></p>

<p><a href="content/book/PLplot/x09.pl"> x09.pl text source code</a></p><hr/>

<h3 id="Window-positioning-demo-x10">Window positioning demo x10</h3>

<p><img width="400" alt="" src="content/book/PLplot/x10.pl.800.png"/></p>

<p><a href="content/book/PLplot/x10.pl"> x10.pl text source code</a></p><hr/>

<h3 id="Mesh-plot-demo-x11">Mesh plot demo x11</h3>

<p><img width="400" alt="" src="content/book/PLplot/x11.pl.800.png"/></p>

<p><a href="content/book/PLplot/x11.pl"> x11.pl text source code</a></p><hr/>

<h3 id="Bar-chart-demo-x12">Bar chart demo x12</h3>

<p><img width="400" alt="" src="content/book/PLplot/x12.pl.800.png"/></p>

<p><a href="content/book/PLplot/x12.pl"> x12.pl text source code</a></p><hr/>

<h3 id="simple-pie-chart-x13">simple pie chart x13</h3>

<p><img width="400" alt="" src="content/book/PLplot/x13.pl.800.png"/></p>

<p><a href="content/book/PLplot/x13.pl"> x13.pl text source code</a></p><hr/>

<h3 id="Shade-plot-demo-x15">Shade plot demo x15</h3>

<p><img width="400" alt="" src="content/book/PLplot/x15.pl.800.png"/></p>

<p><a href="content/book/PLplot/x15.pl"> x15.pl text source code</a></p><hr/>

<h3 id="plshade-demo-using-color-fill-x16">plshade demo, using color fill x16</h3>

<p><img width="400" alt="" src="content/book/PLplot/x16.pl.800.png"/></p>

<p><a href="content/book/PLplot/x16.pl"> x16.pl text source code</a></p><hr/>

<h3 id="A-simple-stripchart-with-four-pens-x17">A simple stripchart with four pens x17</h3>

<p><img width="400" alt="" src="content/book/PLplot/x17.pl.800.png"/></p>

<p><a href="content/book/PLplot/x17.pl"> x17.pl text source code</a></p><hr/>

<h3 id="d-line-and-point-plot-demo-x18">3-d line and point plot demo x18</h3>

<p><img width="400" alt="" src="content/book/PLplot/x18.pl.800.png"/></p>

<p><a href="content/book/PLplot/x18.pl"> x18.pl text source code</a></p><hr/>

<h3 id="Backdrop-plotting-of-world-US-maps.-x19">Backdrop plotting of world, US maps. x19</h3>

<p><img width="400" alt="" src="content/book/PLplot/x19.pl.800.png"/></p>

<p><a href="content/book/PLplot/x19.pl"> x19.pl text source code</a></p><hr/>

<h3 id="Grid-data-demo-x21">Grid data demo x21</h3>

<p><img width="400" alt="" src="content/book/PLplot/x21.pl.800.png"/></p>

<p><a href="content/book/PLplot/x21.pl"> x21.pl text source code</a></p><hr/>

<h3 id="Simple-vector-plot-x22">Simple vector plot x22</h3>

<p><img width="400" alt="" src="content/book/PLplot/x22.pl.800.png"/></p>

<p><a href="content/book/PLplot/x22.pl"> x22.pl text source code</a></p><hr/>

<h3 id="Displays-Greek-letters-and-mathematically-interesting-Unicode-ranges-x23">Displays Greek letters and mathematically interesting Unicode ranges x23</h3>

<p><img width="400" alt="" src="content/book/PLplot/x23.pl.800.png"/></p>

<p><a href="content/book/PLplot/x23.pl"> x23.pl text source code</a></p><hr/>

<h3 id="Unicode-Pace-Flag-x24">Unicode Pace Flag x24</h3>

<p><img width="400" alt="" src="content/book/PLplot/x24.pl.800.png"/></p>

<p><a href="content/book/PLplot/x24.pl"> x24.pl text source code</a></p><hr/>

<h3 id="Drawing-polygons-x25">Drawing polygons x25</h3>

<p><img width="400" alt="" src="content/book/PLplot/x25.pl.800.png"/></p>

<p><a href="content/book/PLplot/x25.pl"> x25.pl text source code</a></p><hr/>

<h3 id="Frequency-Amplitude-and-Phase-x26">Frequency Amplitude and Phase x26</h3>

<p><img width="400" alt="" src="content/book/PLplot/x26.pl.800.png"/></p>

<p><a href="content/book/PLplot/x26.pl"> x26.pl text source code</a></p><hr/>

<h3 id="Spirograph-curves---epitrochoids-cycolids-roulettes-x27">Spirograph curves - epitrochoids, cycolids, roulettes x27</h3>

<p><img width="400" alt="" src="content/book/PLplot/x27.pl.800.png"/></p>

<p><a href="content/book/PLplot/x27.pl"> x27.pl text source code</a></p><hr/>

<h3 id="plmtex3-plptex3-demo-x28">plmtex3, plptex3 demo x28</h3>

<p><img width="400" alt="" src="content/book/PLplot/x28.pl.800.png"/></p>

<p><a href="content/book/PLplot/x28.pl"> x28.pl text source code</a></p><hr/>

<h3 id="Plots-using-date-time-formatting-for-axes-x29">Plots using date / time formatting for axes x29</h3>

<p><img width="400" alt="" src="content/book/PLplot/x29.pl.800.png"/></p>

<p><a href="content/book/PLplot/x29.pl"> x29.pl text source code</a></p><hr/>

<h3 id="Alpha-color-values-demonstration-x30">Alpha color values demonstration x30</h3>

<p><img width="400" alt="" src="content/book/PLplot/x30.pl.800.png"/></p>

<p><a href="content/book/PLplot/x30.pl"> x30.pl text source code</a></p><hr/>

<h3 id="Using-pllegend-including-unicode-symbols-x33">Using <code>pllegend</code> including unicode symbols x33</h3>

<p><img width="400" alt="" src="content/book/PLplot/x33.pl.800.png"/></p>

<p><a href="content/book/PLplot/x33.pl"> x33.pl text source code</a></p><hr/>

<h2 id="Typesetting-greek-letters-symbols">Typesetting, greek letters, symbols</h2>

<p>Use escape sequences to insert superscripts, subscripts, Greek letters, etc. Unicode is supported.</p>

<pre><code>    #u - superscript until the next #d
    #d - subscript until the next #u
    #- - toggle underline mode
    #+ - toggle overline mode
    #fn - switch to normal (sans-serif) font
    #fr - switch to Roman (serif) font
    #fi - switch to italic font
    #fs - switch to script font

   # Use greek symbol rho for density:
       $pl-&gt;xyplot($radius, $density, 
       YLAB =&gt; &#39;density #gr&#39;
        # ...
       );</code></pre>

<p><img width="400" alt="" src="content/book/PLplot/w30a.pl.800.png"/></p><hr/>

<h3 id="A-basic-typsetting-example">A basic typsetting example</h3>

<pre><code>  #!/usr/bin/perl
  use strict;
  use warnings;
  use PDL;
  use aliased &#39;PDL::Graphics::PLplot&#39;;

  # Generate a time series
  my $time = sequence(100)/10;
  my $sinewave = 5 * sin($time);

  # Create the PLplot object:
  my $pl = PLplot-&gt;new(
        DEV =&gt; &#39;pscairo&#39;,
        FILE =&gt; &#39;Typesetting.eps&#39;);

  # Plot the time series
  $pl-&gt;xyplot($time, $sinewave,
        XLAB =&gt; &#39;#fi time #fn [Hz#u-1#d]&#39;,
        YLAB =&gt; &#39;#fiposition#fn [cm]&#39;,
        TITLE =&gt; &#39;#frMass on Spring&#39;
      );

  # Close the PLplot object to finalize
  $pl-&gt;close;</code></pre>

<p><img width="400" alt="" src="content/book/PLplot/w30.pl.800.png"/></p>

<p><a href="content/book/PLplot/w30.pl"> w30.pl text source code</a></p><hr/>

<h3 id="psfrag">psfrag</h3>

<p>For LATEX typsetting, post-process eps images with psfrag.</p>

<pre><code>   --  replaces simple strings with any valid LATEX text.
   --  ensures consistent fonts for both images and documents
   --  Do not use the pscairo device. Use ps or psc.</code></pre>

<h2 id="annotations-and-TEXTPOSITION">annotations and TEXTPOSITION</h2>

<p>To add text to a plot, use the text method, specifying the TEXTPOSITION option. The TEXTPOSITION takes either four or five arguments. The four-argument form places text outside the viewport along one of its edges:</p>

<pre><code>   $pl-&gt;text($string, TEXTPOSITION =&gt; [$side, $disp, $pos, $just]);</code></pre>

<p>$side is one of &#39;t&#39;, &#39;b&#39;, &#39;l&#39;, or &#39;r&#39; indicating the top, bottom, left, or right edge</p>

<p>$disp is the number of character heights out from the edge</p>

<p>$pos is the position of the string&#39;s reference point along the edge of the viewport, from 0 to 1</p>

<p>$just indicates the location of the reference point of the string.</p>

<p>0 means the reference point is the string&#39;s left edge; 1 indicates the right edge</p>

<p>The five-argument form places the text within the viewport at an arbitrary position and slope:</p>

<pre><code>  $pl-&gt;text($string, TEXTPOSITION =&gt; [$x, $y, $dx, $dy, $just]);</code></pre>

<p>$x, $y are the location of the string&#39;s reference point within the clipping box</p>

<p>$dx, $dy together indicate the slope along which the text is drawn</p>

<p>$just indicates the location of the reference point of the string.</p>

<p>0 means the reference point is the string&#39;s left edge; 1 indicates the right edge</p>

<h3 id="TEXTPOSITION-3-argument-form">TEXTPOSITION 3 argument form</h3>

<pre><code>  #!/usr/bin/perl
  use strict;
  use warnings;
  use PDL;
  use aliased &#39;PDL::Graphics::PLplot&#39;;

  my $pl = PLplot-&gt;new(
           DEV =&gt; &#39;pscairo&#39;,
           FILE =&gt; &#39;text1.eps&#39;);

  my $x = zeroes(100)-&gt;xlinvals(-3,3);
  my $y = $x**2;
  $pl-&gt;xyplot($x, $y);

  $pl-&gt;setparm(CHARSIZE =&gt; 1.2);
  # x label on the lower right
  $pl-&gt;text(&#39;Position x [m]&#39;,
           TEXTPOSITION =&gt; [&#39;b&#39;, 3, 1, 1]);

  # y label on the upper left
  $pl-&gt;text(&#39;Potential Energy V [J]&#39;,
           TEXTPOSITION =&gt; [&#39;l&#39;, 3.5, 1, 1]);

  # title at the center top
  $pl-&gt;text(&#39;Harmonic Oscillator&#39;,
           CHARSIZE =&gt; 2.5,
           TEXTPOSITION =&gt; [&#39;t&#39;, 1.5, 0.5, 0.5]);

  $pl-&gt;close;</code></pre>

<p><img width="400" alt="" src="content/book/PLplot/w31.pl.800.png"/></p>

<p><a href="content/book/PLplot/w31.pl"> w31.pl text source code</a></p><hr/>

<h3 id="TEXTPOSITION-4-argument-form">TEXTPOSITION 4 argument form</h3>

<pre><code>  #!/usr/bin/perl
  use strict;
  use warnings;
  use PDL;
  use aliased &#39;PDL::Graphics::PLplot&#39;;

  my $pl = PLplot-&gt;new(
         DEV =&gt; &#39;pscairo&#39;,
         FILE =&gt; &#39;text2.eps&#39;);

  # Plot a quadratic
  my $x = zeroes(100)-&gt;xlinvals(-3,3);
  my $y = $x**2;

  $pl-&gt;xyplot($x, $y, TITLE =&gt; &#39;SHO&#39;,
         XLAB =&gt; &#39;Position x [m]&#39;,
         YLAB =&gt; &#39;Potential V [J]&#39;);

  # annotate negative slope at (-2, 4)
  $pl-&gt;text(&#39;Slope is negative&#39;,
           TEXTPOSITION =&gt; [-1.8, 4.1, 1, -4, 0.5]);

  # annotate positive slope at (2, 4)
  $pl-&gt;text(&#39;Slope is positive&#39;,
           TEXTPOSITION =&gt; [1.9, 3.9, 10, 40, 1]);

  $pl-&gt;close;</code></pre>

<p><img width="400" alt="" src="content/book/PLplot/w32.pl.800.png"/></p>

<p><a href="content/book/PLplot/w32.pl"> w32.pl text source code</a></p><hr/>

<h2 id="Legends">Legends</h2>

<p>PLplot does not have a command to create legends. We must make them ourselves. Legends are only necessary when plotting discrete data sets. If possible, use color keys instead of constructing legends by hand.</p>

<pre><code>  #!/usr/bin/perl
  use strict;
  use warnings;
  use PDL;
  use PDL::Graphics::PLplot;

  my $pl = PDL::Graphics::PLplot-&gt;new(
                DEV =&gt; &#39;pscairo&#39;,
                FILE =&gt; &#39;legend.eps&#39;);


  my $x = zeroes(100)-&gt;xlinvals(-1.2, 1.2);
  my @colors = qw(BLACK GREEN BLUE);
  my @labels = qw(Linear Quadratic Cubic);
  my $legend_x = pdl(0.3, 0.5);
  my $legend_y = -0.5;

  # Plot linear, quadratic, and cubic curves with a legend
   for my $i (0..2) {

   $pl-&gt;xyplot($x, $x**($i+1), COLOR =&gt; $colors[$i]);

   $pl-&gt;xyplot($legend_x, pdl($legend_y, $legend_y),
           COLOR =&gt; $colors[$i]);

   $pl-&gt;text($labels[$i], COLOR =&gt; &#39;BLACK&#39;,
           TEXTPOSITION =&gt; [0.6, $legend_y, 1, 0, 0]);

   $legend_y -= 0.2;
  }</code></pre>

<p>$pl-&gt;close;</p>

<p><img width="400" alt="" src="content/book/PLplot/w33.pl.800.png"/></p>

<p><a href="content/book/PLplot/w33.pl"> w33.pl text source code</a></p><hr/>

<h1 id="D-Graphics-with-OpenGL">3D Graphics with OpenGL</h1>

<h2 id="Introduction">Introduction</h2>

<p> <img width="300" alt="" src="content/book/graphics_3d/gnuplot-eg.png"/></p>

<pre><code> Figure 3.1: A 3D surface graph plotted using gnuplot,
 using the commands:
 
 set isosamples 30; splot [0:7] [0:7] sin(x)*sin(y). </code></pre>

<p>There are lots of programs that let you plot so-called 3D surface graphs, such as the one shown in Fig. 3.1. However, from the beginning, PDL&#39;s 3D graphics have had something different that we feel is really useful: motion, or as we call it &quot;twiddling&quot;. Dragging the 3D image with the mouse rotates the image, at the speed allowed by your display hardware. This turned out to be quite useful for displaying functions: the human eye is able to grasp the presented 3D surface much better when it moves, especially in response to the mouse.</p>

<p> <img width="200" alt="" src="content/book/graphics_3d/pdltrid-eg1.png"/></p>

<p> <img width="200" alt="" src="content/book/graphics_3d/pdltrid-eg2.png"/></p>

<pre><code> Figure 3.2: The same 3D surface, plotted using the
 PDL::TriD module. The two different images were obtained
 literally by grabbing the image in the window opened by
 PDL and dragging it with the mouse to rotate. </code></pre>

<p>Let&#39;s start with plotting the surface we showed using gnuplot in the beginning:</p>

<pre><code>  pdl&gt; use PDL::Graphics::TriD;
  pdl&gt; $x = xlinvals(zeroes(30), 0, 7);
  pdl&gt; imag3d [ sin($x) * sin($x-&gt;dummy(0)) ];</code></pre>

<p>This should produce a new window with the image seen in Figure 3.2. Notice that your console window is now frozen: it is waiting for you to twiddle in the graphics window using the mouse and to press <code>q</code> in that window once you&#39;re done.</p>

<p>If the above commands produce an error instead of a new window, it might be that your PDL wasn&#39;t compiled with the option to include the 3D graphics library. (See the Perl Data Language web site at <a href="http://pdl.perl.org">http://pdl.perl.org</a> for information on installing and using PDL.)</p>

<p>That above expression is a bit more difficult than the gnuplot version, and there&#39;s a simple reason for that: gnuplot is primarily meant for plotting functions; PDL is meant for handling and plotting numerical data. So to plot a function, we have to create the data for the function first which is a bit more difficult.</p>

<p>Now let&#39;s go through that part by part.</p>

<pre><code>  pdl&gt; use PDL::Graphics::TriD;</code></pre>

<p>The first line simply tells Perl to load the PDL::Graphics::TriD module. The name comes from the fact that you can&#39;t have parts of module names starting with numbers, unfortunately. The second line</p>

<pre><code>  pdl&gt; $x = xlinvals(zeroes(30), 0, 7);</code></pre>

<p>creates a one-dimensional ndarray with 30 elements that has linear values from 0 to 7:</p>

<pre><code>  pdl&gt; p $x
  [0 0.24137931 0.48275862 0.72413793 0.96551724.....</code></pre>

<p>The <code>xlinvals</code> and the corresponding <code>ylinvals</code> and <code>zlinvals</code> are useful for exactly this purpose: creating ndarrays of equally spaced values. The final line,</p>

<pre><code>  pdl&gt; imag3d [ sin($x) * sin($x-&gt;dummy(0)) ];</code></pre>

<p>is what draws the actual image. The expression inside, uses the variable <code>$x</code> for both the X and Y coordinates, via a clever use of the dummy operation. (See chapter [chap_slice] for some explanation). This results in a 2-dimensional ndarray with the values for the Z coordinate. So far you&#39;ve already seen all this. And the final part, <code>imag3d [vals]</code> is the call that creates the 3D plot and opens the new window for it. The brackets around the parameter may be slightly surprising: the 2-D commands work well without those but there is a good reason for this, as you&#39;ll learn later on: otherwise there would be a bad ambiguity.</p>

<h2 id="Parametric-Graphics">Parametric Graphics</h2>

<p>We alluded in the introduction that allowing</p>

<pre><code>  pdl&gt; imag3d $ndarray;</code></pre>

<p>could be ambiguous and should be written</p>

<pre><code>  pdl&gt; imag3d [$ndarray];</code></pre>

<p>if <code>$ndarray</code> is intended to be the Z axis values of a rectangular 2D plot. Now is the time to find out why. The simple truth is that</p>

<pre><code>  pdl&gt; imag3d $ndarray;</code></pre>

<p>is in fact legal code---if and only if the first dimension of <code>$ndarray</code> has exactly three elements. As you probably have already guessed, these three elements are X, Y and Z. So what you can do is pass <code>$ndarray</code> with shape <code>[3,t,u]</code> which is the same as a 2-dimensional <code>[t,u]</code> lattice with a 3-vector at each point. This ndarray will then be interpreted parametrically: the mesh will be drawn as a function of <code>$t</code> and <code>$u</code>.</p>

<p>Let&#39;s have an example: a curve that is not possible to plot with just Z axis values, say the surface of a torus, with colors coming from somewhere. First, set up the ndarrays and the parameter variables:</p>

<pre><code>   use PDL;
   use PDL::Graphics::TriD;
   use PDL::NiceSlice;
   
   $torus = zeroes(3, 60, 20);
   
   $x = $torus((0));
   $y = $torus((1));
   $z = $torus((2));
   
   $t = xlinvals $x, 0, 6.28;
   $u = ylinvals $x, 0, 6.28;</code></pre>

<p>Note that the coordinate separation can be done in just one line:</p>

<pre><code>   ($x, $y, $z) = map { $torus(($_)) } 0..2;</code></pre>

<p>Next, we color the torus. Let&#39;s put stripes on it:</p>

<pre><code>   $r = (1 + sin(2*$t +   $u))/2;
   $g = (1 + cos(2*$t + 2*$u))/2;
   $b = (1 + sin(2*$t + 3*$u))/2;</code></pre>

<p>Then, we choose the outer and inner radii and put the coordinates into the slices. We&#39;ll let the torus lie in the XY plane so the parametric coordinates can be easily derived.</p>

<pre><code>   $r_o = 3;
   $r_i = 1;
   $x .= ($r_o + $r_i * sin($u)) * sin($t) ;
   $y .= ($r_o + $r_i * sin($u)) * cos($t);
   $z .=         $r_i * cos($u);
   imag3d_ns $torus, [$r, $g, $b];</code></pre>

<p>And here&#39;s our colorful torus!</p>

<p> <img width="300" alt="" src="content/book/graphics_3d/color-torus.png"/></p>

<p>It looks a bit more like a barrel because TriD automatically scales the axes but there it is. Note how we use <code>imag3d_ns</code> to get the colors instead of the shaded version.</p>

<p>Now, there is more than one way to do it. If your data is not by default in the three-vector format (as ours wasn&#39;t above), it is probably easier to do</p>

<pre><code>   imag3d_ns [$x, $y, $z], [$r, $g, $b];</code></pre>

<p>which will produce the same results. Also, we could concatenate the RGB ndarrays to form a single <code>[3,60,20]</code> ndarray that could be used without square brackets:</p>

<pre><code>   $rgb = cat($r,$g,$b)-&gt;mv(-1,0);  # $rgb is [3,60,20]
   imag3d_ns $torus, $rgb;</code></pre>

<p>Now, since PDL does its best to make dimensions usable anywhere, we can easily plot several parametrics of the same parameters at once, if we pack all the surfaces into an ndarray of shape <code>[3,n_t,n_u,...]</code> where the three periods in the end indicate the beginning of the extra parameters.</p>

<p>For example, we can plot a family of shrinking toruses by adding an extra dimension into <code>$torus</code>:</p>

<pre><code>   $cone = $torus-&gt;dummy(3, 4)-&gt;copy();
   $fac = axisvals($cone, 3);
   $cone *= $fac + 2;
   $cone(2) += 4 * $fac;
   imag3d $cone;</code></pre>

<p> <img width="300" alt="" src="content/book/graphics_3d/torus-stack.png"/></p>

<p>And further, if we want to distort them, it&#39;s perfectly possible:</p>

<pre><code>   $x = $cone(0);
   $cone(2) += 0.1 * $x ** 2;
   imag3d $cone;</code></pre>

<p> <img width="300" alt="" src="content/book/graphics_3d/torus-stack-warp.png"/></p>

<p>Any other kind of mutilation is also possible but we leave you to discovering the interesting things that are possible by yourself, because we have to move to something else that&#39;s important to cover: coordinate systems. So far, all the examples you&#39;ve seen have happened in the Euclidean coordinate system where the coordinates are specified as measures X, Y and Z on three orthogonal axes.</p>

<p>Or actually this is not true: in fact, we have used two kinds of coordinates, the explicit X, Y and Z given in this section but in the preceding sections, only Z has been given and X and Y have been assumed by the system from the context.</p>

<p>Of course, since PDL tries to follow &quot;simple things simple, complicated things possible&quot;, it is possible to override the default context.</p>

<h2 id="Types-of-3D-Graphical-Objects">Types of 3D Graphical Objects</h2>

<p>So far, we&#39;ve only been toying with surfaces. However, PDL can do much more. We can plot points; here&#39;s a picture of two samples from different (overlapping) probability distributions, plotted with different colors:</p>

<pre><code>   use PDL::Graphics::TriD;
   
   $i = zeroes(8000);
   $which = random($i) &lt; 0.5;
   $x = grandom($i) * (1   + $which);
   $y = grandom($i) * (0.5 + $which);
   $z = grandom($i) * (2   - $which);
   $x += $which * $y; $y += $which * $z; # Make it oblique
   points3d [$x, $y, $z], [$which, 0.5*(1-$which), 1-$which];</code></pre>

<p>And the result:</p>

<p> <img width="300" alt="" src="content/book/graphics_3d/two-prob-distributions.png"/></p>

<p>A lot of fun things can be done with points but we&#39;ll go into that later.</p>

<p>Then, there are---of course---lines. As a fun demo of lines, let&#39;s plot a number of flow lines moving in the Lorenz attractor. As you may know, the Lorenz attractor is described by</p>

<pre><code>  dx                        
  --    =    sigma (y - x)  
  dt                        
                            
  dy                        
  --    =    (r - z) x  -  y
  dt                        
                            
  dz                        
  --    =    (y - b) z      
  dt                        </code></pre>

<p>where sigma=10, r=28 and b=8/3. Because we&#39;re just doing this as a simple demo, we&#39;ll use the extremely unstable d=Delta method integration. We&#39;ll plot six trajectories that start close to each other.</p>

<pre><code>   use PDL::Graphics::TriD;
   $n = 500;
   $nstart = 0;
   $nc = 6;
   $delta = 0.015;
   # $x = pdl(1, 1, 1, 1, 1);
   # $y = pdl(1, 1, 1, 1, 1);
   # $z = pdl(1, 1.01, 1.02, 1.03, 1.04);
   $xs = zeroes($n, $nc);
   $ys = zeroes($n, $nc);
   $zs = zeroes($n, $nc);
   $x = -23 * ones($nc);
   $y = -2 * ones($nc);
   $z = 20 * ones($nc) + 0.02 * xvals($nc);
   $sigma = 10; $r = 28; $b = 8.0/3.0;
   for (-$nstart..$n-1) {
      if($_ &gt;= 0) {
         $xs(($_)) .= $x;
         $ys(($_)) .= $y;
         $zs(($_)) .= $z;
      }
      $dx = $sigma * ($y - $x);
      $dy = ($r - $z)*$x - $y;
      $dz = $x*$y - $b * $z;
   
      $x += $delta * $dx;
      $y += $delta * $dy;
      $z += $delta * $dz;
   }
   $col = yvals(1, $nc) / ($nc-1);
   $tim = xvals($n) / ($n-1);
   line3d [$xs, $ys, $zs], [$col, $tim , 1-$col];</code></pre>

<p> <img width="300" alt="" src="content/book/graphics_3d/busy-lorenz-attr.png"/></p>

<pre><code>  Figure: Busy Lorenz Attractor</code></pre>

<p>Unfortunately, this plot has too much stuff going on so it&#39;s difficult to see where the functions diverge even though they have different colors at different times. This is an excellent time to change variables: let&#39;s get rid of X and plot the time step instead:</p>

<pre><code>   line3d [$tim, $ys, $zs], [$col, $tim , 1-$col];</code></pre>

<p>This yields a much clearer plot of the chaotic behavior when the lines diverge with time.</p>

<p> <img width="300" alt="" src="content/book/graphics_3d/timeseries-lorenz.png"/></p>

<p>In the latest versions of PDL it is possible to adjust the line width as well:</p>

<pre><code>   line3d [$tim, $ys, $zs], [$col, $tim , 1-$col], {LineWidth =&gt; 10}</code></pre>

<p>gives the same plot but with much thicker lines.</p>

<p> <img width="300" alt="" src="content/book/graphics_3d/timeseries-lorenz-thick.png"/></p>

<p>The basic rectangular surface you already saw in the preceding sections. It also has an option to turn off the lines. There is also a command <code>mesh3d</code> similar to the <code>imag3d</code> surface which just draws the surface as a wire mesh instead of a solid surface. On slow machines this can be of great help.</p>

<p>Finally, there are two commands for quickly painting strictly rectangular true color images: <code>imagrgb</code> and <code>imagrgb3d</code>. This can be demonstrated by Tuomas J. Lukka&#39;s 4-liner:</p>

<pre><code>   use PDL; use PDL::Graphics::TriD;$a=zeroes 300,300;$r=$a-&gt;xlinvals(-1.5,
   0.5);$i=$a-&gt;ylinvals(-1,1);$t=$r;$u=$i;for(1..30){$q=$r**2-$i**2+$t;$h=2
   *$r*$i+$u;$d=$r**2+$i**2;$a=lclip($a,$_*($d&gt;2.0)*($a==0));($r,$i)=map{$_
   -&gt;clip(-5,5)}($q,$h);}imagrgb[$a/30];</code></pre>

<p>This, as odd as it may sound, plots a grayscale Mandelbrot. If you work your way through the code, you&#39;ll see that it simply iterates the standard Mandelbrot iteration formula</p>

<pre><code>     z &lt;-- z**2 + C     </code></pre>

<p>where <code>C</code> is the original point. Then it uses <code>lclip</code> to keep the numbers in a reasonable range and colors the points according to the iteration when the point crossed the distance <code>sqrt(2)</code> from the origin. The ndarray <code>$a</code> is two-dimensional so just like for coordinates, it is enclosed in an array ref. It is also possible to use</p>

<pre><code>   imag3gb [$r, $g, $b];
   imag3gb $colors;</code></pre>

<p>where the RGB ndarrays are two-dimensional and <code>$colors</code> has three dimensions, the first of which is of length three.</p>

<p>The command <code>imagrgb3d</code> does the same but allows the user to place the rectangle anywhere in 3-space. This is useful e.g. for putting an image underneath a plotted surface of the same function, as we shall see in the next section.</p>

<h2 id="More-than-one-Image">More than one Image</h2>

<p>If you have used the PDL PGPLOT interface for plotting multiple graphs then TriD is not going to surprise you: the commands <code>hold3d</code> and <code>release3d</code> work just like their PGPLOT counterparts. Before going further, however, let me remind you that for many plots, it is not necessary to explicitly plot several points, lines, surfaces or whatever: it can be easier just to use extra dimensions, like we used for the torus cone in the first section.</p>

<p>However, if you want to put objects of more than one type, or objects of more than one resolution on the same graph, then you do need to do so explicitly. As an example we&#39;ll use some fractal mountain code by Tuomas J. Lukka from the 3D Gallery. Unlike with the Mandelbrot that has a well-known algorithm, this code we&#39;d just better format clearly from the start (the parameters have also been slightly modified and the code has been modified to plot all the iterations on top of each other).</p>

<pre><code>   use PDL; # XXX FIX - LOOKS BAD.
   use PDL::Image2D;
   use PDL::Graphics::TriD;
   $k = ones(3,3) / 9;
   $a = 20;
   $b = $a*(random(2,2)-0.5);
   hold3d(); # Set the coordinate system: XXX hack!!! FIX TriD
   line3d pdl([[0, 0, 0,], [0, 0, 10]]);
   for (0..4) {
      if ($_ != 0) {
         $c = $b-&gt;dummy(0,2)-&gt;clump(2)-&gt;xchg(0,1)-&gt;
                   dummy(0,2)-&gt;clump(2)-&gt;xchg(0,1)-&gt;copy;
         $c += $a*($c-&gt;random-0.5);
         $a /= 1.5;
         $b = conv2d($c,$k);
      }
      imag3d [xlinvals($b,0,1), ylinvals($b,0,1), $b + 2.0*$_], {Lines =&gt; 0};
   }
   release3d();</code></pre>

<p>Even laid out bare, this code is a mouthful with that big double dummy-clump-xchg thing in the middle. But in fact the function is really simple: the dummy-clump-xchg thing simply doubles the length of each dimension, copying each value to two consecutive locations. After doubling the resolution, we add some noise from the random function (the magnitude of the noise is diminished each time). Finally, we pull in PDL::Image2D for the <code>conv2d</code> routine that does 2-dimensional convolutions (optimized for small kernels like ours). We use a 5x5 kernel to smooth our data at each step by convolution. That&#39;s the numerical part, now here is the sequence of images created:</p>

<p> <img width="400" alt="" src="content/book/graphics_3d/fractal-mountain-sequence.png"/></p>

<h2 id="Putting-it-all-together---cool-hacks">Putting it all together---cool hacks</h2>

<p>Here&#39;s one where the original idea is by Robin Williams, done for the 3D Gallery. This gallery is available in the PDL distribution in the file Demos/TriDGallery.pm. The idea is to put interesting scripts that do a lot using just 4 lines of 72 characters. The crux of the idea is to use OpenGL points to perform volume-like rendering. This is just a quick hack. However, the principles are interesting enough that we thought you might enjoy them. Let&#39;s start with a function of three variables, whose zeroes are a sphere and an ellipsoid inside the sphere, with the Y axis slightly distorted to form a parabola with the Z axis:</p>

<pre><code>   sub f {
      my($x, $y, $z) = @_;
      $y = $y + 0.04 * $z**2;
      return (($x**2 + $y**2 + $z**2) - 100) *
             ((2*$x**2 + 4*$y**2 + 4*$z**2) - 100);
   }</code></pre>

<p>Note here that we can&#39;t use the += operator for <code>$y</code> since below we use the same ndarray for the three coordinates (with a simple dummy transformation). Now, we want to picture approximately where the function crosses zero, but since there are two separate zero surfaces we can&#39;t just use an algorithm that finds a zero and creates an isosurface. Besides, an isosurface renderer wouldn&#39;t be able to show both the sphere and the ellipsoid simultaneously. So rather, let&#39;s first calculate the sign of the function in a 50x50x50 lattice. The radius of the sphere is <code>sqrt(100)=10</code> so we make the coordinate system slightly larger.</p>

<pre><code>   use PDL::Graphics::TriD;
   $x = xlinvals(zeroes(float,50), -11, 11);
   $f = f($x, $x-&gt;dummy(0), $x-&gt;dummy(0)-&gt;dummy(0));
   $sign = byte($f&gt;0);</code></pre>

<p>Now that we have the sign, why don&#39;t we simply find the set of points where the sign has changed. It is simplest to do this over just one dimension:</p>

<pre><code>   $df = ($sign(0:-2) != $sign(1:-1));
   points3d whichND($df);  # for PDL-2.4.10</code></pre>

<p>And indeed, we get a rotatable set of points in 3-space that are in the shape of a sphere with an ellipsoid inside, slightly distorted, just as ordered.</p>

<p> <img width="400" alt="" src="content/book/graphics_3d/nest-sphere-01.png"/></p>

<p>This is not yet a good picture: there is a hole in the point set where the surface is parallel to the X axis, naturally, since there there is no difference between the sigh between the points next to each other on X axis.</p>

<p><b>NOTE</b>: For PDL-2.4.9 and earlier, you&#39;ll need to use <code>points3d [ whichND($df) ];</code> since previous to PDL-2.4.10 <code>whichND</code> returned a list of ndarrays in list context. That behavior is now deprecated.</p>

<p>To do a more complete job, we need to compare the signs not only along X but other dimensions as well. This is possible due to the wonderful invention by Robin Williams:</p>

<pre><code>   $a = $sign;
   foreach (1,2,4) {
      $t=($a(0:-2)&lt;&lt;$_);
      $t+=$a(1:-1);
      $a=$t-&gt;mv(0,2);
   }
   points3d [whichND(($a != 0) &amp; ($a != 255))];</code></pre>

<p>It&#39;s a bit cryptic but truly beautiful so bear with us while we go through it. The loop is executed thrice, once for each dimension. In the beginning, we know that all the values in <code>$a</code> are either 0 or 1. The first line of the loop takes a slice from <code>$a</code>, leaving the last element of dimension one out and shifts if by the loop index <code>$_</code>. The second line takes another slice, this time leaving out the first element and adds it to the first. Finally, the dimensions are rotated for the next invocation.</p>

<p>Choosing the shifts to be 1,2,4 is the key: this way after the first round, the ndarray contains values 0,1,2,3 after the second it contains 0...15 and after the third, 0..255. None of the shifts shift anything on top of each other so the plus operation could be replaced with a bitwise or.</p>

<p>So after the loop, we have a three-dimensional ndarray with one index less in each dimension, and each value in that ndarray contains in its 8 bits the 8 corners of a small cube. Finally, to find whether the function crosses zero at that cube, we simply check whether all the bits are equal, i.e. whether the number is 255 or 0 and if it isn&#39;t we know the function changes sign.</p>

<p> <img width="400" alt="" src="content/book/graphics_3d/nest-sphere-02.png"/></p>

<p>The image quality can be slightly improved by removing the Moire effect through randomization:</p>

<pre><code>   points3d (map {$_+$_-&gt;float-&gt;random} whichND(($a != 0) &amp; ($a != 255)))</code></pre>

<p> <img width="400" alt="" src="content/book/graphics_3d/nest-sphere-moire.png"/></p>

<p>Now, to further improve image quality we could add different-color pixels but that would require alpha blending to the OpenGL parameters and this would get into complications we don&#39;t necessarily want here. So now we&#39;re going to KISS* this topic away and move to the next one.</p>

<pre><code>   * Keep It Simple, Stupid</code></pre>

<h1 id="The-PDL-Preprocessor">The PDL Preprocessor</h1>

<p>The PDL PreProcessor, or PDL::PP, is PDL&#39;s secret weapon. With PDL::PP, you can quickly and easily implement new &quot;primitive&quot; compiled C-language PDL functions that follow the PDL broadcasting rules, without having to write tedious loops or glue code. You can write simple computations with zero or more active dimensions (see <a>PDL::Book::Broadcasting</a>), write functions that contain a mix of Perl and compiled code, and/or generate output PDLs that remain linked to the source PDL in trivial or nontrivial ways.</p>

<p>The PDL::PP module is a preprocessor that accepts a metalanguage (&quot;PP&quot;) and emits both Perl and XS code. PDL::PP is not generally invoked directly by you, the coder, at run time -- it is invoked as part of your module&#39;s build process (via <a>ExtUtils::MakeMaker</a> or <a>Module::Build</a>) or by Inline::Pdlpp as part of inline compilation of snippets of PP. I will use the latter case throughout this documentation as it allows me to give full copy-and-paste examples.</p>

<p>Note that the vast majority of these examples are tested and should work by simply pasting them directly into a text editor. The only correction you will need to make is to ensure that the <code>__END__</code> and <code>__Pdlpp__</code> markers are flush against the left edge, i.e. there are no spaces before the underscores.</p>

<p>After reading this introduction, you should have a firm grasp on the basics of using PDL::PP and the full documentation in the <a>PDL::PP man page</a> should be fairly easy to follow.</p>

<h2 id="Basics">Basics</h2>

<p>In this section I discuss the basics of writing PP code using <code>pp_def</code>. I will use <a>Inline::Pdlpp</a> for all of my examples, including this first one. If you need help getting <a>Inline::Pdlpp</a> to work, see Appendix A.</p>

<p>The contents of the <a>Inline::Pdlpp</a> is no more than a Perl script that calls special functions defined in the <a>PDL::PP</a> module. The final result of this Perl script are a Perl module (.pm file) and a Perl extension (.xs file). The latter gets expanded to C code and compiled to produce XSUBs that ultimately end up as methods in the PDL package.</p>

<p><code>pp_def</code> accepts a collection of parameters that describe both the way the new method should interact with the broadcasting engine (e.g. its dimensional signature and which data types it should support natively), and also the code for the core of the method.</p>

<h3 id="First-Example">First Example</h3>

<p>Let&#39;s begin with a variation on the canonical Hello World.</p>

<pre><code> use strict;
 use warnings;
 use PDL;
 use Inline &#39;Pdlpp&#39;;
 my $a = sequence(10);
 $a-&gt;printout;
 
 __END__
 
 __Pdlpp__
 
 pp_def(&#39;printout&#39;,
     Pars =&gt; &#39;a()&#39;,
     Code =&gt; q{
         printf(&quot;%f\n&quot;, $a());
     },
 );</code></pre>

<p>If you run that script, after a short pause you should see output that looks like this:</p>

<pre><code> &gt; perl my_script.pl
 0.000000
 1.000000
 2.000000
 3.000000
 4.000000
 5.000000
 6.000000
 7.000000
 8.000000
 9.000000</code></pre>

<p>During that pause, Inlne took the text below the <code>__Pdlpp__</code> marker and sent it off to <a>Inline::Pdlpp</a>, which generated a source file and a Makefile. Inline took it from there, compiling the function and then loading the newly compiled module into your current Perl interpreter. That module defined the function <code>PDL::printout</code>, which the script ran a couple of lines below the <code>use Inline &#39;Pdlpp&#39;</code>. The cool part about Inline is that it caches the result of that build process and only rebuilds if you change the part below the <code>__Pdlpp__</code> marker. You can freely play with the Perl part of the file and it will use the same cached Pdlpp code. Now that you understand what Inline did, let&#39;s take a closer look at how I actually defined the <code>printout</code> function.</p>

<p>PDL::PP is a Perl module that you use to <b>generate</b> the XS and Perl code for your PDL functions. This means that everything below the <code>__Pdlpp__</code> marker is actually a plain Perl script, except that you don&#39;t need to <code>use PDL::PP</code> because <a>Inline::Pdlpp</a> took care of that for you.</p>

<p>In order to generate your XS code, you call one of the many functions defined in PDL::PP. All of these are discussed in the PDL::PP documentation, and in this chapter I will focus entirely on PDL::PP&#39;s workhorse: <code>pp_def</code>. In the above example, the code of interest is this:</p>

<pre><code> pp_def(&#39;printout&#39;,
     Pars =&gt; &#39;a()&#39;,
     Code =&gt; q{
         printf(&quot;%f\n&quot;, $a());
     },
 );</code></pre>

<p>The first argument to <code>pp_def</code> is the name of the function you want to create. After that, you pass a number of key/value pairs to tell PDL::PP precisely what sort of function you are trying to create. The bare minimum for a normal computational function (as opposed to a slice function, for which there is sadly no documentation) is the <code>Pars</code> key and the <code>Code</code> key.</p>

<p>The <code>Pars</code> key specifies the <b>ndarray</b> arguments for your function. It accepts a simple Perl string with the argument names and dimensions, delimited by semicolons. In the example I only use a single argument, but you can specify multiple input and output arguments, and you can even restrict (that is, force a coercion in) their data types. Note that the parentheses that follow the <code>a</code> are important and cannot be omitted. They might make the statement look like a function, but we&#39;ll see soon why they are important.</p>

<p>The <code>Code</code> key specifies a Perl string with a quasi-C block of code that I am going to call PP code. This Perl string gets thoroughly transformed by PDL::PP and combined with other keys to produce the XS (and eventually C) code for your function. You can think of PP code as being regular C code with a few special macros and notations. The first example already demonstrates one such notation: to access the value in an ndarray, you must prefix the name with a dollar-sign and you must postfix it with parentheses. In the next section we&#39;ll see just what sort of arguments you can put in those parentheses.</p>

<dl>

<dt id="Best-Practice:-Use-q-for-Code-Sections">Best Practice: Use q{ } for Code Sections</dt>
<dd>

<p>When creating a string for the Code key (as well as the BadCode, BackCode, and BadBackCode keys), I strongly recommend that you use Perl&#39;s <code>q</code> quote operator with curly braces as delimiters, as I have used in the examples so far. Perl offers many ways to quote long blocks of text. Your first impulse may be to simply use normal Perl quotes like so:</p>

<pre><code> Code =&gt; &#39; printf(&quot;%f\n&quot;, $a()); &#39;,</code></pre>

<p>For longer lines, you would probably pull out the ever-useful heredoc:</p>

<pre><code> Code =&gt; &lt;&lt;EOCode,
 
     printf(&quot;%f\n&quot;, $a());
 
 EOCode</code></pre>

<p>I have two reasons for recommending Perl&#39;s <code>q</code> operator. First, it makes your Code section look like a code block:</p>

<pre><code> Code =&gt; q{
     printf(&quot;%f\n&quot;, $a());
 }</code></pre>

<p>Second, PDL::PP&#39;s error reporting is not the greatest, and if you miss a curly brace, Perl&#39;s <b>interpreter</b> will catch it as a problem. This is not the case with the other delimiters. In this example, I forgot to include a closing brace:</p>

<pre><code> Code =&gt; &lt;&lt;&#39;EOCode&#39;,
     printf(&quot;Starting\n&quot;);
     
     for(i = 0; i &lt; $SIZE(n); ++i) {
         printf(&quot;%d: %f\n&quot;, i, $a(n =&gt; i));
     
     printf(&quot;All done\n&quot;);
 EOCode</code></pre>

<p>The C compiler will croak on the above example with an error that is likely to be obscure and only tangentially helpful. However, Perl will catch this typo at compile time if you use <code>q{ }</code>:</p>

<pre><code> Code =&gt; q{
     printf(&quot;Starting\n&quot;);
     
     for(i = 0; i &lt; $SIZE(n); ++i) {
         printf(&quot;%d: %f\n&quot;, i, $a(n =&gt; i));
     
     printf(&quot;All done\n&quot;);
 },</code></pre>

<p>Also note that I do not recommend using the <code>qq</code> quoting operator. Almost all the PDL::PP code strings delimit ndarrays using dollar-signs (like <code>$a()</code> above) and you must escape each one of these unless you want Perl to interpolate a variable for you. Obviously <code>qq</code> has its uses occasionally, but in general I recommend sticking almost exclusively with <code>q</code>.</p>

</dd>
</dl>

<p>Let&#39;s now expand the example so that the function takes two arguments. Replace the original <code>pp_def</code> with this slightly more interesting code:</p>

<pre><code> pp_def(&#39;printout_sum&#39;,
     Pars =&gt; &#39;a(); b()&#39;,
     Code =&gt; q{
         printf(&quot;%f + %f = %f\n&quot;, $a(), $b(), $a() + $b());
     },
 );</code></pre>

<p>Change the line that reads</p>

<pre><code> $a-&gt;printout;</code></pre>

<p>to the following two lines:</p>

<pre><code> my $b = $a-&gt;random;
 $a-&gt;printout_sum($b);</code></pre>

<p>and you should get output that looks like this:</p>

<pre><code> &gt; perl two-args.pl
 0.000000 + 0.690920 = 0.690920
 1.000000 + 0.907612 = 1.907612
 2.000000 + 0.479112 = 2.479112
 3.000000 + 0.421556 = 3.421556
 4.000000 + 0.431388 = 4.431388
 5.000000 + 0.022563 = 5.022563
 6.000000 + 0.014719 = 6.014719
 7.000000 + 0.354457 = 7.354457
 8.000000 + 0.705733 = 8.705733
 9.000000 + 0.827809 = 9.827809</code></pre>

<p>The differences between this and the previous example are not complicated but deserve some discussion. A cosmetic difference is that I have used a different name for the function, but a more substantial difference is that the function now takes two arguments, <code>a()</code> and <code>b()</code>, as specified by the <code>Pars</code> key. The <code>Code</code> block makes use of these two ndarrays, printing out the two and their sum. Notice that I access the value in <code>a</code> with the expression <code>$a()</code>, and the value in <code>b</code> with <code>$b()</code>. Also notice that I can use those values in an arithmetic expression.</p>

<h3 id="Returning-Values">Returning Values</h3>

<p>The examples I have used have all demonstrated their behavior by printing out their results to STDOUT. If you are like me, you will be glad to know that you can use printfs throughout your PP code when it comes time to debug, but these functions would be far more useful if they returned ndarrays with the calculated results. Fortunately, PDL::PP functions are really just C functions in disguise, and ultimately the data are passed around in C arrays, essentially by reference. This means that you can modify incoming ndarrays in-place. For example, this function increments an ndarray:</p>

<pre><code> use strict;
 use warnings;
 use PDL;
 use Inline &#39;Pdlpp&#39;;
 my $a = sequence(10);
 print &quot;a is initially $a\n&quot;;
 $a-&gt;my_inc;
 print &quot;a is now $a\n&quot;;
 
 __END__
 __Pdlpp__
 pp_def(&#39;my_inc&#39;,
     Pars =&gt; &#39;a()&#39;,
     Code =&gt; q{
         $a()++;
     },
 );</code></pre>

<p>When I run that, I get this output:</p>

<pre><code> a is initially [0 1 2 3 4 5 6 7 8 9]
 a is now [1 2 3 4 5 6 7 8 9 10]</code></pre>

<p>If you want to modify an ndarray in-place, PDL provides multiple mechanisms for handling this, depending on what you are trying to accomplish. In particular, there are ways to handle the <code>inplace</code> flag for a given ndarray. But I&#39;m getting a bit ahead of myself. Generally speaking, you shouldn&#39;t modify an ndarray in-place: you should return a result instead. To do this, you simply mark the argument in the <code>Pars</code> key with the <code>[o]</code> qualifier. Here, I show how to return two arguments:</p>

<pre><code> pp_def(&#39;my_sum_and_diff&#39;,
     Pars =&gt; &#39;left(); right(); [o] sum(); [o] diff()&#39;,
     Code =&gt; q{
         $sum() = $left() + $right();
         $diff() = $left() - $right();
     },
 );</code></pre>

<p>This function takes <code>$left</code> and <code>$right</code> as input arguments (in that order) and it outputs <code>$sum</code> and <code>$diff</code> (also in that order, as a Perl list). For example, we could run the above pp-code with Perl code like this:</p>

<pre><code> use strict;
 use warnings;
 use PDL;
 use Inline &#39;Pdlpp&#39;;
 my $left = sequence(10);
 my $right = $left-&gt;random;
 
 my ($sum, $diff) = $left-&gt;my_sum_and_diff($right);
 
 print &quot;Left:  $left\n&quot;;
 print &quot;Right: $right\n&quot;;
 print &quot;Sum:   $sum\n&quot;;
 print &quot;Diff:  $diff\n&quot;;</code></pre>

<p>The functions defined using <code>pp_def</code> actually allow for you to pass in the output ndarrays as arguments, but I&#39;ll explore that in one of the exercises rather than boring you with more details.</p>

<h3 id="Exercise-Set-1">Exercise Set 1</h3>

<p>So far I have shown you how to write basic PP code that prints values to the screen or returns values. The great thing about PDL::PP is that this code actually allows for two different calling conventions, and it Does What You Mean when you give it all manner of ndarrays. Rather than bore you to death with more prose, I am going to give you a couple of exercises. Solutions to these exercises are in Appendix B.</p>

<dl>

<dt id="Slices">1. Slices</dt>
<dd>

<p>Working with <code>printout_sum</code>, replace <code>$b</code> with a <b>slice</b> from some other ndarray. Does it do what you expect?</p>

</dd>
<dt id="Broadcasting2">2. Broadcasting</dt>
<dd>

<p>With <code>printout_sum</code>, what if you replace <code>$b</code> with a two-dimensional ndarray that is broadcast-compatible with <code>$a</code>? Try to guess the order of the output that you&#39;ll get before running the example. Did you guess correctly?</p>

</dd>
<dt id="Orthogonal-NDArrays">3. Orthogonal NDArrays</dt>
<dd>

<p>What if <code>$a</code> has dimensions M and <code>$b</code> has dimensions (1, N) with <code>printout_sum</code>? What about <code>my_sum_and_diff</code>?</p>

</dd>
<dt id="Varying-Input-Order">4. Varying Input Order</dt>
<dd>

<p>The PP code that I present puts all the output ndarrays at the end of the <code>Pars</code> section. What happens if you move them to the beginning of the section instead of the end?</p>

</dd>
<dt id="Supplying-Outputs-in-the-Function-Call">5. Supplying Outputs in the Function Call</dt>
<dd>

<p>You can call <code>pp_def</code>ined functions by supplying all the arguments to the function. For example, instead of calling <code>my_sum_and_diff</code> like this:</p>

<pre><code> # No output ndarrays in function call
 my ($sum, $diff) = $left-&gt;my_sum_and_diff($right);</code></pre>

<p>you can call it like this:</p>

<pre><code> # All in function call, both outputs null
 my ($sum, $diff) = (PDL::null, PDL::null);
 $left-&gt;my_sum_and_diff($right, $sum, $diff);</code></pre>

<p>What is the return value of this sort of invocation? How does the function call change if you alter the <code>Pars</code> order? There&#39;s a good reason for this capability, can you guess why PDL lets you do this?</p>

</dd>
</dl>

<h2 id="Higher-Dimensional-Functions">Higher Dimensional Functions</h2>

<p>So far I have shown how to write rudimentary functions that accept zero-dimensional ndarrays. In this section, I will explain how to write functions that accept higher-dimensional data.</p>

<h3 id="Specifying-Dimensions-and-Using-Explicit-Looping">Specifying Dimensions and Using Explicit Looping</h3>

<p>Exercises 1.2 and 1.3 demonstrate that PDL::PP automatically loops over the values in an ndarray for you. What if you want to do some sort of aggregate behavior, such as computing the sum of all the values in an ndarray? This requires more fine-grained control of the code over which PDL::PP loops.</p>

<p>Our discussion begins by looking more closely at the <code>Pars</code> key. When you have a parameter list like <code>&#39;input(); [o] output()&#39;</code>, you are telling PDL::PP that you want it to present the data from the input and output ndarrays as scalars. The code you specify in the <code>Code</code> key gets wrapped by a couple of C <code>for</code> loops that loop through higher dimensions, something that we call <i>broadcasting</i>. There are many calculations you cannot do with this simplistic representation of the data, such as write a Fourier Transform, matrix-matrix multiplication, or a cumulative sum. For these, you need PDL::PP to represent your data as vectors or matrices.</p>

<p>Note: I am about to cover some material that makes sense once you get it, but which is very easy to mis-interpret. Pay close attention!</p>

<p>To tell PDL::PP that you want it to represent the data as a vector, you specify a <i>dimension name</i> in the <code>Pars</code> key, such as</p>

<pre><code> Pars =&gt; &#39;input(n); [o] sum()&#39;</code></pre>

<p>Notice that I have put something within the parentheses of the input ndarray, <code>n</code>. That means that I want PDL::PP to represent the input as a vector with one dimension and I am going to refer to its (single) dimension by the name <code>n</code>. Then, to access the third element of that vector, you would write <code>$input(n =&gt; 2)</code>. (Element access uses zero-offsets, just like Perl and C array access.) To sum all the values in the vector and store the result in the output variable, you could use a C for-loop like so:</p>

<pre><code> int i;
 $sum() = 0;
 for (i = 0; i &lt; $SIZE(n); i++) {
     $sum() += $input(n =&gt; i);
 }</code></pre>

<p>Here, <code>$SIZE(n)</code> is a PDL::PP macro that returns the length of the vector (or more precisely, the size of the dimension that we have called <code>n</code>).</p>

<dl>

<dt id="Best-practice:-optimize-for-clarity-when-using-SIZE">Best practice: optimize for clarity when using $SIZE</dt>
<dd>

<p>When I first encountered the <code>$SIZE</code> PDL::PP macro, I assumed it produced slow code. It turns out that it replaces itself with a direct variable access, which is quite fast. As a general rule regarding <code>$SIZE</code>, optimize for clarity. The only exception is that, as of this writing, you <b>cannot</b> use <code>$SIZE</code> within a direct memory access, as I discuss next.</p>

</dd>
<dt id="Wart:-no-parenthesized-expressions-within-direct-memory-access">Wart: no parenthesized expressions within direct memory access</dt>
<dd>

<p>Due to a current limitation in PDL::PP, you cannot use parenthesized expressions within a memory access. For example, this will fail to compile and will throw a most obscure error:</p>

<pre><code> $sum() += $input(n =&gt; (i-1));</code></pre>

<p>The reason is that the parser isn&#39;t a real parser: it&#39;s just a series of regular expressions. It takes everything up until the first closing parenthesis and doesn&#39;t realize that you put <code>i-1</code> in parentheses. This means that these also fail:</p>

<pre><code> $sum() += $input(n =&gt; calculate_offset(i));
 $sum() += $input(n =&gt; $SIZE(n)-1);</code></pre>

<p>You can use expressions that do not involve parentheses, even expressions involving arithmetic, so you can achieve the same ends with these work-arounds:</p>

<pre><code> long calc_off = calculate_offset(i);
 $sum() += $input(n =&gt; calc_off);
 
 long N = $SIZE(n);
 $sum() += $input(n =&gt; N-1);</code></pre>

<p>I intend to improve this soon so that at least parenthesized expressions will work in memory access statements. However, fixing access statement parsing to allow <code>$SIZE(n)</code> may require a more substantial overhaul of the parser and may not happen any time soon. Sorry.</p>

</dd>
</dl>

<p>PDL::PP also provides a convenient short-hand for this sort of loop:</p>

<pre><code> $sum() = 0;
 loop (n) %{
     $sum() += $input();
 %}</code></pre>

<p>Here, I declare a PDL::PP loop block. Standard blocks in C (and in Perl) are delimited with curly braces, but the loop block is delimited with <code>%{</code> and <code>%}</code>. You end up with code that is functionally identical to the previous method for writing this sum, but you can use fewer keystrokes to do it.</p>

<p>Putting this all together, here is a complete example that performs a sum over a vector:</p>

<pre><code> use strict;
 use warnings;
 use PDL;
 use Inline &#39;Pdlpp&#39;;
 my $a = sequence(10);
 print &quot;a is $a and its sumover is &quot;
     , $a-&gt;my_sumover, &quot;\n&quot;;
 
 my $b = sequence(3, 5);
 print &quot;b is $b and its sumover is &quot;
     , $b-&gt;my_sumover, &quot;\n&quot;;
 
 __END__
 
 __Pdlpp__
 
 pp_def(&#39;my_sumover&#39;,
     Pars =&gt; &#39;input(n); [o] sum()&#39;,
     Code =&gt; q{
         $sum() = 0;
         loop (n) %{
             $sum() += $input();
         %}
     }
 );</code></pre>

<p>That gives the following output:</p>

<pre><code> a is [0 1 2 3 4 5 6 7 8 9] and its sumover is 45
 b is 
 [
  [ 0  1  2]
  [ 3  4  5]
  [ 6  7  8]
  [ 9 10 11]
  [12 13 14]
 ]
  and its sumover is [3 12 21 30 39]</code></pre>

<p>As the calculation on <code>$a</code> shows, when you perform the calculation on a one-dimensional ndarray, it returns a single result with the sum of all the elements. The calculation on <code>$b</code> treats each row as a vector and performs the calculation on each row.</p>

<h3 id="Matrix-Matrix-Multiplication">Matrix-Matrix Multiplication</h3>

<p>Let&#39;s look at another example, matrix-matrix multiplication. (You remember how to do matrix-matrix multiplication, right? No? Brush-up on <a href="http://en.wikipedia.org/wiki/Matrix_multiplication">http://en.wikipedia.org/wiki/Matrix_multiplication</a>.) How would we write such an algorithm using PDL::PP? First, the <code>Pars</code> section needs to indicate what sort of input and output ndarrays we want to handle. The length of the row of the first matrix has to be equal to the length of the column of the second matrix. The output matrix will have as many rows as the second matrix, and as many columns as the first matrix. Second, we need to loop over the entire output dimensions. Altogether, my first guess at this function looked like this:</p>

<pre><code> pp_def(&#39;my_matrix_mult&#39;,
     Pars =&gt; &#39;left(n,m); right(m,p); [o] output(n,p)&#39;,
     Code =&gt; q{
         loop (n) %{
             loop (p) %{
                 $output() = 0;
                 loop (m) %{
                     $output() += $left() * $right();
                 %}
             %}
         %}
     },
 );</code></pre>

<p>&quot;Wait,&quot; you say, &quot;That&#39;s it? It&#39;s that simple?&quot; Yep. Once you figure out the relationship of the dimension sizes, the broadcasting engine just Does What You Mean. (As you&#39;ll see, I got the dimensions wrong, but it&#39;ll be a quick fix.) You can run that with this Perl code:</p>

<pre><code> use strict;
 use warnings;
 use PDL;
 use Inline &#39;Pdlpp&#39;;
 my $left = sequence(2,4);
 my $right = sequence(4,5);
 print &quot;$left times $right is &quot;, $left-&gt;my_matrix_mult($right);</code></pre>

<p>and that gives this output:</p>

<pre><code> [
  [0 1]
  [2 3]
  [4 5]
  [6 7]
 ]
  times 
 [
  [ 0  1  2  3]
  [ 4  5  6  7]
  [ 8  9 10 11]
  [12 13 14 15]
  [16 17 18 19]
 ]
  is 
 [
  [ 18  21]
  [ 42  49]
  [ 66  77]
  [ 90 105]
  [114 133]
 ]</code></pre>

<p>Oops! You can see that PDL considers the first argument to the number of columns, not the number of rows! I&#39;ll let you fix that in an exercise.</p>

<h3 id="Broadcastloops">Broadcastloops</h3>

<p>PDL::PP also has the <code>broadcastloop</code> construct, which lets you declare the code over which PDL should broadcast, and the code that should come before and after the broadcast loop. Here&#39;s a simple example demonstrating the <code>broadcastloop</code> construct in conjunction with the <code>loop</code> construct:</p>

<pre><code> use strict;
 use warnings;
 use PDL;
 use Inline &#39;Pdlpp&#39;;
 
 # Run the code on a 2x4 matrix:
 sequence(2,4)-&gt;my_print_rows;
 
 # Run the code on a 3x4x5 matrix:
 sequence(3,4,5)-&gt;my_print_rows;
 
 __END__
 
 __Pdlpp__
 
 pp_def(&#39;my_print_rows&#39;,
     Pars =&gt; &#39;in(n)&#39;,
     Code =&gt; q{
         printf(&quot;About to start printing rows\n&quot;);
         int row_counter = 0;
         broadcastloop %{
             printf(&quot;  Row %3d: &quot;, row_counter);
             loop(n) %{
                 printf(&quot;%f, &quot;, $in());
             %}
             printf(&quot;\n&quot;);
             row_counter++;
         %}
         printf(&quot;All done!\n&quot;);
     },
 );</code></pre>

<p>A snippet of that output looks like this:</p>

<pre><code> About to start printing rows
   Row   0: 0.000000, 1.000000, 
   Row   1: 2.000000, 3.000000, 
   Row   2: 4.000000, 5.000000, 
   Row   3: 6.000000, 7.000000, 
 All done!
 About to start printing rows
   Row   0: 0.000000, 1.000000, 2.000000, 
   Row   1: 3.000000, 4.000000, 5.000000, 
   ...
   Row  19: 57.000000, 58.000000, 59.000000, 
 All done!</code></pre>

<p>There are two important aspects to remember about broadcastloops. First, you must not put anything between the <code>broadcastloop</code> and the <code>%{</code> except white space. For example:</p>

<pre><code> /* ok */
 broadcastloop %{
 
 /* ok */
 broadcastloop
     %{
 
 /* BAD */
 broadcastloop /* outer loop */ %{</code></pre>

<p>As you can see, the parser for the PDL PreProcessor is not terribly sophisticated. It&#39;s mostly a pile of regular expressions, and 99% of the time, it does exactly what you need.</p>

<p>Another potential area of confusion can arise if you have something that looks like a broadcastloop in your code, but you&#39;ve commented it out:</p>

<pre><code> ...
 #if 0  /* skip this for now */
 
 broadcastloop %{
         printf(&quot;  Row %3d: &quot;, row_counter);
         loop(n) %{
                 printf(&quot;%f, &quot;, $in());
         %}
         printf(&quot;\n&quot;);
         row_counter++;
 %}
 
 #endif /* skipped block of code */
 ...</code></pre>

<p>The problem is that if you do not indicate where the broadcastloop is supposed to go, PDL wraps all your code in the broadcastloop logic. However, if PDL sees what looks like a broadcastloop block, it assumes that you want to be more precise about where the broadcastloop logic goes. In fact, it even inserts the broadcastloop logic where you indicated it was to go, but this will eventually get discarded by the C preprocessor thanks to the <code>#if 0</code> block. This means that the code that contains the <code>loop(n)</code> block, below the <code>#endif</code>, does not have the broadcastloop logic that it needs to do its job, and you will get erroneous results.</p>

<p>The easiest fix for this? In addition to commenting out the blocks, put something (anything) between the text <code>broadcastloop</code> and the percent block <code>%{</code>. As already discussed, this will always prevent PDL from identifying the broadcastloop, which is what you need it to temporarily do in this case.</p>

<p>It may seem that broadcastloops are bad things to be avoided, but broadcastloops are particularly useful if you are writing a function that needs access to a system resource that is costly to allocate with each iteration. For that sort of operation, you allocate it before entering the broadcastloop and de-allocate it after leaving:</p>

<pre><code>     Code =&gt; q{
         /* allocate system resource */
         broadcastloop %{
             /* use system resource */
         %}
         /* Free system resource */
     },</code></pre>

<p>They are also handy if you need to perform a particularly expensive calculation once each time the function is invoked.</p>

<h3 id="A-Complex-Example">A Complex Example</h3>

<p>To put this all together, I am going to consider writing a PDL::PP function that computes the first numerical derivative of a time series. You can read about finite difference formulas here: <a href="http://en.wikipedia.org/wiki/Numerical_differentiation">http://en.wikipedia.org/wiki/Numerical_differentiation</a>. Normally, finite difference formulas result in a numerical derivative with one less point than the original time series. Since I have not discussed how to set a return dimension with a calculated size, I&#39;m going to use a slightly modified numerical derivative. The derivatives associated with the first and last points will be calculated using the right and left finite differences, respectively, whereas the points in the middle will be calculated using a centered-difference formula. I&#39;ll run this function on the sine wave and compare the results with the actual derivative of the sine wave, which is the cosine wave. I&#39;ve marked a couple of points in the code for the discussion that follows.</p>

<pre><code> use strict;
 use warnings;
 use PDL;
 use Inline &#39;Pdlpp&#39;;
 
 # Create some sine data:
 my $h = 0.3;
 my $sine = sin(sequence(10) * $h);
 my $derivative = $sine-&gt;my_first_derivative($h);
 my $cosine = cos(sequence(10) * $h);
 
 print &quot;The difference between the computed and actual derivative:\n&quot;
    , $derivative - $cosine, &quot;\n&quot;;
 
 __END__
 
 __Pdlpp__
 
 pp_def(&#39;my_first_derivative&#39;,
     Pars =&gt; &#39;t_series(n); step(); [o] derivative(n)&#39;,
     Code =&gt; q{
         int N = $SIZE(n);
         broadcastloop %{
             /* Derivative for i = 0 */
             $derivative(n =&gt; 0)
                 = ($t_series(n =&gt; 1) - $t_series(n =&gt; 0))
                     / $step();
             /* Derivatives for 1 &lt;= i &lt;= N-2 */
             /* (Point 1) */
             loop (n) %{
                 /* Skip the first and last elements (Point 2) */
                 if (n == 0 || n == N - 1) {
                     /* (Point 3) */
                     continue;
                     
                 }
                 /* (Points 4 and 5) */
                 $derivative()
                     = ($t_series(n =&gt; n+1) - $t_series(n =&gt; n-1))
                         / 2.0 / $step();
             %}
             /* Derivative for i = N-1 */
             $derivative(n =&gt; N-1)
                 = ($t_series(n =&gt; N-1) - $t_series(n =&gt; N-2))
                     / $step();
         %}
     },
 );</code></pre>

<p>The output on my machine looks like this:</p>

<p>The difference between the computed and actual derivative:</p>

<pre><code>  [-0.014932644 -0.0142657   -0.012324443 -0.0092822807 -0.0054109595
   -0.0010562935 0.0033927281 0.0075386874 0.011011238   0.077127808 ]</code></pre>

<p>These differences are fairly small, four times smaller than the (fairly large) step size. And if I decrease the size of <code>$h</code> by 2, these errors should get smaller by a factor of 4 except at the endpoints. Not bad.</p>

<p>But what we really care about is the code, which uses a number of tricks I haven&#39;t discussed yet. Let&#39;s run through each point in turn.</p>

<dl>

<dt id="point-1-a-sub-optimal-example">point 1, a sub-optimal example</dt>
<dd>

<p>The code within this loop does <code>not</code> actually compute results for all indices from zero to N-1. As such, I should use a for loop that starts from 1 and runs to N-2. I dislike it when bad examples are used for pedagogical reasons, but that&#39;s what I&#39;m going to do here. Sorry.</p>

</dd>
<dt id="point-2-a-useful-register">point 2, a useful register</dt>
<dd>

<p>The actual C code that gets generated by the <code>loop</code> construct creates a register variable called <code>n</code> within the scope of the loop block. Thus, we can access the current value of <code>n</code> from within the loop by simply using that value in our code. I do that in this <code>if</code> statement and in the memory accesses later.</p>

</dd>
<dt id="point-3-C-looping-commands">point 3, C looping commands</dt>
<dd>

<p>The <code>loop</code> construct creates a bona fide <code>for</code> loop, so you can use <code>break</code> and <code>continue</code>, just like in a real C <code>for</code> loop.</p>

</dd>
<dt id="point-4-explicit-dimension-values-within-a-loop-block">point 4, explicit dimension values within a loop block</dt>
<dd>

<p>When we <code>loop</code> over <code>n</code>, it saves you keystrokes in your memory access by making it unnecessary to specify <code>n</code>. This is exploited when I say <code>$derivative()</code> without specifying a value for <code>n</code>. However, we can override that value for <code>n</code> within the loop by explicitly specifying it, which is what I do with <code>$t_series(n =</code> n-2)&gt;.</p>

</dd>
<dt id="point-5:-which-n">point 5: which n?</dt>
<dd>

<p>Look closely at the access statements for <code>$t_series</code>:</p>

<pre><code> $t_series(n =&gt; n-1)</code></pre>

<p>PDL::PP parses this as</p>

<pre><code> $ &lt;pars-variable-name&gt; ( &lt;dimension-name&gt; =&gt; &lt;value&gt;,
                          &lt;dimension-name&gt; =&gt; &lt;value&gt;,
                          ...
                        )</code></pre>

<p>and replaces it with a direct array access statement. In this statement, the <code>n</code> on the left side of the fat comma (the <code>=&gt;</code>) is the name of the dimension. The <code>n</code> on the right side of the fat comma is part of a C expression and is not touched by PDL::PP. That means that the <code>n</code> on the right side refers to the C variable <code>n</code>. This makes two uses of the same token, <code>n</code>, which can be a bit confusing. I&#39;m not suggesting that this is a best practice, but it is a possible practice which may be useful to you. So now you know.</p>

</dd>
</dl>

<p>In the above section I have explained how to use <code>loop</code> and <code>broadcastloop</code> to control how PDL::PP presents data to your code, and to control which sections of code PDL::PP broadcasts over. I have also shown you how to access specific memory locations when you have vector representations of your data.</p>

<h3 id="Exercise-Set-2">Exercise Set 2</h3>

<dl>

<dt id="Matrix-Multiplication-Fixed">1. Matrix Multiplication, Fixed</dt>
<dd>

<p>I noted above that my code for the matrix multiplication is incorrect and I explained why. Changing nothing more than the <code>Pars</code> section, fix this code so that it performs proper matrix multiplication.</p>

</dd>
<dt id="Broadcasting-Engine-Tricks">2. Broadcasting Engine Tricks</dt>
<dd>

<p>The function <code>my_sumover</code> uses a <code>loop</code> construct, so it only operates on individual rows. What if you wanted to perform the sum an entire matrix? Using Perl level operations, find a way to manipulate the incoming ndarray so that you can call <code>my_sumover</code> to get the sum over the entire matrix. Bonus points if the same technique works for higher dimensional ndarrays.</p>

</dd>
<dt id="Cumulative-Sum">3. Cumulative Sum</dt>
<dd>

<p>Modify <code>my_sumover</code> to create a function, <code>my_cumulative_sum</code>, which returns the cumulative sum for each row. By this I mean that it would take the input such as (1, 2, 3, 4) and return (1, 3, 6, 10), so that each element of the output corresponds to the sum of all the row&#39;s elements up to that point.</p>

</dd>
<dt id="Full-Cumulative-Sum">4. Full Cumulative Sum</dt>
<dd>

<p>Take your code for <code>my_cumulative_sum</code> and modify it so that it returns the cumulative sum over the entire ndarray, regardless of the ndarray&#39;s dimension. Your resulting code should not have any <code>loop</code> constructs.</p>

</dd>
</dl>

<h2 id="Tips">Tips</h2>

<p>These are a couple of things I have learned which help me make effective use of PDL::PP, but which did not sensibly fit elsewhere.</p>

<dl>

<dt id="Best-Practice:-use-pp_line_numbers">Best Practice: use pp_line_numbers</dt>
<dd>

<p>PDL::PP includes a brand new function in PDL 2.4.10 called <code>pp_line_numbers</code>. This function takes two arguments: a number and a string. The number should indicate the actual line in your Perl source file at which the string starts, and the function causes <code>#line</code> directives to be inserted into the string. This is <code>ENORMOUSLY</code> helpful when you have a syntax error. Without it, the syntax error is reported as coming from a given line in your XS file, but with it the error is reported as coming from your own source file.</p>

<p>I will illustrate this with an example that gave me great trouble while I was preparing this text:</p>

<pre><code> use strict;
 use warnings;
 use PDL;
 use Inline &#39;Pdlpp&#39;;
 
 # Run the code on a 2x4 matrix:
 sequence(2,4)-&gt;my_print_rows;
 
 __END__
 
 __Pdlpp__
 
 pp_def(&#39;my_print_rows&#39;,
     Pars =&gt; &#39;in(n)&#39;,
     Code =&gt; q{
         printf(&quot;About to start printing rows\n&quot;);
         int row_counter = 0;
         broadcastloop %{
             printf(&quot;  Row %3d: &quot;, row_counter);
             loop(n) %{
                 printf(&quot;%f, &quot;, $in())
             %}
             printf(&quot;\n&quot;);
             row_counter++;
         %}
         printf(&quot;All done!\n&quot;);
     },
 );</code></pre>

<p>Notice what&#39;s missing? The semicolon at the end of the <code>printf</code> is missing. Unfortunately, the error output of this example (contained in <i>_Inline/build/bad_error_reporting_pl_8328/out.make</i>) borders on useless:</p>

<pre><code> bad_error_reporting_pl_4420.xs: In function &#39;pdl_my_print_rows_readdata&#39;:
 bad_error_reporting_pl_4420.xs:177: warning: format &#39;%f&#39; expects type &#39;double&#39;, but argument 2 has type &#39;int&#39;
 bad_error_reporting_pl_4420.xs:177: warning: format &#39;%f&#39; expects type &#39;double&#39;, but argument 2 has type &#39;int&#39;
 bad_error_reporting_pl_4420.xs:178: error: expected &#39;;&#39; before &#39;}&#39; token
 bad_error_reporting_pl_4420.xs:222: warning: format &#39;%f&#39; expects type &#39;double&#39;, but argument 2 has type &#39;int&#39;
 bad_error_reporting_pl_4420.xs:222: warning: format &#39;%f&#39; expects type &#39;double&#39;, but argument 2 has type &#39;int&#39;
 bad_error_reporting_pl_4420.xs:223: error: expected &#39;;&#39; before &#39;}&#39; token
 bad_error_reporting_pl_4420.xs:267: warning: format &#39;%f&#39; expects type &#39;double&#39;, but argument 2 has type &#39;int&#39;
 bad_error_reporting_pl_4420.xs:267: warning: format &#39;%f&#39; expects type &#39;double&#39;, but argument 2 has type &#39;int&#39;
 bad_error_reporting_pl_4420.xs:268: error: expected &#39;;&#39; before &#39;}&#39; token
 bad_error_reporting_pl_4420.xs:312: warning: format &#39;%f&#39; expects type &#39;double&#39;, but argument 2 has type &#39;PDL_Long&#39;
 bad_error_reporting_pl_4420.xs:312: warning: format &#39;%f&#39; expects type &#39;double&#39;, but argument 2 has type &#39;PDL_Long&#39;
 bad_error_reporting_pl_4420.xs:313: error: expected &#39;;&#39; before &#39;}&#39; token
 bad_error_reporting_pl_4420.xs:357: warning: format &#39;%f&#39; expects type &#39;double&#39;, but argument 2 has type &#39;PDL_LongLong&#39;
 bad_error_reporting_pl_4420.xs:357: warning: format &#39;%f&#39; expects type &#39;double&#39;, but argument 2 has type &#39;PDL_LongLong&#39;
 bad_error_reporting_pl_4420.xs:358: error: expected &#39;;&#39; before &#39;}&#39; token
 bad_error_reporting_pl_4420.xs:403: error: expected &#39;;&#39; before &#39;}&#39; token
 bad_error_reporting_pl_4420.xs:448: error: expected &#39;;&#39; before &#39;}&#39; token</code></pre>

<p>If you&#39;re a seasoned C programmer, you&#39;ll recognize the warning: it arises because PDL::PP creates a branches of code for each data type that PDL supports, so using the <code>%f</code> type is not correct. (The correct way to handle this is to use the <code>$T</code> macro.) That&#39;s not our problem, though. The issue is the expected semicolon error. For a small function, you can probably just scan through the code and look for a missing semicolon, but when you are working on a much larger set of PP code, having the line number of the error would be <b>much</b> more useful. You accomplish that by using the <code>pp_line_numbers</code> function, which adds <code>#line</code> directives into your code so that errors get reported on the correct lines. Here is a slightly doctored version to illustrate the issue. (Note that the text <code>#line 1 ...</code> must be flush against the left margin, just like the <code>__END__</code> and <code>__Pdlpp__</code> markers, or Perl won&#39;t realize that you are trying to tell it about line numbers and things will be reported incorrectly.)</p>

<pre><code> use strict;
 use warnings;
 use PDL;
 use Inline &#39;Pdlpp&#39;;
 
 # Run the code on a 2x4 matrix:
 sequence(2,4)-&gt;my_print_rows;
 
 __END__
 
 __Pdlpp__
 #line 1 &quot;my-inline-work&quot;
                   # This is reported as line 1
 pp_def(&#39;my_print_rows&#39;,
     Pars =&gt; &#39;in(n)&#39;,
     Code =&gt; pp_line_numbers(__LINE__, q{
         /* This line is reported as line 5
          * Thanks to pp_line_numbers */
         printf(&quot;About to start printing rows\n&quot;);
         int row_counter = 0;
         broadcastloop %{
             printf(&quot;  Row %3d: &quot;, row_counter);
             loop(n) %{
                 printf(&quot;%f, &quot;, $in())
             %}
             printf(&quot;\n&quot;);
             row_counter++;
         %}
         printf(&quot;All done!\n&quot;);
         /* This is line 18 */
     }),
 );     # This is reported as line 20</code></pre>

<p>Apart from a couple of comments to indicate the line counting, I introduced two modifications: I added a <code>#line</code> directive at the top of the Pdlpp section and I wrapped the <code>Code</code> section in a call to <code>pp_line_numbers</code>. (The <code>#line</code> directive is only necessary when using <a>Inline::Pdlpp</a>, and is not necessary in a .pd file.) Now the error output gives the line of the closing bracket that reports the missing semicolon:</p>

<pre><code> my-inline-work: In function &#39;pdl_my_print_rows_readdata&#39;:
 my-inline-work:12: warning: format &#39;%f&#39; expects type &#39;double&#39;, but argument 2 has type &#39;int&#39;
 my-inline-work:12: warning: format &#39;%f&#39; expects type &#39;double&#39;, but argument 2 has type &#39;int&#39;
 my-inline-work:13: error: expected &#39;;&#39; before &#39;}&#39; token
 my-inline-work:12: warning: format &#39;%f&#39; expects type &#39;double&#39;, but argument 2 has type &#39;int&#39;
 my-inline-work:12: warning: format &#39;%f&#39; expects type &#39;double&#39;, but argument 2 has type &#39;int&#39;
 my-inline-work:13: error: expected &#39;;&#39; before &#39;}&#39; token
 my-inline-work:12: warning: format &#39;%f&#39; expects type &#39;double&#39;, but argument 2 has type &#39;int&#39;
 my-inline-work:12: warning: format &#39;%f&#39; expects type &#39;double&#39;, but argument 2 has type &#39;int&#39;
 my-inline-work:13: error: expected &#39;;&#39; before &#39;}&#39; token
 my-inline-work:12: warning: format &#39;%f&#39; expects type &#39;double&#39;, but argument 2 has type &#39;PDL_Long&#39;
 my-inline-work:12: warning: format &#39;%f&#39; expects type &#39;double&#39;, but argument 2 has type &#39;PDL_Long&#39;
 my-inline-work:13: error: expected &#39;;&#39; before &#39;}&#39; token
 my-inline-work:12: warning: format &#39;%f&#39; expects type &#39;double&#39;, but argument 2 has type &#39;PDL_LongLong&#39;
 my-inline-work:12: warning: format &#39;%f&#39; expects type &#39;double&#39;, but argument 2 has type &#39;PDL_LongLong&#39;
 my-inline-work:13: error: expected &#39;;&#39; before &#39;}&#39; token
 my-inline-work:13: error: expected &#39;;&#39; before &#39;}&#39; token
 my-inline-work:13: error: expected &#39;;&#39; before &#39;}&#39; token</code></pre>

<p>All the errors are reported as occurring on line 13, immediately directing your eye to where the problem lies. This lets you fix your problem and get on with your work.</p>

<p>Sometimes PDL::PP&#39;s parser croaks on invalid input. Sometimes it doesn&#39;t. For those times when you when you feed PDL::PP bad code and the error reporting leaves you scratching your head, consider wrapping your code in a <code>pp_line_numbers</code> call.</p>

</dd>
<dt id="Wart:-doesnt-always-work-use-if-0">Wart: /* */ doesn&#39;t always work; use #if 0</dt>
<dd>

<p>Note: This issue has been addressed in the git copy of PDL as of April 23, 2012. It will make its way onto CPAN with the release of PDL v2.4.11, slated for spring or summer of 2012.</p>

<p>Until the latest fixes, some of XS code that PDL::PP generates includes C-style comments indicating what they do. This is useful when you find yourself digging into the generated XS code as it helps you get your bearings. However, it can also break a relatively common use of comments. (With the latest work, the commentary is still present, but they use a preprocessor trick so that they don&#39;t break C-style comments anymore.)</p>

<p>When there is a logic bug in my code I find it helpful to reduce the complexity of the code and comment-out sections at a time until I get an output that makes sense.</p>

<p>Here&#39;s an example. I am trying to print out the values in an ndarray, but I have mistakenly used <code>\r</code> instead of <code>\n</code> in my <code>printf</code> statement. On some systems, nothing will get sent to <i>STDOUT</i> because IO operations are buffered, and I am left with a function that appears to print nothing when it gets called. (The last value may get printed when the buffer fills, or when the program terminates. Either way, it&#39;s very confusing.) So, I tried to comment out the confusing print behavior and replace with something foolproof:</p>

<pre><code> use strict;
 use warnings;
 use PDL;
 use Inline &#39;Pdlpp&#39;;
 
 # Run the code on a 2x4 matrix:
 sequence(2,4)-&gt;my_printout;
 
 __END__
 
 __Pdlpp__
 #line 1 &quot;my-printout-pdlpp&quot;
 pp_def(&#39;my_printout&#39;,
     Pars =&gt; &#39;in()&#39;,
     Code =&gt; pp_line_numbers(__LINE__, q{
         printf(&quot;This ndarray contains:\n&quot;);
         broadcastloop %{
             /* grr, not working
             printf(&quot;  %f\r&quot;, $in());
             */
             printf(&quot;  Here\n&quot;);
         %}
     }),
 );</code></pre>

<p>This <i>should</i> work without a hitch. Unfortunately, this gives me these errors:</p>

<pre><code> my-printout-pdlpp: In function &#39;pdl_my_printout_readdata&#39;:
 my-printout-pdlpp:7: error: expected statement before &#39;)&#39; token
 my-printout-pdlpp:8: error: expected expression before &#39;/&#39; token
 my-printout-pdlpp:7: error: expected statement before &#39;)&#39; token
 my-printout-pdlpp:8: error: expected expression before &#39;/&#39; token
 my-printout-pdlpp:7: error: expected statement before &#39;)&#39; token
 my-printout-pdlpp:8: error: expected expression before &#39;/&#39; token
 my-printout-pdlpp:7: error: expected statement before &#39;)&#39; token
 my-printout-pdlpp:8: error: expected expression before &#39;/&#39; token
 my-printout-pdlpp:7: error: expected statement before &#39;)&#39; token
 my-printout-pdlpp:8: error: expected expression before &#39;/&#39; token
 my-printout-pdlpp:7: error: expected statement before &#39;)&#39; token
 my-printout-pdlpp:8: error: expected expression before &#39;/&#39; token
 my-printout-pdlpp:7: error: expected statement before &#39;)&#39; token
 my-printout-pdlpp:8: error: expected expression before &#39;/&#39; token</code></pre>

<p>(Got different line numbers? Be sure to put remove all spaces before <code>#line 1 &quot;my-printout-pdlpp&quot;</code>.) Lines seven and eight are these:</p>

<pre><code>             printf(&quot;  %f\r&quot;, $in());
             */</code></pre>

<p>Perplexed? You bet. I just <i>commented out some code</i>, how could I possibly have introduced a compile error? Using <code>pp_line_numbers</code>, I know which lines in my code caused the C compiler to choke, but I&#39;m even more confused as to why it choked there.</p>

<p>The problem is that the memory access, <code>$in()</code>, gets replaced with a chunk of C code that includes the comment <code>/* ACCESS() */</code>. As C comments do not nest, this leads to some <i>very</i> wrong code. A different approach that achieves the same end is to use <code>#if 0</code>, a common technique among C programmers for cutting out blocks of code:</p>

<pre><code> use strict;
 use warnings;
 use PDL;
 use Inline &#39;Pdlpp&#39;;
 
 # Run the code on a 2x4 matrix:
 sequence(2,4)-&gt;my_printout;
 
 __END__
 
 __Pdlpp__
 #line 1 &quot;my-printout-pdlpp&quot;
 pp_def(&#39;my_printout&#39;,
     Pars =&gt; &#39;in()&#39;,
     Code =&gt; pp_line_numbers(__LINE__, q{
         printf(&quot;This ndarray contains:\n&quot;);
         broadcastloop %{
           #if 0
             printf(&quot;  %f\r&quot;, $in());
           #endif
             printf(&quot;  Here\n&quot;);
         %}
     }),
 );</code></pre>

<p>PDL::PP will still merrily fiddle with the stuff between the <code>#if 0</code> and <code>#endif</code>, but the C preprocessor will get rid of it before it actually tries to compile the code. Now the code at least runs and printouts the expected dumb results:</p>

<pre><code> This ndarray contains:
   Here
   Here
   Here
   Here
   Here
   Here
   Here
   Here</code></pre>

<p>Hopefully this gives me enough to find that errant <code>\r</code>.</p>

</dd>
</dl>

<h2 id="Recap">Recap</h2>

<p>In this chapter, I&#39;ve covered the very basics of using PDL::PP to write fast, versatile code. I have covered much less material than I had hoped, and I hope to expand this chapter in the coming months. Nonetheless, I hope and believe it will serve as a good starting point for learning PDL::PP, and I expect it will give you enough to dig into the PDL::PP documentation.</p>

<p>Good luck, and happy piddling!</p>

<h2 id="Appendix-A:-Installing-Inline::Pdlpp">Appendix A: Installing Inline::Pdlpp</h2>

<p>The PDL installation always installs <a>Inline::Pdlpp</a>, but that does not mean it works for you because <a>Inline</a> is not actually a prerequisite for PDL. The good news is that once you have installed <a>Inline</a>, <a>Inline::Pdlpp</a> will work automatically.</p>

<p>To begin, you will need to have access to the C compiler that compiled your copy of Perl. On Mac and Linux, this amounts to ensuring that the developer tools that contain <code>gcc</code> are installed on your system. On Windows, this will depend on your flavor of Perl. I personally have excellent experience working with Strawberry Perl, which ships with a working C compiler, but you can also work with Visual C or Cygwin. If you run into trouble, contact the PDL mailing list for help.</p>

<p>If you are on Linux, you can probably install <a>Inline</a> using your package manager. If you are not on Linux or you do not have administrative privileges, you will have to install <a>Inline</a> using CPAN. To do this, enter the following commands at your console:</p>

<pre><code> &gt; cpan Inline</code></pre>

<p>This will likely ask you a few questions during the installation, so do not walk away to get a cup of coffee and expect it to be done.</p>

<p>Once that&#39;s installed, you should be ready to work with the examples.</p>

<h2 id="Appendix-B:-Solutions-to-Exercises">Appendix B: Solutions to Exercises</h2>

<h3 id="Excercise-Set-1">Excercise Set 1</h3>

<dl>

<dt id="Slices1">1. Slices</dt>
<dd>

<pre><code> use strict;
 use warnings;
 use PDL;
 use Inline &#39;Pdlpp&#39;;
 use PDL::NiceSlice;
 
 # Create $a
 my $a = sequence(5);
 print &quot;a is $a\n&quot;;
 
 # Create $b as a five-element slice from a sequence:
 my $idx = pdl(1, 2, 7, 4, 8);
 my $b = sequence(20)-&gt;index($idx);
 print &quot;b is $b\n&quot;;
 
 print &quot;printout_sum(a, b) says:\n&quot;;
 $a-&gt;printout_sum($b);
 
 no PDL::NiceSlice;
 
 __END__
 
 __Pdlpp__
 pp_def(&#39;printout_sum&#39;,
     Pars =&gt; &#39;a(); b()&#39;,
     Code =&gt; q{
         printf(&quot;%f + %f = %f\n&quot;, $a(), $b(), $a() + $b());
     },
 );</code></pre>

</dd>
<dt id="Broadcasting3">2. Broadcasting</dt>
<dd>

<pre><code> use strict;
 use warnings;
 use PDL;
 use Inline &#39;Pdlpp&#39;;
 
 my $a = sequence(5);
 print &quot;a is $a\n&quot;;
 my $b = sequence(5,3);
 print &quot;b is $b\n&quot;;
 
 print &quot;a + b = &quot;, $a + $b, &quot;\n&quot;;
 
 print &quot;printout_sum(a, b) says:\n&quot;;
 $a-&gt;printout_sum($b);
 
 __END__
 
 __Pdlpp__
 pp_def(&#39;printout_sum&#39;,
     Pars =&gt; &#39;a(); b()&#39;,
     Code =&gt; q{
         printf(&quot;%f + %f = %f\n&quot;, $a(), $b(), $a() + $b());
     },
 );</code></pre>

</dd>
<dt id="Orthogonal-NDArrays1">3. Orthogonal NDArrays</dt>
<dd>

<pre><code> use strict;
 use warnings;
 use PDL;
 use Inline &#39;Pdlpp&#39;;
 
 my $a = sequence(5);
 print &quot;a is $a\n&quot;;
 my $b = sequence(1,3);
 print &quot;b is $b\n&quot;;
 
 print &quot;a + b = &quot;, $a + $b, &quot;\n&quot;;
 
 print &quot;printout_sum(a, b) says:\n&quot;;
 $a-&gt;printout_sum($b);
 
 __END__
 
 __Pdlpp__
 pp_def(&#39;printout_sum&#39;,
     Pars =&gt; &#39;a(); b()&#39;,
     Code =&gt; q{
         printf(&quot;%f + %f = %f\n&quot;, $a(), $b(), $a() + $b());
     },
 );</code></pre>

</dd>
<dt id="Varying-Input-Order1">4. Varying Input Order</dt>
<dd>

<p>Different input order would be like this:</p>

<pre><code> Pars =&gt; &#39;[o] sum(); left(); [o] diff(); right()&#39;;
 Pars =&gt; &#39;[o] sum(); [o] diff(); left(); right()&#39;;</code></pre>

<p>The only consistency here is that <code>sum</code> always comes before <code>diff</code>, and <code>left</code> always comes before right.</p>

</dd>
<dt id="Supplying-Outputs-in-the-Function-Call1">5. Supplying Outputs in the Function Call</dt>
<dd>

<p>For a <code>Pars</code> key like this:</p>

<pre><code> Pars =&gt; &#39;left(); right(); [o] sum(); [o] diff()&#39;;</code></pre>

<p>You can call the function like this:</p>

<pre><code> my ($sum, $diff) = $left-&gt;my_sum_and_diff($right);
 
 my ($sum, $diff);
 $left-&gt;my_sum_and_diff($right
     , ($sum = PDL::null), ($diff = PDL::null));
 
 my $sum = $left-&gt;zeroes;
 my $diff = PDL::null;
 $left-&gt;my_sum_and_diff($right, $sum, $diff);</code></pre>

<p>For the latter calling convention, the function returns nothing (rather than <code>$sum</code> and <code>$diff</code>). When you supply a null ndarray (as in the middle example) or you call the function with the input ndarrays only (as in the first example), PDL will allocate memory for you. As demonstrated with the last example, you can supply a pre-allocated ndarray, in which case PDL will <b>not</b> allocate memory for you. This can improve performance when you repeatedly call the same function.</p>

</dd>
</dl>

<h3 id="Exercise-Set-21">Exercise Set 2</h3>

<dl>

<dt id="Matrix-Multiplication-Fixed1">1. Matrix Multiplication, Fixed</dt>
<dd>

<p>The corrected <code>Pars</code> section should look like this:</p>

<pre><code> Pars =&gt; &#39;left(m,n); right(p,m); [o] output(p,n)&#39;,</code></pre>

<p>Note that you will have to make sure the dimensions of the input ndarrays match this new specification, e.g.:</p>

<pre><code> my $left = sequence(2,4)-&gt;transpose;
 my $right = sequence(4,5)-&gt;transpose;</code></pre>

</dd>
<dt id="Broadcasting-Engine-Tricks1">2. Broadcasting Engine Tricks</dt>
<dd>

<p>The key is to use <code>clump(-1)</code>:</p>

<pre><code> my $matrix = sequence(2,4);
 my $result = $matrix-&gt;clump(-1)-&gt;my_sumover;</code></pre>

</dd>
<dt id="Cumulative-Sum1">3. Cumulative Sum</dt>
<dd>

<pre><code> use strict;
 use warnings;
 use PDL;
 use Inline &#39;Pdlpp&#39;;
 my $a = sequence(10);
 print &quot;Cumulative sum for a:\n&quot;;
 print $a-&gt;my_cumulative_sum;
 my $b = grandom(10,3);
 print &quot;\nCumulative sum for b:\n&quot;;
 print $b-&gt;my_cumulative_sum;
 
 __END__
 
 __Pdlpp__
 
 pp_def(&#39;my_cumulative_sum&#39;,
     Pars =&gt; &#39;input(n); [o] output(n)&#39;,
     Code =&gt; q{
         double cumulative_sum;
         broadcastloop %{
             cumulative_sum = 0.0;
             loop (n) %{
                 cumulative_sum += $input();
                 $output() = cumulative_sum;
             %}
         %}
     }
 );</code></pre>

</dd>
<dt id="Full-Cumulative-Sum1">4. Full Cumulative Sum</dt>
<dd>

<pre><code> pp_def(&#39;my_full_cumulative_sum&#39;,
     Pars =&gt; &#39;input(); [o] output()&#39;,
     Code =&gt; q{
         double cumulative_sum = 0.0;
         broadcastloop %{
             cumulative_sum += $input();
             $output() = cumulative_sum;
         %}
     }
 );</code></pre>

</dd>
</dl>

<h1 id="The-Beginnings-of-PDL">The Beginnings of PDL</h1>

<p><i>&quot;Why is it that we entertain the belief that for every purpose odd numbers are the most effectual?&quot; - Pliny the Elder.</i></p>

<p>The PDL project began in February 1996, when I decided to experiment with writing my own &#39;Data Language&#39;. I am an astronomer. My day job involves a lot of analysis of digital data accumulated on many nights observing on telescopes around the world. Such data might for example be images containing millions of pixels and thousands of images of distant stars and galaxies. Or more abstrusely, many hundreds of digital spectral revealing the secrets of the composition and properties of these distant objects.</p>

<p>Obviously many astronomers before have dealt with these problems, and a large amount of software has been constructed to facilitate their analysis. However, like many of my colleagues, I was constantly frustrated by the lack of generality and flexibility of these programs and the difficulty of doing anything out of the ordinary quickly and easily. What I wanted had a name: &#39;Data Language&#39;, i.e. a language which allowed the manipulation of large amounts of data with simple arithmetic expressions. In fact some commercial software worked like this, and I was impressed with the capabilities but not with the price tag. And I thought I could do better.</p>

<p>As a fairly computer literate astronomer (read &#39;nerd&#39; or &#39;geek&#39; according to your local argot) I was very familiar with &#39;Perl&#39;, a computer language which now seems to fill the shelves of many bookstores around the world. I was impressed by it&#39;s power and flexibility, and especially it&#39;s ease of use. I had even explored the depths of it&#39;s internals and written an interface to allow graphics - the PGPLOT module (The PGPLOT module for perl is an interface to the pgplot graphics library (written in C and FORTRAN) created by Tim Pearson of Caltech. More information about this library can be obtained from: <a href="http://astro.caltech.edu/~tjp/pgplot/">http://astro.caltech.edu/~tjp/pgplot/</a>). The ease with which I could then create charts and graphs, for my papers, was refreshing.</p>

<p>Version 5 of Perl had just been released, and I was fascinated by the new features available. Especially the support of arbitrary data structures (or &#39;objects&#39; in modern parlance) and the ability to &#39;overload&#39; operators --- i.e. make mathematical symbols like <b>+-*/</b> do whatever you felt like. It seemed to me it ought to be possible to write an extension to Perl where I could play with my data in a general way: for example using the maths operators manipulate whole images at once.</p>

<p>Well one slow night at an observatory I just thought I would try a little experiment. In a bored moment I fired up a text editor and started to create a file called <code>PDL.xs</code> - a Perl extension module to manipulate data vectors. A few hours later I actually had something half decent working, where I could add two images in the Perl language, <b>fast</b>! This was something I could not let rest, and it probably cost me one or two scientific papers worth of productivity. A few weeks later the Perl Data Language version 1.0 was born. It was a pretty bare infant: very little was there apart from the basic arithmetic operators. But encouraged I made it available on the Internet to see what people thought.</p>

<p>Well people were fairly critical - among the most vocal were Tuomas Lukka and Christian Soeller. Unfortunately for them they were both Perl enthusiasts too and soon found themselves improving my code to implement all the features they thought PDL ought to have and I had heinously neglected. PDL is a prime example of that modern phenomenon of authoring large free software packages via the Internet. Large numbers of people, most of whom have never met, have made contributions ranging for core functionality to large modules to the smallest of bug patches. PDL version 2.0 is now here (though it should perhaps have been called version 10 to reflect the amount of growth in size and functionality) and the phenomenon continues.</p>

<p>I firmly believe that PDL is a great tool for tackling general problems of data analysis. It is powerful, fast, easy to add too and freely available to anyone. I wish I had had it when I was a graduate student! I hope you too will find it of immense value, I hope it will save you from heaps of time and frustration in solving complex problems. Of course it can&#39;t do everything, but it provides the framework, the hammers and the nails for building solutions without having to reinvent wheels or levers.</p>

<p><i> - Karl Glazebrook, Sydney, Australia. 4/March/1999</i></p>

<h2 id="The-case-for-a-high-level-approach">The case for a high-level approach</h2>

<p>We&#39;ve all been there. You know how you want to analyze your data. You need to Fourier transform it, take the square root, multiply by a high-pass filter and sum up all the high frequency modes. But it&#39;s two in the morning and you are staring at the guts of your C or FORTRAN program trying to figure out why your program keeps crashing with array overflow errors. You know these problems have been solved individually innumerable times in the past, carefully written subroutines are available to do it. Why should it be so difficult?</p>

<p>The reason is though subroutines are available low-level languages still force a lot of complexity on you. You must manage memory yourself, declare variables however trivial, call subroutines with a whole bunch of arguments in case just one of them is needed, etc. And you must be able to pull together separate subroutine libraries to do file input/output, user interaction, data processing and graphics.</p>

<p>Whereas all you really want to do is tell the computer things like &#39;read this&#39;, &#39;Fourier transform that&#39;, and &#39;Plot this&#39;, and have it be smart enough to do the right thing. What you are wishing for is in effect a high-level language, in this case it is called &#39;English&#39;.</p>

<p>While natural language understanding is still quite a long way off, high-level computer languages are currently proliferating. Examples include Perl, TCL, JAVAscriptm, Visual Basic, Python, and many more. Such systems have also been developed for data processing. Worthy of note are commercial software such as <code>IDL</code> (&#39;Interactive Data Language&#39; from Exelis <a href="http://www.exelisvis.com">http://www.exelisvis.com</a>), <code>MATLAB</code> (from The Mathworks, Inc. <a href="http://www.mathworks.com">http://www.mathworks.com</a>) and the public domain program <code>Octave</code> <a href="http://www.octave.org">http://www.octave.org</a>. These implement special-purpose high-level languages where data is handled in large chunks, via &#39;vector operations&#39;.</p>

<p>What does this mean in practice? It means if you say:</p>

<pre><code>   C=A+B  </code></pre>

<p>then the operation is performed even if <code>A</code> and <code>B</code> are large arrays containing many millions of numbers. Further you can say something like:</p>

<pre><code>   D=FFT(C) </code></pre>

<p>(to apply a Fast Fourier Transform) and get what you want. No messing about. These data analysis languages also implement nice graphics layers, as well as a large suite of mathematical algorithms.</p>

<p>Having used these systems ourselves the authors of PDL can attest to the superiority of that approach in terms of plain getting things done. We of course believe that PDL is now better than all those systems, for quite a few reasons, and that your life will be easier if you get it and use it.</p>

<h2 id="The-case-for-a-free-Data-Language">The case for a free Data Language</h2>

<p>The free software community has taken off to an extraordinary extent in the few years. This has been most vivid in the success of the Linux, a free UNIX-like Operating System. Sometimes this movement is also described as &#39;Open Source&#39; rather than &#39;free,&#39; and the term &#39;free&#39; is often used to mean freedom of use rather than freedom from price. Although much of the code is indeed free/public domain money is made out of the sale of packaged distributions, support, books, etc. Nevertheless the software is usually available at minimal cost.</p>

<p>One key point is that the source code is available, so that however the software is obtained one has the ability to take it and in principle be able to change it to do whatever is required with it.</p>

<p>How is this relevant to data languages? The authors of PDL are all scientists. We write, obviously, as scientists but believe our ideas are directly relevant to all users of PDL. The scientific community has for hundreds of years believed in the free exchange of ideas. It has been traditional to publish <i>full details</i> about how research is done openly in journals. This is very close in spirit to the ideas behind the free software. These days much of what scientists do involves software, in fact large software packages to facilitate certain kinds of analysis are often the subject of major papers themselves with the software being freely available on the Internet. Such software is commonly written in C or FORTRAN to allow general use.</p>

<p>Why aren&#39;t they working at a higher level? As we explained above this would allow faster creation and make the software more portable and more easily customizable. Well in our view one of the reasons this has not happened is because of the lack of a suitable free high-level data-centric language, with powerful enough facilities.</p>

<p>This is not just a minor point, it is critical. Even if software is not published and is for internal use among a team of researchers, in the modern world the team is often distributed among dozens of individuals across many institutes and nations. The only way to ensure that all will be able to use software is if it is freely available. All the PDL authors have had direct experience with this problem in the past. We have often been hindered in sharing our code by collaborators having lack of access to software.</p>

<p>Moreover scientific work often involves extensive innovations and modifications to old ways of doing things. For software as well as being freely available it is critical to have access to the source code to permit easy customization.</p>

<p>Finally there <i>is</i> also the issue of cost. Equivalent commercial packages cost several thousand dollars per workstation. We are not anti-commercial, these packages are very powerful and useful. However we certainly think there should be something like PDL that <i>anybody</i> can use and develop for free. Science is a worldwide activity and we like to think that anybody with a PC could use PDL to do research and analysis.</p>

<p>In our view PDL - a free, public domain, Open Source, data language - meets a great need. Today it is openly developed by a group of several dozen people collaborating via the Internet. Anybody with time, expertise or dedication can contribute to improving PDL.</p>

<h2 id="So-why-Perl">So why Perl?</h2>

<p>So we chose Perl as our implementation language. Our basic data language extensions could have been built around quite a few high-level languages so why did we choose Perl? {Of course the real reason we chose Perl was because we were using it already and liked it a lot. These &#39;reasons&#39; are really &#39;compelling rationalizations&#39;!)</p>

<ol>

<li><p>We need a high-level language which looks after messy details for the user. This of course is why we don&#39;t want to use C or FORTRAN.</p>

</li>
<li><p>The language should be a commonly used and widely available on many platforms and with a good chance that you already use it for something else. Like the reader, the authors get tired of constantly have to learn new languages.</p>

</li>
<li><p>For the system to be fast and interactive the language should be able to run in an interpreted mode, i.e. commands typed can be instantly executed without having to mess around with compiling and linking. Most high-level languages offer this.</p>

</li>
<li><p>The language must be Open Source (i.e. free, in the public domain and with the source code freely available and redistributable) as we wish our data language to be Open Source too. Why? So people can use it without restrictions, share their code, make improvements to the core language as well as extensions.</p>

</li>
<li><p>The language must offer a full suite of modern features. Users of PDL don&#39;t just need access to numerical and graphics features. They also want quick and convenient access to databases, network connectivity, the World Wide Web, Object-Oriented and modular programming, graphical user interfaces, multi-process and multi-processor interactions, text handling, the list could go on for several more sentences. In fact none of the data languages mentioned above have all these features, in particular the commercial systems are hampered in their access to these features by their proprietary nature and specialist syntax. We think it is easier to add numerical features to a robust language which has all these other features than to do it the other way around.</p>

</li>
<li><p>The language must have a clean and well-documented way of incorporating new subroutines, in low-level languages such as C and FORTRAN, in to the core. First this lets us implement PDL, secondly it allows diverse groups of people to create their own PDL modules and include compiled code with their own specialist subroutines.</p>

</li>
<li><p>The language must be very easy to use, with a reasonably familiar syntax to new users. To some extent this item and the previous one are contradictory. For example the Python language, which is admirable for it&#39;s sophisticated and clean Object-Oriented model, meets all the above requirements. Indeed their is already a numerical extension - NumPy (<a href="http://numpy.scipy.org/">http://numpy.scipy.org/</a>). However in our view the syntax is a bit too strange for new users. We prefer a language where simple code can still achieve useful results and which grows with the user. We recognize of course that much of this is just a matter of preference. NumPy and SciPy have grown into a well supported set of modules, so if you are into Python, go on and use them!</p>

</li>
</ol>

<h1 id="PDL-Book-Credits">PDL Book Credits</h1>

<p>Several separate sources of material have been used to make this 2015 version of the PDL Book. The biggest source of material has been &quot;PDL - Scientific Programming in Perl&quot;, written in 2001 and added to over the past decade by Karl Glazebrook, Christian Soeller, Tuomas J. Lukka, Marc Lehmann, Jarle Brinchmann, Doug Hunt, John Cerney, Robin Williams and Tim Pickering, and several chapters written by Craig DeForest from 2009.</p>

<p>The original source was written in LaTeX and LyX, which allowed embedding of figures in the document. However, this has presented a small hurdle for other authours to add their own material. With this in mind, Matthew Kenworthy set about converting one chapter of the PDL book into POD to see what could be done, and the result didn&#39;t look too bad at all. Although this may seem to be a step back from the finer formatting of LaTeX, tags can be included in POD so that the basic documentation is readable at the command line, and there are enough filters to provide clean output in HTML and PDF formats.</p>

<p>Several other people have carried out conversion of the original book and figures into POD, and others have also contributed original new material for the PDL Book.</p>

<p>In alphabetical order, we have:</p>

<p>Joel Berger</p>

<p>Craig DeForest</p>

<p>Karl Glazebrook</p>

<p>Matthew Kenworthy</p>

<p>David Mertens</p>

<p>Chris Marshall</p>

<p>Joe Milosch</p>

<p>Creating.pod:</p>

<p>Section 2.4 from PDL LyX book by Craig DeForest POD-ed by M. Kenworthy</p>

<p>Functions:</p>

<p>Written by Matthew Kenworthy 2011</p>

<p>PGPLOT.pod:</p>

<p>Original text from &quot;PDL - Scientific Programming in Perl&quot; (2001) Chap. 4</p>

<p>Authors: Karl Glazebrook, Marc Lehmann, John Cerney, Christian Soeller, Jarle Brinchmann, Robin Williams, Christopher Marshall, Tuomas J. Lukka, Doug Hunt, Tim Pickering.</p>

<p>Modified to LyX by Chris Marshall for PDL 2.4.3, December 2006.</p>

<p>Converted to POD format by Matthew Kenworthy, May 2010.</p>

<p>PLplot:</p>

<p>Joe Milosch, also known as zentara on perlmonks, assembled this document. David Mertens, wrote most of the section and examples on Object Oriented usage, which were taken from his slide show on PLplot.</p>

<p>David Mertens&#39; slide show on <b>PDL::Graphics::PLplot</b>. His very informative slide show can be downloaded or viewed at <a href="http://www.slideshare.net/dcmertens/p-lplot-talk">http://www.slideshare.net/dcmertens/p-lplot-talk</a></p>

<p>PP.pod:</p>

<p>David Mertens &lt;dcmertens.perl@gmail.com&gt;</p>

<p>Copyright (c) 2011 David Mertens. All rights reserved.</p>

<p>This is free documentation; you can redistribute it and/or modify it under the same terms as Perl itself.</p>

<p>NDArray.pod:</p>

<p>Original text from &quot;PDL - Scientific Programming in Perl&quot; (2001) Chap. 1</p>

<p>Authors: Karl Glazebrook, Marc Lehmann, John Cerney, Christian Soeller, Jarle Brinchmann, Robin Williams, Christopher Marshall, Tuomas J. Lukka, Doug Hunt, Tim Pickering.</p>

<p>Modified to LyX by Chris Marshall for PDL 2.4.3, December 2006.</p>

<p>Converted to POD format by Mike Burns, May 2010.</p>


</body>

</html>


